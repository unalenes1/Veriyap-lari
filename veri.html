<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c2{background-color:#ffffff;max-width:451.4pt;padding:72pt 72pt 72pt 72pt}.c3{height:11pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c2"><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">SQL&gt; SET ROLE ALL;</span></p><p class="c0"><span class="c1">Role set.</span></p><p class="c0"><span class="c1">SQL&gt; SELECT COUNT(*) FROM ALL_OBJECTS;</span></p><p class="c0"><span class="c1">COUNT(*)</span></p><p class="c0"><span class="c1">----------</span></p><p class="c0"><span class="c1">68295</span></p><p class="c0"><span class="c1">SQL&gt; SET ROLE NONE;</span></p><p class="c0"><span class="c1">Role set.</span></p><p class="c0"><span class="c1">SQL&gt; SELECT COUNT(*) FROM ALL_OBJECTS;</span></p><p class="c0"><span class="c1">COUNT(*)</span></p><p class="c0"><span class="c1">----------</span></p><p class="c0"><span class="c1">53771</span></p><p class="c0"><span class="c1">Application developers should be cognizant of the effect of roles when using ALL_</span></p><p class="c0"><span class="c1">views in a stored procedure, where roles are not enabled by default.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Reference for a complete list of data dictionary</span></p><p class="c0"><span class="c1">views and their columns</span></p><p class="c0"><span class="c1">&#9632; &quot;Overview of Views&quot; on page 4-12</span></p><p class="c0"><span class="c1">See Also: Oracle Database Administrator&#39;s Guide for detailed</span></p><p class="c0"><span class="c1">information on administrative privileges</span></p><p class="c0"><span class="c1">See Also: &quot;PL/SQL Subprograms&quot; on page 8-3Overview of the Data Dictionary</span></p><p class="c0"><span class="c1">6-4 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Views with the Prefix USER_</span></p><p class="c0"><span class="c1">The views most likely to be of interest to typical database users are those with the</span></p><p class="c0"><span class="c1">prefix USER_. These views:</span></p><p class="c0"><span class="c1">&#9632; Refer to the user&#39;s private environment in the database, including metadata about</span></p><p class="c0"><span class="c1">schema objects created by the user, grants made by the user, and so on</span></p><p class="c0"><span class="c1">&#9632; Display only rows pertinent to the user, returning a subset of the information in</span></p><p class="c0"><span class="c1">the ALL_ views</span></p><p class="c0"><span class="c1">&#9632; Has columns identical to the other views, except that the column OWNER is implied</span></p><p class="c0"><span class="c1">&#9632; Can have abbreviated PUBLIC synonyms for convenience</span></p><p class="c0"><span class="c1">For example, the following query returns all the objects contained in your schema:</span></p><p class="c0"><span class="c1">SELECT OBJECT_NAME, OBJECT_TYPE</span></p><p class="c0"><span class="c1">FROM USER_OBJECTS</span></p><p class="c0"><span class="c1">ORDER BY OBJECT_NAME;</span></p><p class="c0"><span class="c1">The DUAL Table</span></p><p class="c0"><span class="c1">DUAL is a small table in the data dictionary that Oracle Database and user-written</span></p><p class="c0"><span class="c1">programs can reference to guarantee a known result. The dual table is useful when a</span></p><p class="c0"><span class="c1">value must be returned only once, for example, the current date and time. All database</span></p><p class="c0"><span class="c1">users have access to DUAL.</span></p><p class="c0"><span class="c1">The DUAL table has one column called DUMMY and one row containing the value X. The</span></p><p class="c0"><span class="c1">following example queries DUAL to perform an arithmetical operation:</span></p><p class="c0"><span class="c1">SQL&gt; SELECT ((3*4)+5)/3 FROM DUAL;</span></p><p class="c0"><span class="c1">((3*4)+5)/3</span></p><p class="c0"><span class="c1">-----------</span></p><p class="c0"><span class="c1">5.66666667</span></p><p class="c0"><span class="c1">Storage of the Data Dictionary</span></p><p class="c0"><span class="c1">The data dictionary base tables are the first objects created in any Oracle database. All</span></p><p class="c0"><span class="c1">data dictionary tables and views for a database are stored in the SYSTEM tablespace.</span></p><p class="c0"><span class="c1">Because the SYSTEM tablespace is always online when the database is open, the data</span></p><p class="c0"><span class="c1">dictionary is always available when the database is open.</span></p><p class="c0"><span class="c1">How Oracle Database Uses the Data Dictionary</span></p><p class="c0"><span class="c1">The Oracle Database user SYS owns all base tables and user-accessible views of the</span></p><p class="c0"><span class="c1">data dictionary. Data in the base tables of the data dictionary is necessary for Oracle</span></p><p class="c0"><span class="c1">Database to function. Therefore, only Oracle Database should write or change data</span></p><p class="c0"><span class="c1">dictionary information. No Oracle Database user should ever alter rows or schema</span></p><p class="c0"><span class="c1">objects contained in the SYS schema because such activity can compromise data</span></p><p class="c0"><span class="c1">integrity. The security administrator must keep strict control of this central account.</span></p><p class="c0"><span class="c1">See Also: Oracle Database SQL Language Reference for more</span></p><p class="c0"><span class="c1">information about the DUAL table</span></p><p class="c0"><span class="c1">See Also: &quot;The SYSTEM Tablespace&quot; on page 12-32 for more</span></p><p class="c0"><span class="c1">information about the SYSTEM tablespace</span></p><p class="c0"><span class="c1">Caution: Altering or manipulating the data in data dictionary</span></p><p class="c0"><span class="c1">tables can permanently and detrimentally affect database operation.Overview of the Dynamic Performance Views</span></p><p class="c0"><span class="c1">Data Dictionary and Dynamic Performance Views 6-5</span></p><p class="c0"><span class="c1">During database operation, Oracle Database reads the data dictionary to ascertain that</span></p><p class="c0"><span class="c1">schema objects exist and that users have proper access to them. Oracle Database also</span></p><p class="c0"><span class="c1">updates the data dictionary continuously to reflect changes in database structures,</span></p><p class="c0"><span class="c1">auditing, grants, and data.</span></p><p class="c0"><span class="c1">For example, if user hr creates a table named interns, then new rows are added to the</span></p><p class="c0"><span class="c1">data dictionary that reflect the new table, columns, segment, extents, and the</span></p><p class="c0"><span class="c1">privileges that hr has on the table. This new information is visible the next time the</span></p><p class="c0"><span class="c1">dictionary views are queried.</span></p><p class="c0"><span class="c1">Public Synonyms for Data Dictionary Views</span></p><p class="c0"><span class="c1">Oracle Database creates public synonyms for many data dictionary views so users can</span></p><p class="c0"><span class="c1">access them conveniently. The security administrator can also create additional public</span></p><p class="c0"><span class="c1">synonyms for schema objects that are used systemwide. Users should avoid naming</span></p><p class="c0"><span class="c1">their own schema objects with the same names as those used for public synonyms.</span></p><p class="c0"><span class="c1">Cache the Data Dictionary for Fast Access</span></p><p class="c0"><span class="c1">Much of the data dictionary information is in the data dictionary cache because the</span></p><p class="c0"><span class="c1">database constantly requires the information to validate user access and verify the</span></p><p class="c0"><span class="c1">state of schema objects. Parsing information is typically kept in the caches. The</span></p><p class="c0"><span class="c1">COMMENTS columns describing the tables and their columns are not cached in the</span></p><p class="c0"><span class="c1">dictionary cache, but may be cached in the database buffer cache.</span></p><p class="c0"><span class="c1">Other Programs and the Data Dictionary</span></p><p class="c0"><span class="c1">Other Oracle Database products can reference existing views and create additional</span></p><p class="c0"><span class="c1">data dictionary tables or views of their own. Application developers who write</span></p><p class="c0"><span class="c1">programs that refer to the data dictionary should refer to the public synonyms rather</span></p><p class="c0"><span class="c1">than the underlying tables. Synonyms are less likely to change between releases.</span></p><p class="c0"><span class="c1">Overview of the Dynamic Performance Views</span></p><p class="c0"><span class="c1">Throughout its operation, Oracle Database maintains a set of virtual tables that record</span></p><p class="c0"><span class="c1">current database activity. These views are called dynamic performance views because</span></p><p class="c0"><span class="c1">they are continuously updated while a database is open and in use. The views, also</span></p><p class="c0"><span class="c1">sometimes called V$ views, contain information such as the following:</span></p><p class="c0"><span class="c1">&#9632; System and session parameters</span></p><p class="c0"><span class="c1">&#9632; Memory usage and allocation</span></p><p class="c0"><span class="c1">&#9632; File states (including RMAN backup files)</span></p><p class="c0"><span class="c1">&#9632; Progress of jobs and tasks</span></p><p class="c0"><span class="c1">&#9632; SQL execution</span></p><p class="c0"><span class="c1">&#9632; Statistics and metrics</span></p><p class="c0"><span class="c1">The dynamic performance views have the following primary uses:</span></p><p class="c0"><span class="c1">&#9632; Oracle Enterprise Manager uses the views to obtain information about the</span></p><p class="c0"><span class="c1">database (see &quot;Oracle Enterprise Manager&quot; on page 18-2).</span></p><p class="c0"><span class="c1">See Also: &quot;SYS and SYSTEM Schemas&quot; on page 2-5</span></p><p class="c0"><span class="c1">See Also: &quot;Overview of Synonyms&quot; on page 4-22</span></p><p class="c0"><span class="c1">See Also: &quot;Data Dictionary Cache&quot; on page 14-19Database Object Metadata</span></p><p class="c0"><span class="c1">6-6 Oracle Database Concepts</span></p><p class="c0"><span class="c1">&#9632; Administrators can use the views for performance monitoring and debugging.</span></p><p class="c0"><span class="c1">Contents of the Dynamic Performance Views</span></p><p class="c0"><span class="c1">Dynamic performance views are sometimes called fixed views because they cannot be</span></p><p class="c0"><span class="c1">altered or removed by a database administrator. However, database administrators can</span></p><p class="c0"><span class="c1">query and create views on the tables and grant access to these views to other users.</span></p><p class="c0"><span class="c1">SYS owns the dynamic performance tables, whose names begin with V_$. Views are</span></p><p class="c0"><span class="c1">created on these tables, and then public synonyms prefixed with V$. For example, the</span></p><p class="c0"><span class="c1">V$DATAFILE view contains information about data files. The V$FIXED_TABLE view</span></p><p class="c0"><span class="c1">contains information about all of the dynamic performance tables and views.</span></p><p class="c0"><span class="c1">For almost every V$ view, a corresponding GV$ view exists. In Oracle Real Application</span></p><p class="c0"><span class="c1">Clusters (Oracle RAC), querying a GV$ view retrieves the V$ view information from all</span></p><p class="c0"><span class="c1">qualified database instances (see &quot;Database Server Grid&quot; on page 17-13).</span></p><p class="c0"><span class="c1">When you use the Database Configuration Assistant (DBCA) to create a database,</span></p><p class="c0"><span class="c1">Oracle automatically creates the data dictionary. Oracle Database automatically runs</span></p><p class="c0"><span class="c1">the catalog.sql script, which contains definitions of the views and public synonyms</span></p><p class="c0"><span class="c1">for the dynamic performance views. You must run catalog.sql to create these views</span></p><p class="c0"><span class="c1">and synonyms.</span></p><p class="c0"><span class="c1">Storage of the Dynamic Performance Views</span></p><p class="c0"><span class="c1">Dynamic performance views are based on virtual tables built from database memory</span></p><p class="c0"><span class="c1">structures. Thus, they are not conventional tables stored in the database. Read</span></p><p class="c0"><span class="c1">consistency is not guaranteed for the views because the data is updated dynamically.</span></p><p class="c0"><span class="c1">Because the dynamic performance views are not true tables, the data is dependent on</span></p><p class="c0"><span class="c1">the state of the database and instance. For example, you can query V$INSTANCE and</span></p><p class="c0"><span class="c1">V$BGPROCESS when the database is started but not mounted. However, you cannot</span></p><p class="c0"><span class="c1">query V$DATAFILE until the database has been mounted.</span></p><p class="c0"><span class="c1">Database Object Metadata</span></p><p class="c0"><span class="c1">The DBMS_METADATA package provides interfaces for extracting complete definitions of</span></p><p class="c0"><span class="c1">database objects. The definitions can be expressed either as XML or as SQL DDL. Two</span></p><p class="c0"><span class="c1">styles of interface are provided: a flexible, sophisticated interface for programmatic</span></p><p class="c0"><span class="c1">control, and a simplified interface for ad hoc querying.</span></p><p class="c0"><span class="c1">See Also: Oracle Database Reference for a complete list of the</span></p><p class="c0"><span class="c1">dynamic performance views</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Tools for Database Installation and Configuration&quot; on page 18-4</span></p><p class="c0"><span class="c1">to learn about DBCA</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn how to run</span></p><p class="c0"><span class="c1">catalog.sql manually</span></p><p class="c0"><span class="c1">&#9632; Oracle Real Application Clusters Administration and Deployment</span></p><p class="c0"><span class="c1">Guide to learn about using performance views in Oracle RAC</span></p><p class="c0"><span class="c1">See Also: Chapter 9, &quot;Data Concurrency and Consistency&quot;</span></p><p class="c0"><span class="c1">See Also: Oracle Database PL/SQL Packages and Types Reference for</span></p><p class="c0"><span class="c1">more information about DBMS_METADATAPart II</span></p><p class="c0"><span class="c1">Part IIOracle Data Access</span></p><p class="c0"><span class="c1">This part contains the following chapters:</span></p><p class="c0"><span class="c1">&#9632; Chapter 7, &quot;SQL&quot;</span></p><p class="c0"><span class="c1">&#9632; Chapter 8, &quot;Server-Side Programming: PL/SQL and Java&quot;7</span></p><p class="c0"><span class="c1">SQL 7-1</span></p><p class="c0"><span class="c1">SQL 7</span></p><p class="c0"><span class="c1">This chapter provides an overview of the Structured Query Language (SQL) and how</span></p><p class="c0"><span class="c1">Oracle Database processes SQL statements.</span></p><p class="c0"><span class="c1">This chapter includes the following topics:</span></p><p class="c0"><span class="c1">&#9632; Introduction to SQL</span></p><p class="c0"><span class="c1">&#9632; Overview of SQL Statements</span></p><p class="c0"><span class="c1">&#9632; Overview of the Optimizer</span></p><p class="c0"><span class="c1">&#9632; Overview of SQL Processing</span></p><p class="c0"><span class="c1">Introduction to SQL</span></p><p class="c0"><span class="c1">SQL (pronounced sequel) is the set-based, high-level declarative computer language</span></p><p class="c0"><span class="c1">with which all programs and users access data in an Oracle database. Although some</span></p><p class="c0"><span class="c1">Oracle tools and applications mask SQL use, all database operations are performed</span></p><p class="c0"><span class="c1">using SQL. Any other data access method circumvents the security built into Oracle</span></p><p class="c0"><span class="c1">Database and potentially compromises data security and integrity.</span></p><p class="c0"><span class="c1">SQL provides an interface to a relational database such as Oracle Database. SQL</span></p><p class="c0"><span class="c1">unifies tasks such as the following in one consistent language:</span></p><p class="c0"><span class="c1">&#9632; Creating, replacing, altering, and dropping objects</span></p><p class="c0"><span class="c1">&#9632; Inserting, updating, and deleting table rows</span></p><p class="c0"><span class="c1">&#9632; Querying data</span></p><p class="c0"><span class="c1">&#9632; Controlling access to the database and its objects</span></p><p class="c0"><span class="c1">&#9632; Guaranteeing database consistency and integrity</span></p><p class="c0"><span class="c1">SQL can be used interactively, which means that statements are entered manually into</span></p><p class="c0"><span class="c1">a program. SQL statements can also be embedded within a program written in a</span></p><p class="c0"><span class="c1">different language such as C or Java.</span></p><p class="c0"><span class="c1">SQL Data Access</span></p><p class="c0"><span class="c1">There are two broad families of computer languages: declarative languages that are</span></p><p class="c0"><span class="c1">nonprocedural and describe what should be done, and procedural languages such as</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database SQL Language Reference for an introduction to SQL</span></p><p class="c0"><span class="c1">&#9632; &quot;Introduction to Server-Side Programming&quot; on page 8-1 and</span></p><p class="c0"><span class="c1">&quot;Client-Side Database Programming&quot; on page 19-5Introduction to SQL</span></p><p class="c0"><span class="c1">7-2 Oracle Database Concepts</span></p><p class="c0"><span class="c1">C++ and Java that describe how things should be done. SQL is declarative in the sense</span></p><p class="c0"><span class="c1">that users specify the result that they want, not how to derive it. The SQL language</span></p><p class="c0"><span class="c1">compiler performs the work of generating a procedure to navigate the database and</span></p><p class="c0"><span class="c1">perform the desired task.</span></p><p class="c0"><span class="c1">SQL enables you to work with data at the logical level. You need be concerned with</span></p><p class="c0"><span class="c1">implementation details only when you want to manipulate the data. For example, the</span></p><p class="c0"><span class="c1">following statement queries records for employees whose last name begins with K:</span></p><p class="c0"><span class="c1">SELECT last_name, first_name</span></p><p class="c0"><span class="c1">FROM hr.employees</span></p><p class="c0"><span class="c1">WHERE last_name LIKE &#39;K%&#39;</span></p><p class="c0"><span class="c1">ORDER BY last_name, first_name;</span></p><p class="c0"><span class="c1">The database retrieves all rows satisfying the WHERE condition, also called the</span></p><p class="c0"><span class="c1">predicate, in a single step. These rows can be passed as a unit to the user, to another</span></p><p class="c0"><span class="c1">SQL statement, or to an application. You do not need to process the rows one by one,</span></p><p class="c0"><span class="c1">nor are you required to know how the rows are physically stored or retrieved.</span></p><p class="c0"><span class="c1">All SQL statements use the optimizer, a part of Oracle Database that determines the</span></p><p class="c0"><span class="c1">most efficient means of accessing the specified data. Oracle Database also supports</span></p><p class="c0"><span class="c1">techniques that you can use to make the optimizer perform its job better.</span></p><p class="c0"><span class="c1">SQL Standards</span></p><p class="c0"><span class="c1">Oracle strives to follow industry-accepted standards and participates actively in SQL</span></p><p class="c0"><span class="c1">standards committees. Industry-accepted committees are the American National</span></p><p class="c0"><span class="c1">Standards Institute (ANSI) and the International Organization for Standardization</span></p><p class="c0"><span class="c1">(ISO). Both ANSI and the ISO/IEC have accepted SQL as the standard language for</span></p><p class="c0"><span class="c1">relational databases.</span></p><p class="c0"><span class="c1">The latest SQL standard was adopted in July 2003 and is often called SQL:2003. One</span></p><p class="c0"><span class="c1">part of the SQL standard, Part 14, SQL/XML (ISO/IEC 9075-14) was revised in 2006</span></p><p class="c0"><span class="c1">and is often referred to as SQL/XML:2006.</span></p><p class="c0"><span class="c1">Oracle SQL includes many extensions to the ANSI/ISO standard SQL language, and</span></p><p class="c0"><span class="c1">Oracle Database tools and applications provide additional statements. The tools</span></p><p class="c0"><span class="c1">SQL*Plus, SQL Developer, and Oracle Enterprise Manager enable you to run any</span></p><p class="c0"><span class="c1">ANSI/ISO standard SQL statement against an Oracle database and any additional</span></p><p class="c0"><span class="c1">statements or functions available for those tools.</span></p><p class="c0"><span class="c1">See Also: Oracle Database SQL Language Reference for detailed</span></p><p class="c0"><span class="c1">information about SQL statements and other parts of SQL (such as</span></p><p class="c0"><span class="c1">operators, functions, and format models)</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database SQL Language Reference for an explanation of the</span></p><p class="c0"><span class="c1">differences between Oracle SQL and standard SQL</span></p><p class="c0"><span class="c1">&#9632; SQL*Plus User&#39;s Guide and Reference for SQL*Plus commands,</span></p><p class="c0"><span class="c1">including their distinction from SQL statements</span></p><p class="c0"><span class="c1">&#9632; &quot;Tools for Database Administrators&quot; on page 18-2 and &quot;Tools for</span></p><p class="c0"><span class="c1">Database Developers&quot; on page 19-1Overview of SQL Statements</span></p><p class="c0"><span class="c1">SQL 7-3</span></p><p class="c0"><span class="c1">Overview of SQL Statements</span></p><p class="c0"><span class="c1">All operations performed on the information in an Oracle database are run using SQL</span></p><p class="c0"><span class="c1">statements. A SQL statement is a computer program or instruction that consists of</span></p><p class="c0"><span class="c1">identifiers, parameters, variables, names, data types, and SQL reserved words.</span></p><p class="c0"><span class="c1">A SQL statement must be the equivalent of a complete SQL sentence, such as:</span></p><p class="c0"><span class="c1">SELECT last_name, department_id FROM employees</span></p><p class="c0"><span class="c1">Oracle Database only runs complete SQL statements. A fragment such as the following</span></p><p class="c0"><span class="c1">generates an error indicating that more text is required:</span></p><p class="c0"><span class="c1">SELECT last_name;</span></p><p class="c0"><span class="c1">Oracle SQL statements are divided into the following categories:</span></p><p class="c0"><span class="c1">&#9632; Data Definition Language (DDL) Statements</span></p><p class="c0"><span class="c1">&#9632; Data Manipulation Language (DML) Statements</span></p><p class="c0"><span class="c1">&#9632; Transaction Control Statements</span></p><p class="c0"><span class="c1">&#9632; Session Control Statements</span></p><p class="c0"><span class="c1">&#9632; System Control Statement</span></p><p class="c0"><span class="c1">&#9632; Embedded SQL Statements</span></p><p class="c0"><span class="c1">Data Definition Language (DDL) Statements</span></p><p class="c0"><span class="c1">Data definition language (DDL) statements define, structurally change, and drop</span></p><p class="c0"><span class="c1">schema objects. For example, DDL statements enable you to:</span></p><p class="c0"><span class="c1">&#9632; Create, alter, and drop schema objects and other database structures, including the</span></p><p class="c0"><span class="c1">database itself and database users. Most DDL statements start with the keywords</span></p><p class="c0"><span class="c1">CREATE, ALTER, or DROP.</span></p><p class="c0"><span class="c1">&#9632; Delete all the data in schema objects without removing the structure of these</span></p><p class="c0"><span class="c1">objects (TRUNCATE).</span></p><p class="c0"><span class="c1">&#9632; Grant and revoke privileges and roles (GRANT, REVOKE).</span></p><p class="c0"><span class="c1">&#9632; Turn auditing options on and off (AUDIT, NOAUDIT).</span></p><p class="c0"><span class="c1">&#9632; Add a comment to the data dictionary (COMMENT).</span></p><p class="c0"><span class="c1">DDL enables you to alter attributes of an object without altering the applications that</span></p><p class="c0"><span class="c1">access the object. For example, you can add a column to a table accessed by a human</span></p><p class="c0"><span class="c1">resources application without rewriting the application. You can also use DDL to alter</span></p><p class="c0"><span class="c1">the structure of objects while database users are performing work in the database.</span></p><p class="c0"><span class="c1">Note: SQL reserved words have special meaning in SQL and should</span></p><p class="c0"><span class="c1">not be used for any other purpose. For example, SELECT and UPDATE</span></p><p class="c0"><span class="c1">are reserved words and should not be used as table names.</span></p><p class="c0"><span class="c1">Note: Unlike DELETE, TRUNCATE generates no undo data, which</span></p><p class="c0"><span class="c1">makes it faster than DELETE. Also, TRUNCATE does not invoke delete</span></p><p class="c0"><span class="c1">triggers.Overview of SQL Statements</span></p><p class="c0"><span class="c1">7-4 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Example 7&ndash;1 uses DDL statements to create the plants table and then uses DML to</span></p><p class="c0"><span class="c1">insert two rows in the table. The example then uses DDL to alter the table structure,</span></p><p class="c0"><span class="c1">grant and revoke privileges on this table to a user, and then drop the table.</span></p><p class="c0"><span class="c1">Example 7&ndash;1 DDL Statements</span></p><p class="c0"><span class="c1">CREATE TABLE plants</span></p><p class="c0"><span class="c1">( plant_id NUMBER PRIMARY KEY,</span></p><p class="c0"><span class="c1">common_name VARCHAR2(15) );</span></p><p class="c0"><span class="c1">INSERT INTO plants VALUES (1, &#39;African Violet&#39;); # DML statement</span></p><p class="c0"><span class="c1">INSERT INTO plants VALUES (2, &#39;Amaryllis&#39;); # DML statement</span></p><p class="c0"><span class="c1">ALTER TABLE plants ADD</span></p><p class="c0"><span class="c1">( latin_name VARCHAR2(40) );</span></p><p class="c0"><span class="c1">GRANT SELECT ON plants TO scott;</span></p><p class="c0"><span class="c1">REVOKE SELECT ON plants FROM scott;</span></p><p class="c0"><span class="c1">DROP TABLE plants;</span></p><p class="c0"><span class="c1">An implicit COMMIT occurs immediately before the database executes a DDL statement</span></p><p class="c0"><span class="c1">and a COMMIT or ROLLBACK occurs immediately afterward. In Example 7&ndash;1, two INSERT</span></p><p class="c0"><span class="c1">statements are followed by an ALTER TABLE statement, so the database commits the</span></p><p class="c0"><span class="c1">two INSERT statements. If the ALTER TABLE statement succeeds, then the database</span></p><p class="c0"><span class="c1">commits this statement; otherwise, the database rolls back this statement. In either case</span></p><p class="c0"><span class="c1">the two INSERT statements have already been committed.</span></p><p class="c0"><span class="c1">Data Manipulation Language (DML) Statements</span></p><p class="c0"><span class="c1">Data manipulation language (DML) statements query or manipulate data in existing</span></p><p class="c0"><span class="c1">schema objects. Whereas DDL statements enable you to change the structure of the</span></p><p class="c0"><span class="c1">database, DML statements enable you to query or change the contents. For example,</span></p><p class="c0"><span class="c1">ALTER TABLE changes the structure of a table, whereas INSERT adds one or more rows</span></p><p class="c0"><span class="c1">to the table.</span></p><p class="c0"><span class="c1">DML statements are the most frequently used SQL statements and enable you to:</span></p><p class="c0"><span class="c1">&#9632; Retrieve or fetch data from one or more tables or views (SELECT).</span></p><p class="c0"><span class="c1">&#9632; Add new rows of data into a table or view (INSERT) by specifying a list of column</span></p><p class="c0"><span class="c1">values or using a subquery to select and manipulate existing data.</span></p><p class="c0"><span class="c1">&#9632; Change column values in existing rows of a table or view (UPDATE).</span></p><p class="c0"><span class="c1">&#9632; Update or insert rows conditionally into a table or view (MERGE).</span></p><p class="c0"><span class="c1">&#9632; Remove rows from tables or views (DELETE).</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Overview of Database Security&quot; on page 17-1 to learn about</span></p><p class="c0"><span class="c1">privileges and roles</span></p><p class="c0"><span class="c1">&#9632; Oracle Database 2 Day Developer&#39;s Guide and Oracle Database</span></p><p class="c0"><span class="c1">Administrator&#39;s Guide to learn how to create schema objects</span></p><p class="c0"><span class="c1">&#9632; Oracle Database SQL Language Reference for a list of DDL</span></p><p class="c0"><span class="c1">statementsOverview of SQL Statements</span></p><p class="c0"><span class="c1">SQL 7-5</span></p><p class="c0"><span class="c1">&#9632; View the execution plan for a SQL statement (EXPLAIN PLAN). See &quot;How Oracle</span></p><p class="c0"><span class="c1">Database Processes DML&quot; on page 7-22.</span></p><p class="c0"><span class="c1">&#9632; Lock a table or view, temporarily limiting access by other users (LOCK TABLE).</span></p><p class="c0"><span class="c1">The following example uses DML to query the employees table. The example uses</span></p><p class="c0"><span class="c1">DML to insert a row into employees, update this row, and then delete it:</span></p><p class="c0"><span class="c1">SELECT * FROM employees;</span></p><p class="c0"><span class="c1">INSERT INTO employees (employee_id, last_name, email, job_id, hire_date, salary)</span></p><p class="c0"><span class="c1">VALUES (1234, &#39;Mascis&#39;, &#39;JMASCIS&#39;, &#39;IT_PROG&#39;, &#39;14-FEB-2011&#39;, 9000);</span></p><p class="c0"><span class="c1">UPDATE employees SET salary=9100 WHERE employee_id=1234;</span></p><p class="c0"><span class="c1">DELETE FROM employees WHERE employee_id=1234;</span></p><p class="c0"><span class="c1">A collection of DML statements that forms a logical unit of work is called a</span></p><p class="c0"><span class="c1">transaction. For example, a transaction to transfer money could involve three discrete</span></p><p class="c0"><span class="c1">operations: decreasing the savings account balance, increasing the checking account</span></p><p class="c0"><span class="c1">balance, and recording the transfer in an account history table. Unlike DDL</span></p><p class="c0"><span class="c1">statements, DML statements do not implicitly commit the current transaction.</span></p><p class="c0"><span class="c1">SELECT Statements</span></p><p class="c0"><span class="c1">A query is an operation that retrieves data from a table or view. SELECT is the only SQL</span></p><p class="c0"><span class="c1">statement that you can use to query data. The set of data retrieved from execution of a</span></p><p class="c0"><span class="c1">SELECT statement is known as a result set.</span></p><p class="c0"><span class="c1">Table 7&ndash;1 shows two required keywords and two keywords that are commonly found</span></p><p class="c0"><span class="c1">in a SELECT statement. The table also associates capabilities of a SELECT statement with</span></p><p class="c0"><span class="c1">the keywords.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Introduction to Transactions&quot; on page 10-1</span></p><p class="c0"><span class="c1">&#9632; Oracle Database 2 Day Developer&#39;s Guide to learn how to query and</span></p><p class="c0"><span class="c1">manipulate data</span></p><p class="c0"><span class="c1">&#9632; Oracle Database SQL Language Reference for a list of DML</span></p><p class="c0"><span class="c1">statements</span></p><p class="c0"><span class="c1">Table 7&ndash;1 Keywords in a SQL Statement</span></p><p class="c0"><span class="c1">Keyword Required? Description Capability</span></p><p class="c0"><span class="c1">SELECT Yes Specifies which columns should be shown in the</span></p><p class="c0"><span class="c1">result. Projection produces a subset of the columns in</span></p><p class="c0"><span class="c1">the table.</span></p><p class="c0"><span class="c1">An expression is a combination of one or more values,</span></p><p class="c0"><span class="c1">operators, and SQL functions that resolves to a value.</span></p><p class="c0"><span class="c1">The list of expressions that appears after the SELECT</span></p><p class="c0"><span class="c1">keyword and before the FROM clause is called the select</span></p><p class="c0"><span class="c1">list.</span></p><p class="c0"><span class="c1">Projection</span></p><p class="c0"><span class="c1">FROM Yes Specifies the tables or views from which the data</span></p><p class="c0"><span class="c1">should be retrieved.</span></p><p class="c0"><span class="c1">Joining</span></p><p class="c0"><span class="c1">WHERE No Specifies a condition to filter rows, producing a subset</span></p><p class="c0"><span class="c1">of the rows in the table. A condition specifies a</span></p><p class="c0"><span class="c1">combination of one or more expressions and logical</span></p><p class="c0"><span class="c1">(Boolean) operators and returns a value of TRUE, FALSE,</span></p><p class="c0"><span class="c1">or UNKNOWN.</span></p><p class="c0"><span class="c1">SelectionOverview of SQL Statements</span></p><p class="c0"><span class="c1">7-6 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Joins</span></p><p class="c0"><span class="c1">A join is a query that combines rows from two or more tables, views, or materialized</span></p><p class="c0"><span class="c1">views. Example 7&ndash;2 joins the employees and departments tables (FROM clause), selects</span></p><p class="c0"><span class="c1">only rows that meet specified criteria (WHERE clause), and uses projection to retrieve</span></p><p class="c0"><span class="c1">data from two columns (SELECT). Sample output follows the SQL statement.</span></p><p class="c0"><span class="c1">Example 7&ndash;2 Sample Join</span></p><p class="c0"><span class="c1">SELECT email, department_name</span></p><p class="c0"><span class="c1">FROM employees JOIN departments</span></p><p class="c0"><span class="c1">ON employees.department_id = departments.department_id</span></p><p class="c0"><span class="c1">WHERE employee_id IN (100,103)</span></p><p class="c0"><span class="c1">ORDER BY email;</span></p><p class="c0"><span class="c1">EMAIL DEPARTMENT_NAME</span></p><p class="c0"><span class="c1">------------------------- ------------------------------</span></p><p class="c0"><span class="c1">AHUNOLD IT</span></p><p class="c0"><span class="c1">SKING Executive</span></p><p class="c0"><span class="c1">Figure 7&ndash;1 graphically represents the operations of projection and selection in the join</span></p><p class="c0"><span class="c1">shown in Example 7&ndash;2.</span></p><p class="c0"><span class="c1">Figure 7&ndash;1 Projection and Selection</span></p><p class="c0"><span class="c1">Most joins have at least one join condition, either in the FROM clause or in the WHERE</span></p><p class="c0"><span class="c1">clause, that compares two columns, each from a different table. The database combines</span></p><p class="c0"><span class="c1">pairs of rows, each containing one row from each table, for which the join condition</span></p><p class="c0"><span class="c1">ORDER BY No Specifies the order in which the rows should be</span></p><p class="c0"><span class="c1">shown.</span></p><p class="c0"><span class="c1">See Also: Oracle Database SQL Language Reference for SELECT syntax</span></p><p class="c0"><span class="c1">and semantics</span></p><p class="c0"><span class="c1">Table 7&ndash;1 (Cont.) Keywords in a SQL Statement</span></p><p class="c0"><span class="c1">Keyword Required? Description Capability</span></p><p class="c0"><span class="c1">Table DEPARTMENTS</span></p><p class="c0"><span class="c1">DEPARTMENT_ID DEPARTMENT_NAME MANAGER_ID LOCATION_ID</span></p><p class="c0"><span class="c1">103</span></p><p class="c0"><span class="c1">100</span></p><p class="c0"><span class="c1">1400</span></p><p class="c0"><span class="c1">1700</span></p><p class="c0"><span class="c1">60</span></p><p class="c0"><span class="c1">90</span></p><p class="c0"><span class="c1">IT</span></p><p class="c0"><span class="c1">Executive</span></p><p class="c0"><span class="c1">EMPLOYEE_ID LAST_NAME HIRE_DATE JOB_ID MANAGER_ID DEPARTMENT_ID</span></p><p class="c0"><span class="c1">Table EMPLOYEES</span></p><p class="c0"><span class="c1">17-JUN-87</span></p><p class="c0"><span class="c1">21-SEP-89</span></p><p class="c0"><span class="c1">13-JAN-93</span></p><p class="c0"><span class="c1">03-JAN-90</span></p><p class="c0"><span class="c1">SELECT email,department_name</span></p><p class="c0"><span class="c1">FROM employees JOIN</span></p><p class="c0"><span class="c1">departments</span></p><p class="c0"><span class="c1">ON employees.department_id =</span></p><p class="c0"><span class="c1">departments.department_id</span></p><p class="c0"><span class="c1">WHERE employee_id IN (100,103)</span></p><p class="c0"><span class="c1">ORDER BY email</span></p><p class="c0"><span class="c1">EMAIL</span></p><p class="c0"><span class="c1">King</span></p><p class="c0"><span class="c1">Kochhar</span></p><p class="c0"><span class="c1">De Hann</span></p><p class="c0"><span class="c1">Hunold</span></p><p class="c0"><span class="c1">100</span></p><p class="c0"><span class="c1">101</span></p><p class="c0"><span class="c1">102</span></p><p class="c0"><span class="c1">103</span></p><p class="c0"><span class="c1">SKING</span></p><p class="c0"><span class="c1">NKOCHHAR</span></p><p class="c0"><span class="c1">LDEHANN</span></p><p class="c0"><span class="c1">AHUNOLD</span></p><p class="c0"><span class="c1">AD_PRES</span></p><p class="c0"><span class="c1">AD_VP</span></p><p class="c0"><span class="c1">AD_VP</span></p><p class="c0"><span class="c1">IT_PROG</span></p><p class="c0"><span class="c1">100</span></p><p class="c0"><span class="c1">100</span></p><p class="c0"><span class="c1">102</span></p><p class="c0"><span class="c1">90</span></p><p class="c0"><span class="c1">90</span></p><p class="c0"><span class="c1">90</span></p><p class="c0"><span class="c1">60</span></p><p class="c0"><span class="c1">Projection</span></p><p class="c0"><span class="c1">SelectionOverview of SQL Statements</span></p><p class="c0"><span class="c1">SQL 7-7</span></p><p class="c0"><span class="c1">evaluates to TRUE. The optimizer determines the order in which the database joins</span></p><p class="c0"><span class="c1">tables based on the join conditions, indexes, and any available statistics for the tables.</span></p><p class="c0"><span class="c1">Join types include the following:</span></p><p class="c0"><span class="c1">&#9632; Inner joins</span></p><p class="c0"><span class="c1">An inner join is a join of two or more tables that returns only rows that satisfy the</span></p><p class="c0"><span class="c1">join condition. For example, if the join condition is</span></p><p class="c0"><span class="c1">employees.department_id=departments.department_id, then rows that do not</span></p><p class="c0"><span class="c1">satisfy this condition are not returned.</span></p><p class="c0"><span class="c1">&#9632; Outer joins</span></p><p class="c0"><span class="c1">An outer join returns all rows that satisfy the join condition and also returns rows</span></p><p class="c0"><span class="c1">from one table for which no rows from the other table satisfy the condition. For</span></p><p class="c0"><span class="c1">example, a left outer join of employees and departments retrieves all rows in the</span></p><p class="c0"><span class="c1">employees table even if there is no match in departments. A right outer join</span></p><p class="c0"><span class="c1">retrieves all rows in departments even if there is no match in employees.</span></p><p class="c0"><span class="c1">&#9632; Cartesian products</span></p><p class="c0"><span class="c1">If two tables in a join query have no join condition, then the database returns their</span></p><p class="c0"><span class="c1">Cartesian product. Each row of one table combines with each row of the other. For</span></p><p class="c0"><span class="c1">example, if employees has 107 rows and departments has 27, then the Cartesian</span></p><p class="c0"><span class="c1">product contains 107*27 rows. A Cartesian product is rarely useful.</span></p><p class="c0"><span class="c1">Subqueries and Implicit Queries</span></p><p class="c0"><span class="c1">A subquery is a SELECT statement nested within another SQL statement. Subqueries</span></p><p class="c0"><span class="c1">are useful when you must execute multiple queries to solve a single problem.</span></p><p class="c0"><span class="c1">Each query portion of a statement is called a query block. In Example 7&ndash;3, the</span></p><p class="c0"><span class="c1">subquery in parentheses is the inner query block. The inner SELECT statement</span></p><p class="c0"><span class="c1">retrieves the IDs of departments with location ID 1800. These department IDs are</span></p><p class="c0"><span class="c1">needed by the outer query block, which retrieves names of employees in the</span></p><p class="c0"><span class="c1">departments whose IDs were supplied by the subquery.</span></p><p class="c0"><span class="c1">Example 7&ndash;3 Subquery</span></p><p class="c0"><span class="c1">SELECT first_name, last_name</span></p><p class="c0"><span class="c1">FROM employees</span></p><p class="c0"><span class="c1">WHERE department_id</span></p><p class="c0"><span class="c1">IN (SELECT department_id FROM departments WHERE location_id = 1800);</span></p><p class="c0"><span class="c1">The structure of the SQL statement does not force the database to execute the inner</span></p><p class="c0"><span class="c1">query first. For example, the database could rewrite the entire query as a join of</span></p><p class="c0"><span class="c1">employees and departments, so that the subquery never executes by itself. As another</span></p><p class="c0"><span class="c1">example, the Virtual Private Database (VPD) feature could restrict the query of</span></p><p class="c0"><span class="c1">employees using a WHERE clause, so that the database decides to query the employees</span></p><p class="c0"><span class="c1">first and then obtain the department IDs. The optimizer determines the best sequence</span></p><p class="c0"><span class="c1">of steps to retrieve the requested rows.</span></p><p class="c0"><span class="c1">An implicit query is a component of a DML statement that retrieves data without</span></p><p class="c0"><span class="c1">using a subquery. An UPDATE, DELETE, or MERGE statement that does not explicitly</span></p><p class="c0"><span class="c1">include a SELECT statement uses an implicit query to retrieve rows to be modified. For</span></p><p class="c0"><span class="c1">example, the following statement includes an implicit query for the Baer record:</span></p><p class="c0"><span class="c1">UPDATE employees</span></p><p class="c0"><span class="c1">See Also: Oracle Database SQL Language Reference for detailed</span></p><p class="c0"><span class="c1">descriptions and examples of joinsOverview of SQL Statements</span></p><p class="c0"><span class="c1">7-8 Oracle Database Concepts</span></p><p class="c0"><span class="c1">SET salary = salary*1.1</span></p><p class="c0"><span class="c1">WHERE last_name = &#39;Baer&#39;;</span></p><p class="c0"><span class="c1">The only DML statement that does not necessarily include a query component is an</span></p><p class="c0"><span class="c1">INSERT statement with a VALUES clause. For example, an INSERT INTO TABLE mytable</span></p><p class="c0"><span class="c1">VALUES (1) statement does not retrieve rows before inserting a row.</span></p><p class="c0"><span class="c1">Transaction Control Statements</span></p><p class="c0"><span class="c1">Transaction control statements manage the changes made by DML statements and</span></p><p class="c0"><span class="c1">group DML statements into transactions. These statements enable you to:</span></p><p class="c0"><span class="c1">&#9632; Make changes to a transaction permanent (COMMIT).</span></p><p class="c0"><span class="c1">&#9632; Undo the changes in a transaction, since the transaction started (ROLLBACK) or since</span></p><p class="c0"><span class="c1">a savepoint (ROLLBACK TO SAVEPOINT). A savepoint is a user-declared</span></p><p class="c0"><span class="c1">intermediate marker within the context of a transaction.</span></p><p class="c0"><span class="c1">&#9632; Set a point to which you can roll back (SAVEPOINT).</span></p><p class="c0"><span class="c1">&#9632; Establish properties for a transaction (SET TRANSACTION).</span></p><p class="c0"><span class="c1">&#9632; Specify whether a deferrable integrity constraint is checked following each DML</span></p><p class="c0"><span class="c1">statement or when the transaction is committed (SET CONSTRAINT).</span></p><p class="c0"><span class="c1">The following example starts a transaction named Update salaries. The example</span></p><p class="c0"><span class="c1">creates a savepoint, updates an employee salary, and then rolls back the transaction to</span></p><p class="c0"><span class="c1">the savepoint. The example updates the salary to a different value and commits.</span></p><p class="c0"><span class="c1">SET TRANSACTION NAME &#39;Update salaries&#39;;</span></p><p class="c0"><span class="c1">SAVEPOINT before_salary_update;</span></p><p class="c0"><span class="c1">UPDATE employees SET salary=9100 WHERE employee_id=1234 # DML</span></p><p class="c0"><span class="c1">ROLLBACK TO SAVEPOINT before_salary_update;</span></p><p class="c0"><span class="c1">UPDATE employees SET salary=9200 WHERE employee_id=1234 # DML</span></p><p class="c0"><span class="c1">COMMIT COMMENT &#39;Updated salaries&#39;;</span></p><p class="c0"><span class="c1">Session Control Statements</span></p><p class="c0"><span class="c1">Session control statements dynamically manage the properties of a user session. As</span></p><p class="c0"><span class="c1">explained in &quot;Connections and Sessions&quot; on page 15-4, a session is a logical entity in</span></p><p class="c0"><span class="c1">the database instance memory that represents the state of a current user login to a</span></p><p class="c0"><span class="c1">See Also: &quot;Virtual Private Database (VPD)&quot; on page 17-6</span></p><p class="c0"><span class="c1">Note: The ROLLBACK command ends a transaction, but ROLLBACK TO</span></p><p class="c0"><span class="c1">SAVEPOINT does not.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Introduction to Transactions&quot; on page 10-1</span></p><p class="c0"><span class="c1">&#9632; &quot;Deferrable Constraints&quot; on page 5-11</span></p><p class="c0"><span class="c1">&#9632; Oracle Database SQL Language ReferenceOverview of SQL Statements</span></p><p class="c0"><span class="c1">SQL 7-9</span></p><p class="c0"><span class="c1">database. A session lasts from the time the user is authenticated by the database until</span></p><p class="c0"><span class="c1">the user disconnects or exits the database application.</span></p><p class="c0"><span class="c1">Session control statements enable you to:</span></p><p class="c0"><span class="c1">&#9632; Alter the current session by performing a specialized function, such as enabling</span></p><p class="c0"><span class="c1">and disabling SQL tracing (ALTER SESSION).</span></p><p class="c0"><span class="c1">&#9632; Enable and disable roles, which are groups of privileges, for the current session</span></p><p class="c0"><span class="c1">(SET ROLE).</span></p><p class="c0"><span class="c1">The following example turns on SQL tracing for the session and then enables all roles</span></p><p class="c0"><span class="c1">granted in the current session except dw_manager:</span></p><p class="c0"><span class="c1">ALTER SESSION SET SQL_TRACE = TRUE;</span></p><p class="c0"><span class="c1">SET ROLE ALL EXCEPT dw_manager;</span></p><p class="c0"><span class="c1">Session control statements do not implicitly commit the current transaction.</span></p><p class="c0"><span class="c1">System Control Statement</span></p><p class="c0"><span class="c1">System control statements change the properties of the database instance. The only</span></p><p class="c0"><span class="c1">system control statement is ALTER SYSTEM. It enables you to change settings such as the</span></p><p class="c0"><span class="c1">minimum number of shared servers, terminate a session, and perform other</span></p><p class="c0"><span class="c1">system-level tasks.</span></p><p class="c0"><span class="c1">Following are examples of system control statements:</span></p><p class="c0"><span class="c1">ALTER SYSTEM SWITCH LOGFILE;</span></p><p class="c0"><span class="c1">ALTER SYSTEM KILL SESSION &#39;39, 23&#39;;</span></p><p class="c0"><span class="c1">The ALTER SYSTEM statement does not implicitly commit the current transaction.</span></p><p class="c0"><span class="c1">Embedded SQL Statements</span></p><p class="c0"><span class="c1">Embedded SQL statements incorporate DDL, DML, and transaction control statements</span></p><p class="c0"><span class="c1">within a procedural language program. They are used with the Oracle precompilers.</span></p><p class="c0"><span class="c1">Embedded SQL is one approach to incorporating SQL in your procedural language</span></p><p class="c0"><span class="c1">applications. Another approach is to use a procedural API such as Open Database</span></p><p class="c0"><span class="c1">Connectivity (ODBC) or Java Database Connectivity (JDBC).</span></p><p class="c0"><span class="c1">Embedded SQL statements enable you to:</span></p><p class="c0"><span class="c1">&#9632; Define, allocate, and release cursors (DECLARE CURSOR, OPEN, CLOSE).</span></p><p class="c0"><span class="c1">&#9632; Specify a database and connect to it (DECLARE DATABASE, CONNECT).</span></p><p class="c0"><span class="c1">&#9632; Assign variable names (DECLARE STATEMENT).</span></p><p class="c0"><span class="c1">&#9632; Initialize descriptors (DESCRIBE).</span></p><p class="c0"><span class="c1">&#9632; Specify how error and warning conditions are handled (WHENEVER).</span></p><p class="c0"><span class="c1">&#9632; Parse and run SQL statements (PREPARE, EXECUTE, EXECUTE IMMEDIATE).</span></p><p class="c0"><span class="c1">&#9632; Retrieve data from the database (FETCH).</span></p><p class="c0"><span class="c1">See Also: Oracle Database SQL Language Reference for ALTER SESSION</span></p><p class="c0"><span class="c1">syntax and semantics</span></p><p class="c0"><span class="c1">See Also: Oracle Database SQL Language Reference for ALTER SYSTEM</span></p><p class="c0"><span class="c1">syntax and semanticsOverview of the Optimizer</span></p><p class="c0"><span class="c1">7-10 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Overview of the Optimizer</span></p><p class="c0"><span class="c1">To understand how Oracle Database processes SQL statements, it is necessary to</span></p><p class="c0"><span class="c1">understand the part of the database called the optimizer (also known as the query</span></p><p class="c0"><span class="c1">optimizer or cost-based optimizer). All SQL statements use the optimizer to</span></p><p class="c0"><span class="c1">determine the most efficient means of accessing the specified data.</span></p><p class="c0"><span class="c1">Use of the Optimizer</span></p><p class="c0"><span class="c1">To execute a DML statement, Oracle Database may have to perform many steps. Each</span></p><p class="c0"><span class="c1">step either retrieves rows of data physically from the database or prepares them for the</span></p><p class="c0"><span class="c1">user issuing the statement.</span></p><p class="c0"><span class="c1">Many different ways of processing a DML statement are often possible. For example,</span></p><p class="c0"><span class="c1">the order in which tables or indexes are accessed can vary. The steps that the database</span></p><p class="c0"><span class="c1">uses to execute a statement greatly affect how quickly the statement runs. The</span></p><p class="c0"><span class="c1">optimizer generates execution plans describing possible methods of execution.</span></p><p class="c0"><span class="c1">The optimizer determines which execution plan is most efficient by considering</span></p><p class="c0"><span class="c1">several sources of information, including query conditions, available access paths,</span></p><p class="c0"><span class="c1">statistics gathered for the system, and hints. For any SQL statement processed by</span></p><p class="c0"><span class="c1">Oracle, the optimizer performs the following operations:</span></p><p class="c0"><span class="c1">&#9632; Evaluation of expressions and conditions</span></p><p class="c0"><span class="c1">&#9632; Inspection of integrity constraints to learn more about the data and optimize based</span></p><p class="c0"><span class="c1">on this metadata</span></p><p class="c0"><span class="c1">&#9632; Statement transformation</span></p><p class="c0"><span class="c1">&#9632; Choice of optimizer goals</span></p><p class="c0"><span class="c1">&#9632; Choice of access paths</span></p><p class="c0"><span class="c1">&#9632; Choice of join orders</span></p><p class="c0"><span class="c1">The optimizer generates most of the possible ways of processing a query and assigns a</span></p><p class="c0"><span class="c1">cost to each step in the generated execution plan. The plan with the lowest cost is</span></p><p class="c0"><span class="c1">chosen as the query plan to be executed.</span></p><p class="c0"><span class="c1">You can influence optimizer choices by setting the optimizer goal and by gathering</span></p><p class="c0"><span class="c1">representative statistics for the optimizer. For example, you may set the optimizer goal</span></p><p class="c0"><span class="c1">to either of the following:</span></p><p class="c0"><span class="c1">&#9632; Total throughput</span></p><p class="c0"><span class="c1">The ALL_ROWS hint instructs the optimizer to get the last row of the result to the</span></p><p class="c0"><span class="c1">client application as fast as possible.</span></p><p class="c0"><span class="c1">&#9632; Initial response time</span></p><p class="c0"><span class="c1">The FIRST_ROWS hint instructs the optimizer to get the first row to the client as fast</span></p><p class="c0"><span class="c1">as possible.</span></p><p class="c0"><span class="c1">See Also: &quot;Introduction to Server-Side Programming&quot; on page 8-1</span></p><p class="c0"><span class="c1">and &quot;Client-Side APIs&quot; on page 19-7</span></p><p class="c0"><span class="c1">Note: You can obtain an execution plan for a SQL statement without</span></p><p class="c0"><span class="c1">executing the plan. Only an execution plan that the database actually</span></p><p class="c0"><span class="c1">uses to execute a query is correctly termed a query plan.Overview of the Optimizer</span></p><p class="c0"><span class="c1">SQL 7-11</span></p><p class="c0"><span class="c1">A typical end-user, interactive application would benefit from initial response time</span></p><p class="c0"><span class="c1">optimization, whereas a batch-mode, non-interactive application would benefit from</span></p><p class="c0"><span class="c1">total throughput optimization.</span></p><p class="c0"><span class="c1">Optimizer Components</span></p><p class="c0"><span class="c1">The optimizer contains three main components, which are shown in Figure 7&ndash;2.</span></p><p class="c0"><span class="c1">Figure 7&ndash;2 Optimizer Components</span></p><p class="c0"><span class="c1">The input to the optimizer is a parsed query (see &quot;SQL Parsing&quot; on page 7-16). The</span></p><p class="c0"><span class="c1">optimizer performs the following operations:</span></p><p class="c0"><span class="c1">1. The optimizer receives the parsed query and generates a set of potential plans for</span></p><p class="c0"><span class="c1">the SQL statement based on available access paths and hints.</span></p><p class="c0"><span class="c1">2. The optimizer estimates the cost of each plan based on statistics in the data</span></p><p class="c0"><span class="c1">dictionary. The cost is an estimated value proportional to the expected resource</span></p><p class="c0"><span class="c1">use needed to execute the statement with a particular plan.</span></p><p class="c0"><span class="c1">3. The optimizer compares the costs of plans and chooses the lowest-cost plan,</span></p><p class="c0"><span class="c1">known as the query plan, to pass to the row source generator (see &quot;SQL Row</span></p><p class="c0"><span class="c1">Source Generation&quot; on page 7-19).</span></p><p class="c0"><span class="c1">Query Transformer</span></p><p class="c0"><span class="c1">The query transformer determines whether it is helpful to change the form of the</span></p><p class="c0"><span class="c1">query so that the optimizer can generate a better execution plan. The input to the</span></p><p class="c0"><span class="c1">query transformer is a parsed query, which is represented by a set of query blocks.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database PL/SQL Packages and Types Reference for</span></p><p class="c0"><span class="c1">information about using DBMS_STATS</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Performance Tuning Guide for more information</span></p><p class="c0"><span class="c1">about the optimizer and using hints</span></p><p class="c0"><span class="c1">Query</span></p><p class="c0"><span class="c1">Transformer</span></p><p class="c0"><span class="c1">Estimator</span></p><p class="c0"><span class="c1">Plan</span></p><p class="c0"><span class="c1">Generator</span></p><p class="c0"><span class="c1">Parsed Query</span></p><p class="c0"><span class="c1">(from Parser)</span></p><p class="c0"><span class="c1">Query Plan</span></p><p class="c0"><span class="c1">(to Row Source Generator)</span></p><p class="c0"><span class="c1">Transformed query</span></p><p class="c0"><span class="c1">Query + estimates</span></p><p class="c0"><span class="c1">Data</span></p><p class="c0"><span class="c1">Dictionary</span></p><p class="c0"><span class="c1">statisticsOverview of the Optimizer</span></p><p class="c0"><span class="c1">7-12 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Estimator</span></p><p class="c0"><span class="c1">The estimator determines the overall cost of a given execution plan. The estimator</span></p><p class="c0"><span class="c1">generates three different types of measures to achieve this goal:</span></p><p class="c0"><span class="c1">&#9632; Selectivity</span></p><p class="c0"><span class="c1">This measure represents a fraction of rows from a row set. The selectivity is tied to</span></p><p class="c0"><span class="c1">a query predicate, such as last_name=&#39;Smith&#39;, or a combination of predicates.</span></p><p class="c0"><span class="c1">&#9632; Cardinality</span></p><p class="c0"><span class="c1">This measure represents the number of rows in a row set.</span></p><p class="c0"><span class="c1">&#9632; Cost</span></p><p class="c0"><span class="c1">This measure represents units of work or resource used. The query optimizer uses</span></p><p class="c0"><span class="c1">disk I/O, CPU usage, and memory usage as units of work.</span></p><p class="c0"><span class="c1">If statistics are available, then the estimator uses them to compute the measures. The</span></p><p class="c0"><span class="c1">statistics improve the degree of accuracy of the measures.</span></p><p class="c0"><span class="c1">Plan Generator</span></p><p class="c0"><span class="c1">The plan generator tries out different plans for a submitted query and picks the plan</span></p><p class="c0"><span class="c1">with the lowest cost. The optimizer generates subplans for each of the nested</span></p><p class="c0"><span class="c1">subqueries and unmerged views, which is represented by a separate query block. The</span></p><p class="c0"><span class="c1">plan generator explores various plans for a query block by trying out different access</span></p><p class="c0"><span class="c1">paths, join methods, and join orders.</span></p><p class="c0"><span class="c1">The optimizer automatically manages plans and ensures that only verified plans are</span></p><p class="c0"><span class="c1">used. SQL Plan Management (SPM) allows controlled plan evolution by only using a</span></p><p class="c0"><span class="c1">new plan after it has been verified to be perform better than the current plan.</span></p><p class="c0"><span class="c1">Diagnostic tools such as the EXPLAIN PLAN statement enable you to view execution</span></p><p class="c0"><span class="c1">plans chosen by the optimizer. EXPLAIN PLAN shows the query plan for the specified</span></p><p class="c0"><span class="c1">SQL query if it were executed now in the current session. Other diagnostic tools are</span></p><p class="c0"><span class="c1">Oracle Enterprise Manager and the SQL*Plus AUTOTRACE command. Example 7&ndash;6 on</span></p><p class="c0"><span class="c1">page 7-20 shows the execution plan of a query when AUTOTRACE is enabled.</span></p><p class="c0"><span class="c1">Access Paths</span></p><p class="c0"><span class="c1">An access path is the way in which data is retrieved from the database. For example, a</span></p><p class="c0"><span class="c1">query that uses an index has a different access path from a query that does not. In</span></p><p class="c0"><span class="c1">general, index access paths are best for statements that retrieve a small subset of table</span></p><p class="c0"><span class="c1">rows. Full scans are more efficient for accessing a large portion of a table.</span></p><p class="c0"><span class="c1">The database can use several different access paths to retrieve data from a table. The</span></p><p class="c0"><span class="c1">following is a representative list:</span></p><p class="c0"><span class="c1">&#9632; Full table scans</span></p><p class="c0"><span class="c1">See Also: &quot;Query Rewrite&quot; on page 4-19</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Tools for Database Administrators&quot; on page 18-2</span></p><p class="c0"><span class="c1">&#9632; Oracle Database SQL Language Reference to learn about EXPLAIN</span></p><p class="c0"><span class="c1">PLAN</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Performance Tuning Guide to learn about the</span></p><p class="c0"><span class="c1">optimizer componentsOverview of the Optimizer</span></p><p class="c0"><span class="c1">SQL 7-13</span></p><p class="c0"><span class="c1">This type of scan reads all rows from a table and filters out those that do not meet</span></p><p class="c0"><span class="c1">the selection criteria. The database sequentially scans all data blocks in the</span></p><p class="c0"><span class="c1">segment, including those under the high water mark that separates used from</span></p><p class="c0"><span class="c1">unused space (see &quot;Segment Space and the High Water Mark&quot; on page 12-27).</span></p><p class="c0"><span class="c1">&#9632; Rowid scans</span></p><p class="c0"><span class="c1">The rowid of a row specifies the data file and data block containing the row and</span></p><p class="c0"><span class="c1">the location of the row in that block. The database first obtains the rowids of the</span></p><p class="c0"><span class="c1">selected rows, either from the statement WHERE clause or through an index scan,</span></p><p class="c0"><span class="c1">and then locates each selected row based on its rowid.</span></p><p class="c0"><span class="c1">&#9632; Index scans</span></p><p class="c0"><span class="c1">This scan searches an index for the indexed column values accessed by the SQL</span></p><p class="c0"><span class="c1">statement (see &quot;Index Scans&quot; on page 3-6). If the statement accesses only columns</span></p><p class="c0"><span class="c1">of the index, then Oracle Database reads the indexed column values directly from</span></p><p class="c0"><span class="c1">the index.</span></p><p class="c0"><span class="c1">&#9632; Cluster scans</span></p><p class="c0"><span class="c1">A cluster scan is used to retrieve data from a table stored in an indexed table</span></p><p class="c0"><span class="c1">cluster, where all rows with the same cluster key value are stored in the same data</span></p><p class="c0"><span class="c1">block (see &quot;Overview of Indexed Clusters&quot; on page 2-23). The database first</span></p><p class="c0"><span class="c1">obtains the rowid of a selected row by scanning the cluster index. Oracle Database</span></p><p class="c0"><span class="c1">locates the rows based on this rowid.</span></p><p class="c0"><span class="c1">&#9632; Hash scans</span></p><p class="c0"><span class="c1">A hash scan is used to locate rows in a hash cluster, where all rows with the same</span></p><p class="c0"><span class="c1">hash value are stored in the same data block (see &quot;Overview of Hash Clusters&quot; on</span></p><p class="c0"><span class="c1">page 2-25. The database first obtains the hash value by applying a hash function</span></p><p class="c0"><span class="c1">to a cluster key value specified by the statement. Oracle Database then scans the</span></p><p class="c0"><span class="c1">data blocks containing rows with this hash value.</span></p><p class="c0"><span class="c1">The optimizer chooses an access path based on the available access paths for the</span></p><p class="c0"><span class="c1">statement and the estimated cost of using each access path or combination of paths.</span></p><p class="c0"><span class="c1">Optimizer Statistics</span></p><p class="c0"><span class="c1">Optimizer statistics are a collection of data that describe details about the database</span></p><p class="c0"><span class="c1">and the objects in the database. The statistics provide a statistically correct picture of</span></p><p class="c0"><span class="c1">data storage and distribution usable by the optimizer when evaluating access paths.</span></p><p class="c0"><span class="c1">Optimizer statistics include the following:</span></p><p class="c0"><span class="c1">&#9632; Table statistics</span></p><p class="c0"><span class="c1">These include the number of rows, number of blocks, and average row length.</span></p><p class="c0"><span class="c1">&#9632; Column statistics</span></p><p class="c0"><span class="c1">These include the number of distinct values and nulls in a column and the</span></p><p class="c0"><span class="c1">distribution of data.</span></p><p class="c0"><span class="c1">&#9632; Index statistics</span></p><p class="c0"><span class="c1">These include the number of leaf blocks and index levels.</span></p><p class="c0"><span class="c1">&#9632; System statistics</span></p><p class="c0"><span class="c1">These include CPU and I/O performance and utilization.</span></p><p class="c0"><span class="c1">See Also: Oracle Database 2 Day + Performance Tuning Guide and</span></p><p class="c0"><span class="c1">Oracle Database Performance Tuning Guide to learn about access pathsOverview of the Optimizer</span></p><p class="c0"><span class="c1">7-14 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Oracle Database gathers optimizer statistics on all database objects automatically and</span></p><p class="c0"><span class="c1">maintains these statistics as an automated maintenance task. You can also gather</span></p><p class="c0"><span class="c1">statistics manually using the DBMS_STATS package. This PL/SQL package can modify,</span></p><p class="c0"><span class="c1">view, export, import, and delete statistics.</span></p><p class="c0"><span class="c1">Optimizer statistics are created for the purposes of query optimization and are stored</span></p><p class="c0"><span class="c1">in the data dictionary. These statistics should not be confused with performance</span></p><p class="c0"><span class="c1">statistics visible through dynamic performance views.</span></p><p class="c0"><span class="c1">Optimizer Hints</span></p><p class="c0"><span class="c1">A hint is a comment in a SQL statement that acts as an instruction to the optimizer.</span></p><p class="c0"><span class="c1">Sometimes the application designer, who has more information about a particular</span></p><p class="c0"><span class="c1">application&#39;s data than is available to the optimizer, can choose a more effective way to</span></p><p class="c0"><span class="c1">run a SQL statement. The application designer can use hints in SQL statements to</span></p><p class="c0"><span class="c1">specify how the statement should be run.</span></p><p class="c0"><span class="c1">For example, suppose that your interactive application runs a query that returns 50</span></p><p class="c0"><span class="c1">rows. This application initially fetches only the first 25 rows of the query to present to</span></p><p class="c0"><span class="c1">the end user. You want the optimizer to generate a plan that gets the first 25 records as</span></p><p class="c0"><span class="c1">quickly as possible so that the user is not forced to wait. You can use a hint to pass this</span></p><p class="c0"><span class="c1">instruction to the optimizer as shown in the SELECT statement and AUTOTRACE output in</span></p><p class="c0"><span class="c1">Example 7&ndash;4.</span></p><p class="c0"><span class="c1">Example 7&ndash;4 Execution Plan for SELECT with FIRST_ROWS Hint</span></p><p class="c0"><span class="c1">SELECT /*+ FIRST_ROWS(25) */ employee_id, department_id</span></p><p class="c0"><span class="c1">FROM hr.employees</span></p><p class="c0"><span class="c1">WHERE department_id &gt; 50;</span></p><p class="c0"><span class="c1">------------------------------------------------------------------------</span></p><p class="c0"><span class="c1">| Id | Operation | Name | Rows | Bytes</span></p><p class="c0"><span class="c1">------------------------------------------------------------------------</span></p><p class="c0"><span class="c1">| 0 | SELECT STATEMENT | | 26 | 182</span></p><p class="c0"><span class="c1">| 1 | TABLE ACCESS BY INDEX ROWID | EMPLOYEES | 26 | 182</span></p><p class="c0"><span class="c1">|* 2 | INDEX RANGE SCAN | EMP_DEPARTMENT_IX | |</span></p><p class="c0"><span class="c1">------------------------------------------------------------------------</span></p><p class="c0"><span class="c1">The execution plan in Example 7&ndash;4 shows that the optimizer chooses an index on the</span></p><p class="c0"><span class="c1">employees.department_id column to find the first 25 rows of employees whose</span></p><p class="c0"><span class="c1">department ID is over 50. The optimizer uses the rowid retrieved from the index to</span></p><p class="c0"><span class="c1">retrieve the record from the employees table and return it to the client. Retrieval of the</span></p><p class="c0"><span class="c1">first record is typically almost instantaneous.</span></p><p class="c0"><span class="c1">Example 7&ndash;5 shows the same statement, but without the optimizer hint.</span></p><p class="c0"><span class="c1">Example 7&ndash;5 Execution Plan for SELECT with No Hint</span></p><p class="c0"><span class="c1">SELECT employee_id, department_id</span></p><p class="c0"><span class="c1">FROM hr.employees</span></p><p class="c0"><span class="c1">WHERE department_id &gt; 50;</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database 2 Day + Performance Tuning Guide and Oracle</span></p><p class="c0"><span class="c1">Database Performance Tuning Guide to learn how to gather and</span></p><p class="c0"><span class="c1">manage statistics</span></p><p class="c0"><span class="c1">&#9632; Oracle Database PL/SQL Packages and Types Reference to learn about</span></p><p class="c0"><span class="c1">DBMS_STATSOverview of SQL Processing</span></p><p class="c0"><span class="c1">SQL 7-15</span></p><p class="c0"><span class="c1">------------------------------------------------------------------------</span></p><p class="c0"><span class="c1">| Id | Operation | Name | Rows | Bytes | Cos</span></p><p class="c0"><span class="c1">------------------------------------------------------------------------</span></p><p class="c0"><span class="c1">| 0 | SELECT STATEMENT | | 50 | 350 |</span></p><p class="c0"><span class="c1">|* 1 | VIEW | index$_join$_001 | 50 | 350 |</span></p><p class="c0"><span class="c1">|* 2 | HASH JOIN | | | |</span></p><p class="c0"><span class="c1">|* 3 | INDEX RANGE SCAN | EMP_DEPARTMENT_IX | 50 | 350 |</span></p><p class="c0"><span class="c1">| 4 | INDEX FAST FULL SCAN| EMP_EMP_ID_PK | 50 | 350 |</span></p><p class="c0"><span class="c1">The execution plan in Example 7&ndash;5 joins two indexes to return the requested records as</span></p><p class="c0"><span class="c1">fast as possible. Rather than repeatedly going from index to table as in Example 7&ndash;4,</span></p><p class="c0"><span class="c1">the optimizer chooses a range scan of EMP_DEPARTMENT_IX to find all rows where the</span></p><p class="c0"><span class="c1">department ID is over 50 and place these rows in a hash table. The optimizer then</span></p><p class="c0"><span class="c1">chooses to read the EMP_EMP_ID_PK index. For each row in this index, it probes the hash</span></p><p class="c0"><span class="c1">table to find the department ID.</span></p><p class="c0"><span class="c1">In this case, the database cannot return the first row to the client until the index range</span></p><p class="c0"><span class="c1">scan of EMP_DEPARTMENT_IX completes. Thus, this generated plan would take longer to</span></p><p class="c0"><span class="c1">return the first record. Unlike the plan in Example 7&ndash;4, which accesses the table by</span></p><p class="c0"><span class="c1">index rowid, the plan in Example 7&ndash;5 uses multiblock I/O, resulting in large reads.</span></p><p class="c0"><span class="c1">The reads enable the last row of the entire result set to be returned more rapidly.</span></p><p class="c0"><span class="c1">Overview of SQL Processing</span></p><p class="c0"><span class="c1">This section explains how Oracle Database processes SQL statements. Specifically, the</span></p><p class="c0"><span class="c1">section explains the way in which the database processes DDL statements to create</span></p><p class="c0"><span class="c1">objects, DML to modify data, and queries to retrieve data.</span></p><p class="c0"><span class="c1">Stages of SQL Processing</span></p><p class="c0"><span class="c1">Figure 7&ndash;3 depicts the general stages of SQL processing: parsing, optimization, row</span></p><p class="c0"><span class="c1">source generation, and execution. Depending on the statement, the database may omit</span></p><p class="c0"><span class="c1">some of these steps.</span></p><p class="c0"><span class="c1">See Also: Oracle Database Performance Tuning Guide to learn how to</span></p><p class="c0"><span class="c1">use optimizer hintsOverview of SQL Processing</span></p><p class="c0"><span class="c1">7-16 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Figure 7&ndash;3 Stages of SQL Processing</span></p><p class="c0"><span class="c1">SQL Parsing</span></p><p class="c0"><span class="c1">As shown in Figure 7&ndash;3, the first stage of SQL processing is parsing. This stage</span></p><p class="c0"><span class="c1">involves separating the pieces of a SQL statement into a data structure that can be</span></p><p class="c0"><span class="c1">processed by other routines. The database parses a statement when instructed by the</span></p><p class="c0"><span class="c1">application, which means that only the application, and not the database itself, can</span></p><p class="c0"><span class="c1">reduce the number of parses.</span></p><p class="c0"><span class="c1">When an application issues a SQL statement, the application makes a parse call to the</span></p><p class="c0"><span class="c1">database to prepare the statement for execution. The parse call opens or creates a</span></p><p class="c0"><span class="c1">cursor, which is a handle for the session-specific private SQL area that holds a parsed</span></p><p class="c0"><span class="c1">SQL statement and other processing information. The cursor and private SQL area are</span></p><p class="c0"><span class="c1">in the PGA.</span></p><p class="c0"><span class="c1">During the parse call, the database performs the following checks:</span></p><p class="c0"><span class="c1">&#9632; Syntax Check</span></p><p class="c0"><span class="c1">&#9632; Semantic Check</span></p><p class="c0"><span class="c1">&#9632; Shared Pool Check</span></p><p class="c0"><span class="c1">The preceding checks identify the errors that can be found before statement execution.</span></p><p class="c0"><span class="c1">Some errors cannot be caught by parsing. For example, the database can encounter</span></p><p class="c0"><span class="c1">deadlocks or errors in data conversion only during statement execution (see &quot;Locks</span></p><p class="c0"><span class="c1">Generation of</span></p><p class="c0"><span class="c1">multiple</span></p><p class="c0"><span class="c1">execution plans</span></p><p class="c0"><span class="c1">Generation of</span></p><p class="c0"><span class="c1">query plan</span></p><p class="c0"><span class="c1">Parsing</span></p><p class="c0"><span class="c1">Optimization</span></p><p class="c0"><span class="c1">Row Source</span></p><p class="c0"><span class="c1">Generation</span></p><p class="c0"><span class="c1">Execution</span></p><p class="c0"><span class="c1">Hard Parse</span></p><p class="c0"><span class="c1">Soft Parse</span></p><p class="c0"><span class="c1">Semantic</span></p><p class="c0"><span class="c1">Check</span></p><p class="c0"><span class="c1">Syntax</span></p><p class="c0"><span class="c1">Check</span></p><p class="c0"><span class="c1">Shared Pool</span></p><p class="c0"><span class="c1">Check</span></p><p class="c0"><span class="c1">SQL StatementOverview of SQL Processing</span></p><p class="c0"><span class="c1">SQL 7-17</span></p><p class="c0"><span class="c1">and Deadlocks&quot; on page 9-16).</span></p><p class="c0"><span class="c1">Syntax Check Oracle Database must check each SQL statement for syntactic validity. A</span></p><p class="c0"><span class="c1">statement that breaks a rule for well-formed SQL syntax fails the check. For example,</span></p><p class="c0"><span class="c1">the following statement fails because the keyword FROM is misspelled as FORM:</span></p><p class="c0"><span class="c1">SQL&gt; SELECT * FORM employees;</span></p><p class="c0"><span class="c1">SELECT * FORM employees</span></p><p class="c0"><span class="c1">*</span></p><p class="c0"><span class="c1">ERROR at line 1:</span></p><p class="c0"><span class="c1">ORA-00923: FROM keyword not found where expected</span></p><p class="c0"><span class="c1">Semantic Check The semantics of a statement are its meaning. Thus, a semantic check</span></p><p class="c0"><span class="c1">determines whether a statement is meaningful, for example, whether the objects and</span></p><p class="c0"><span class="c1">columns in the statement exist. A syntactically correct statement can fail a semantic</span></p><p class="c0"><span class="c1">check, as shown in the following example of a query of a nonexistent table:</span></p><p class="c0"><span class="c1">SQL&gt; SELECT * FROM nonexistent_table;</span></p><p class="c0"><span class="c1">SELECT * FROM nonexistent_table</span></p><p class="c0"><span class="c1">*</span></p><p class="c0"><span class="c1">ERROR at line 1:</span></p><p class="c0"><span class="c1">ORA-00942: table or view does not exist</span></p><p class="c0"><span class="c1">Shared Pool Check During the parse, the database performs a shared pool check to</span></p><p class="c0"><span class="c1">determine whether it can skip resource-intensive steps of statement processing. To this</span></p><p class="c0"><span class="c1">end, the database uses a hashing algorithm to generate a hash value for every SQL</span></p><p class="c0"><span class="c1">statement. The statement hash value is the SQL ID shown in V$SQL.SQL_ID.</span></p><p class="c0"><span class="c1">When a user submits a SQL statement, the database searches the shared SQL area to</span></p><p class="c0"><span class="c1">see if an existing parsed statement has the same hash value. The hash value of a SQL</span></p><p class="c0"><span class="c1">statement is distinct from the following values:</span></p><p class="c0"><span class="c1">&#9632; Memory address for the statement</span></p><p class="c0"><span class="c1">Oracle Database uses the SQL ID to perform a keyed read in a lookup table. In this</span></p><p class="c0"><span class="c1">way, the database obtains possible memory addresses of the statement.</span></p><p class="c0"><span class="c1">&#9632; Hash value of an execution plan for the statement</span></p><p class="c0"><span class="c1">A SQL statement can have multiple plans in the shared pool. Each plan has a</span></p><p class="c0"><span class="c1">different hash value. If the same SQL ID has multiple plan hash values, then the</span></p><p class="c0"><span class="c1">database knows that multiple plans exist for this SQL ID.</span></p><p class="c0"><span class="c1">Parse operations fall into the following categories, depending on the type of statement</span></p><p class="c0"><span class="c1">submitted and the result of the hash check:</span></p><p class="c0"><span class="c1">&#9632; Hard parse</span></p><p class="c0"><span class="c1">If Oracle Database cannot reuse existing code, then it must build a new executable</span></p><p class="c0"><span class="c1">version of the application code. This operation is known as a hard parse, or a</span></p><p class="c0"><span class="c1">library cache miss. The database always perform a hard parse of DDL.</span></p><p class="c0"><span class="c1">During the hard parse, the database accesses the library cache and data dictionary</span></p><p class="c0"><span class="c1">cache numerous times to check the data dictionary. When the database accesses</span></p><p class="c0"><span class="c1">these areas, it uses a serialization device called a latch on required objects so that</span></p><p class="c0"><span class="c1">their definition does not change (see &quot;Latches&quot; on page 9-25). Latch contention</span></p><p class="c0"><span class="c1">increases statement execution time and decreases concurrency.</span></p><p class="c0"><span class="c1">&#9632; Soft parse</span></p><p class="c0"><span class="c1">A soft parse is any parse that is not a hard parse. If the submitted statement is the</span></p><p class="c0"><span class="c1">same as a reusable SQL statement in the shared pool, then Oracle Database reuses</span></p><p class="c0"><span class="c1">the existing code. This reuse of code is also called a library cache hit.Overview of SQL Processing</span></p><p class="c0"><span class="c1">7-18 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Soft parses can vary in the amount of work they perform. For example,</span></p><p class="c0"><span class="c1">configuring the session shared SQL area can sometimes reduce the amount of</span></p><p class="c0"><span class="c1">latching in the soft parses, making them &quot;softer.&quot;</span></p><p class="c0"><span class="c1">In general, a soft parse is preferable to a hard parse because the database skips the</span></p><p class="c0"><span class="c1">optimization and row source generation steps, proceeding straight to execution.</span></p><p class="c0"><span class="c1">Figure 7&ndash;4 is a simplified representation of a shared pool check of an UPDATE statement</span></p><p class="c0"><span class="c1">in a dedicated server architecture.</span></p><p class="c0"><span class="c1">Figure 7&ndash;4 Shared Pool Check</span></p><p class="c0"><span class="c1">If a check determines that a statement in the shared pool has the same hash value, then</span></p><p class="c0"><span class="c1">the database performs semantic and environment checks to determine whether the</span></p><p class="c0"><span class="c1">statements have the same meaning. Identical syntax is not sufficient. For example,</span></p><p class="c0"><span class="c1">suppose two different users log in to the database and issue the following SQL</span></p><p class="c0"><span class="c1">statements:</span></p><p class="c0"><span class="c1">CREATE TABLE my_table ( some_col INTEGER );</span></p><p class="c0"><span class="c1">SELECT * FROM my_table;</span></p><p class="c0"><span class="c1">The SELECT statements for the two users are syntactically identical, but two separate</span></p><p class="c0"><span class="c1">schema objects are named my_table. This semantic difference means that the second</span></p><p class="c0"><span class="c1">statement cannot reuse the code for the first statement.</span></p><p class="c0"><span class="c1">Even if two statements are semantically identical, an environmental difference can</span></p><p class="c0"><span class="c1">force a hard parse. In this case, the environment is the totality of session settings that</span></p><p class="c0"><span class="c1">can affect execution plan generation, such as the work area size or optimizer settings.</span></p><p class="c0"><span class="c1">Consider the following series of SQL statements executed by a single user:</span></p><p class="c0"><span class="c1">ALTER SYSTEM FLUSH SHARED_POOL;</span></p><p class="c0"><span class="c1">SELECT * FROM my_table;</span></p><p class="c0"><span class="c1">ALTER SESSION SET OPTIMIZER_MODE=FIRST_ROWS;</span></p><p class="c0"><span class="c1">SELECT * FROM my_table;</span></p><p class="c0"><span class="c1">Comparison of hash values</span></p><p class="c0"><span class="c1">User</span></p><p class="c0"><span class="c1">Server</span></p><p class="c0"><span class="c1">Process</span></p><p class="c0"><span class="c1">Client</span></p><p class="c0"><span class="c1">Process</span></p><p class="c0"><span class="c1">Private SQL Area</span></p><p class="c0"><span class="c1">User</span></p><p class="c0"><span class="c1">Update ...</span></p><p class="c0"><span class="c1">PGA</span></p><p class="c0"><span class="c1">SQL Work Areas</span></p><p class="c0"><span class="c1">Session Memory 3967354608</span></p><p class="c0"><span class="c1">System Global Area (SGA)</span></p><p class="c0"><span class="c1">Shared Pool</span></p><p class="c0"><span class="c1">Private</span></p><p class="c0"><span class="c1">SQL Area</span></p><p class="c0"><span class="c1">Shared SQL Area</span></p><p class="c0"><span class="c1">3667723989</span></p><p class="c0"><span class="c1">3967354608</span></p><p class="c0"><span class="c1">2190280494</span></p><p class="c0"><span class="c1">Library Cache</span></p><p class="c0"><span class="c1">Data</span></p><p class="c0"><span class="c1">Dictionary</span></p><p class="c0"><span class="c1">Cache</span></p><p class="c0"><span class="c1">Server</span></p><p class="c0"><span class="c1">Result</span></p><p class="c0"><span class="c1">Cache</span></p><p class="c0"><span class="c1">Other Reserved</span></p><p class="c0"><span class="c1">PoolOverview of SQL Processing</span></p><p class="c0"><span class="c1">SQL 7-19</span></p><p class="c0"><span class="c1">ALTER SESSION SET SQL_TRACE=TRUE;</span></p><p class="c0"><span class="c1">SELECT * FROM my_table;</span></p><p class="c0"><span class="c1">In the preceding example, the same SELECT statement is executed in three different</span></p><p class="c0"><span class="c1">optimizer environments. Consequently, the database creates three separate shared SQL</span></p><p class="c0"><span class="c1">areas for these statements and forces a hard parse of each statement.</span></p><p class="c0"><span class="c1">SQL Optimization</span></p><p class="c0"><span class="c1">As explained in &quot;Overview of the Optimizer&quot; on page 7-10, query optimization is the</span></p><p class="c0"><span class="c1">process of choosing the most efficient means of executing a SQL statement. The</span></p><p class="c0"><span class="c1">database optimizes queries based on statistics collected about the actual data being</span></p><p class="c0"><span class="c1">accessed. The optimizer uses the number of rows, the size of the data set, and other</span></p><p class="c0"><span class="c1">factors to generate possible execution plans, assigning a numeric cost to each plan. The</span></p><p class="c0"><span class="c1">database uses the plan with the lowest cost.</span></p><p class="c0"><span class="c1">The database must perform a hard parse at least once for every unique DML statement</span></p><p class="c0"><span class="c1">and performs optimization during this parse. DDL is never optimized unless it</span></p><p class="c0"><span class="c1">includes a DML component such as a subquery that requires optimization.</span></p><p class="c0"><span class="c1">SQL Row Source Generation</span></p><p class="c0"><span class="c1">The row source generator is software that receives the optimal execution plan from the</span></p><p class="c0"><span class="c1">optimizer and produces an iterative plan, called the query plan, that is usable by the</span></p><p class="c0"><span class="c1">rest of the database. The iterative plan is a binary program that, when executed by the</span></p><p class="c0"><span class="c1">SQL virtual machine, produces the result set.</span></p><p class="c0"><span class="c1">The query plan takes the form of a combination of steps. Each step returns a row set.</span></p><p class="c0"><span class="c1">The rows in this set are either used by the next step or, in the last step, are returned to</span></p><p class="c0"><span class="c1">the application issuing the SQL statement.</span></p><p class="c0"><span class="c1">A row source is a row set returned by a step in the execution plan along with a control</span></p><p class="c0"><span class="c1">structure that can iteratively process the rows. The row source can be a table, view, or</span></p><p class="c0"><span class="c1">result of a join or grouping operation.</span></p><p class="c0"><span class="c1">The row source generator produces a row source tree, which is a collection of row</span></p><p class="c0"><span class="c1">sources. The row source tree shows the following information:</span></p><p class="c0"><span class="c1">&#9632; An ordering of the tables referenced by the statement</span></p><p class="c0"><span class="c1">&#9632; An access method for each table mentioned in the statement</span></p><p class="c0"><span class="c1">&#9632; A join method for tables affected by join operations in the statement</span></p><p class="c0"><span class="c1">&#9632; Data operations such as filter, sort, or aggregation</span></p><p class="c0"><span class="c1">Example 7&ndash;6 shows the execution plan of a SELECT statement when AUTOTRACE is</span></p><p class="c0"><span class="c1">enabled. The statement selects the last name, job title, and department name for all</span></p><p class="c0"><span class="c1">employees whose last names begin with the letter A. The execution plan for this</span></p><p class="c0"><span class="c1">statement is the output of the row source generator.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Private SQL Area&quot; on page 14-5 and &quot;Shared SQL Areas&quot; on</span></p><p class="c0"><span class="c1">page 14-16</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Performance Tuning Guide to learn how to</span></p><p class="c0"><span class="c1">configure the shared pool</span></p><p class="c0"><span class="c1">See Also: Oracle Database Performance Tuning Guide for detailed</span></p><p class="c0"><span class="c1">information about the query optimizerOverview of SQL Processing</span></p><p class="c0"><span class="c1">7-20 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Example 7&ndash;6 Execution Plan</span></p><p class="c0"><span class="c1">SELECT e.last_name, j.job_title, d.department_name</span></p><p class="c0"><span class="c1">FROM hr.employees e, hr.departments d, hr.jobs j</span></p><p class="c0"><span class="c1">WHERE e.department_id = d.department_id</span></p><p class="c0"><span class="c1">AND e.job_id = j.job_id</span></p><p class="c0"><span class="c1">AND e.last_name LIKE &#39;A%&#39; ;</span></p><p class="c0"><span class="c1">Execution Plan</span></p><p class="c0"><span class="c1">----------------------------------------------------------</span></p><p class="c0"><span class="c1">Plan hash value: 975837011</span></p><p class="c0"><span class="c1">---------------------------------------------------------------------------------------------</span></p><p class="c0"><span class="c1">| Id | Operation | Name | Rows | Bytes | Cost (%CPU)| Time |</span></p><p class="c0"><span class="c1">---------------------------------------------------------------------------------------------</span></p><p class="c0"><span class="c1">| 0 | SELECT STATEMENT | | 3 | 189 | 7 (15)| 00:00:01 |</span></p><p class="c0"><span class="c1">|* 1 | HASH JOIN | | 3 | 189 | 7 (15)| 00:00:01 |</span></p><p class="c0"><span class="c1">|* 2 | HASH JOIN | | 3 | 141 | 5 (20)| 00:00:01 |</span></p><p class="c0"><span class="c1">| 3 | TABLE ACCESS BY INDEX ROWID| EMPLOYEES | 3 | 60 | 2 (0)| 00:00:01 |</span></p><p class="c0"><span class="c1">|* 4 | INDEX RANGE SCAN | EMP_NAME_IX | 3 | | 1 (0)| 00:00:01 |</span></p><p class="c0"><span class="c1">| 5 | TABLE ACCESS FULL | JOBS | 19 | 513 | 2 (0)| 00:00:01 |</span></p><p class="c0"><span class="c1">| 6 | TABLE ACCESS FULL | DEPARTMENTS | 27 | 432 | 2 (0)| 00:00:01 |</span></p><p class="c0"><span class="c1">---------------------------------------------------------------------------------------------</span></p><p class="c0"><span class="c1">Predicate Information (identified by operation id):</span></p><p class="c0"><span class="c1">---------------------------------------------------</span></p><p class="c0"><span class="c1">1 - access(&quot;E&quot;.&quot;DEPARTMENT_ID&quot;=&quot;D&quot;.&quot;DEPARTMENT_ID&quot;)</span></p><p class="c0"><span class="c1">2 - access(&quot;E&quot;.&quot;JOB_ID&quot;=&quot;J&quot;.&quot;JOB_ID&quot;)</span></p><p class="c0"><span class="c1">4 - access(&quot;E&quot;.&quot;LAST_NAME&quot; LIKE &#39;A%&#39;)</span></p><p class="c0"><span class="c1">filter(&quot;E&quot;.&quot;LAST_NAME&quot; LIKE &#39;A%&#39;)</span></p><p class="c0"><span class="c1">SQL Execution</span></p><p class="c0"><span class="c1">During execution, the SQL engine executes each row source in the tree produced by</span></p><p class="c0"><span class="c1">the row source generator. This step is the only mandatory step in DML processing.</span></p><p class="c0"><span class="c1">Figure 7&ndash;5 is an execution tree, also called a parse tree, that shows the flow of row</span></p><p class="c0"><span class="c1">sources from one step to another. In general, the order of the steps in execution is the</span></p><p class="c0"><span class="c1">reverse of the order in the plan, so you read the plan from the bottom up. Initial spaces</span></p><p class="c0"><span class="c1">in the Operation column indicate hierarchical relationships. For example, if the name</span></p><p class="c0"><span class="c1">of an operation is preceded by two spaces, then this operation is a child of an</span></p><p class="c0"><span class="c1">operation preceded by one space. Operations preceded by one space are children of</span></p><p class="c0"><span class="c1">the SELECT statement itself.Overview of SQL Processing</span></p><p class="c0"><span class="c1">SQL 7-21</span></p><p class="c0"><span class="c1">Figure 7&ndash;5 Row Source Tree</span></p><p class="c0"><span class="c1">In Figure 7&ndash;5, each node of the tree acts as a row source, which means that each step of</span></p><p class="c0"><span class="c1">the execution plan either retrieves rows from the database or accepts rows from one or</span></p><p class="c0"><span class="c1">more row sources as input. The SQL engine executes each row source as follows:</span></p><p class="c0"><span class="c1">&#9632; Steps indicated by the black boxes physically retrieve data from an object in the</span></p><p class="c0"><span class="c1">database. These steps are the access paths, or techniques for retrieving data from</span></p><p class="c0"><span class="c1">the database.</span></p><p class="c0"><span class="c1">&ndash; Step 6 uses a full table scan to retrieve all rows from the departments table.</span></p><p class="c0"><span class="c1">&ndash; Step 5 uses a full table scan to retrieve all rows from the jobs table.</span></p><p class="c0"><span class="c1">&ndash; Step 4 scans the emp_name_ix index in order, looking for each key that begins</span></p><p class="c0"><span class="c1">with the letter A and retrieving the corresponding rowid (see &quot;Index Range</span></p><p class="c0"><span class="c1">Scan&quot; on page 3-7). For example, the rowid corresponding to Atkinson is</span></p><p class="c0"><span class="c1">AAAPzRAAFAAAABSAAe.</span></p><p class="c0"><span class="c1">&ndash; Step 3 retrieves from the employees table the rows whose rowids were</span></p><p class="c0"><span class="c1">returned by Step 4. For example, the database uses rowid AAAPzRAAFAAAABSAAe</span></p><p class="c0"><span class="c1">to retrieve the row for Atkinson.</span></p><p class="c0"><span class="c1">&#9632; Steps indicated by the clear boxes operate on row sources.</span></p><p class="c0"><span class="c1">&ndash; Step 2 performs a hash join, accepting row sources from Steps 3 and 5, joining</span></p><p class="c0"><span class="c1">each row from the Step 5 row source to its corresponding row in Step 3, and</span></p><p class="c0"><span class="c1">returning the resulting rows to Step 1.</span></p><p class="c0"><span class="c1">TABLE ACCESS</span></p><p class="c0"><span class="c1">FULL</span></p><p class="c0"><span class="c1">jobs</span></p><p class="c0"><span class="c1">5 3</span></p><p class="c0"><span class="c1">TABLE ACCESS</span></p><p class="c0"><span class="c1">BY INDEX ROWID</span></p><p class="c0"><span class="c1">employees</span></p><p class="c0"><span class="c1">4</span></p><p class="c0"><span class="c1">INDEX RANGE</span></p><p class="c0"><span class="c1">SCAN</span></p><p class="c0"><span class="c1">emp_name_ix</span></p><p class="c0"><span class="c1">6</span></p><p class="c0"><span class="c1">TABLE ACCESS</span></p><p class="c0"><span class="c1">FULL</span></p><p class="c0"><span class="c1">departments</span></p><p class="c0"><span class="c1">1</span></p><p class="c0"><span class="c1">HASH JOIN</span></p><p class="c0"><span class="c1">2</span></p><p class="c0"><span class="c1">HASH JOINOverview of SQL Processing</span></p><p class="c0"><span class="c1">7-22 Oracle Database Concepts</span></p><p class="c0"><span class="c1">For example, the row for employee Atkinson is associated with the job name</span></p><p class="c0"><span class="c1">Stock Clerk.</span></p><p class="c0"><span class="c1">&ndash; Step 1 performs another hash join, accepting row sources from Steps 2 and 6,</span></p><p class="c0"><span class="c1">joining each row from the Step 6 source to its corresponding row in Step 2, and</span></p><p class="c0"><span class="c1">returning the result to the client.</span></p><p class="c0"><span class="c1">For example, the row for employee Atkinson is associated with the</span></p><p class="c0"><span class="c1">department named Shipping.</span></p><p class="c0"><span class="c1">In some execution plans the steps are iterative and in others sequential. The plan</span></p><p class="c0"><span class="c1">shown in Example 7&ndash;6 is iterative because the SQL engine moves from index to table</span></p><p class="c0"><span class="c1">to client and then repeats the steps.</span></p><p class="c0"><span class="c1">During execution, the database reads the data from disk into memory if the data is not</span></p><p class="c0"><span class="c1">in memory. The database also takes out any locks and latches necessary to ensure data</span></p><p class="c0"><span class="c1">integrity and logs any changes made during the SQL execution. The final stage of</span></p><p class="c0"><span class="c1">processing a SQL statement is closing the cursor.</span></p><p class="c0"><span class="c1">How Oracle Database Processes DML</span></p><p class="c0"><span class="c1">Most DML statements have a query component. In a query, execution of a cursor</span></p><p class="c0"><span class="c1">places the results of the query into a set of rows called the result set.</span></p><p class="c0"><span class="c1">Result set rows can be fetched either a row at a time or in groups. In the fetch stage,</span></p><p class="c0"><span class="c1">the database selects rows and, if requested by the query, orders the rows. Each</span></p><p class="c0"><span class="c1">successive fetch retrieves another row of the result until the last row has been fetched.</span></p><p class="c0"><span class="c1">In general, the database cannot determine for certain the number of rows to be</span></p><p class="c0"><span class="c1">retrieved by a query until the last row is fetched. Oracle Database retrieves the data in</span></p><p class="c0"><span class="c1">response to fetch calls, so that the more rows the database reads, the more work it</span></p><p class="c0"><span class="c1">performs. For some queries the database returns the first row as quickly as possible,</span></p><p class="c0"><span class="c1">whereas for others it creates the entire result set before returning the first row.</span></p><p class="c0"><span class="c1">Read Consistency</span></p><p class="c0"><span class="c1">In general, a query retrieves data by using the Oracle Database read consistency</span></p><p class="c0"><span class="c1">mechanism. This mechanism, which uses undo data to show past versions of data,</span></p><p class="c0"><span class="c1">guarantees that all data blocks read by a query are consistent to a single point in time.</span></p><p class="c0"><span class="c1">For an example of read consistency, suppose a query must read 100 data blocks in a</span></p><p class="c0"><span class="c1">full table scan. The query processes the first 10 blocks while DML in a different</span></p><p class="c0"><span class="c1">session modifies block 75. When the first session reaches block 75, it realizes the</span></p><p class="c0"><span class="c1">change and uses undo data to retrieve the old, unmodified version of the data and</span></p><p class="c0"><span class="c1">construct a noncurrent version of block 75 in memory.</span></p><p class="c0"><span class="c1">Data Changes</span></p><p class="c0"><span class="c1">DML statements that must change data use the read consistency mechanism to retrieve</span></p><p class="c0"><span class="c1">only the data that matched the search criteria when the modification began.</span></p><p class="c0"><span class="c1">Afterward, these statements retrieve the data blocks as they exist in their current state</span></p><p class="c0"><span class="c1">and make the required modifications. The database must perform other actions related</span></p><p class="c0"><span class="c1">to the modification of the data such as generating redo and undo data.</span></p><p class="c0"><span class="c1">See Also: Oracle Database Performance Tuning Guide for detailed</span></p><p class="c0"><span class="c1">information about execution plans and the EXPLAIN PLAN statement</span></p><p class="c0"><span class="c1">See Also: &quot;Multiversion Read Consistency&quot; on page 9-2</span></p><p class="c0"><span class="c1">See Also: &quot;Overview of the Online Redo Log&quot; on page 11-12Overview of SQL Processing</span></p><p class="c0"><span class="c1">SQL 7-23</span></p><p class="c0"><span class="c1">How Oracle Database Processes DDL</span></p><p class="c0"><span class="c1">Oracle Database processes DDL differently from DML. For example, when you create</span></p><p class="c0"><span class="c1">a table, the database does not optimize the CREATE TABLE statement. Instead, Oracle</span></p><p class="c0"><span class="c1">Database parses the DDL statement and carries out the command.</span></p><p class="c0"><span class="c1">The database process DDL differently because it is a means of defining an object in the</span></p><p class="c0"><span class="c1">data dictionary. Typically, Oracle Database must parse and execute many recursive</span></p><p class="c0"><span class="c1">SQL statements to execute a DDL command. Suppose you create a table as follows:</span></p><p class="c0"><span class="c1">CREATE TABLE mytable (mycolumn INTEGER);</span></p><p class="c0"><span class="c1">Typically, the database would run dozens of recursive statements to execute the</span></p><p class="c0"><span class="c1">preceding statement. The recursive SQL would perform actions such as the following:</span></p><p class="c0"><span class="c1">&#9632; Issue a COMMIT before executing the CREATE TABLE statement</span></p><p class="c0"><span class="c1">&#9632; Verify that user privileges are sufficient to create the table</span></p><p class="c0"><span class="c1">&#9632; Determine which tablespace the table should reside in</span></p><p class="c0"><span class="c1">&#9632; Ensure that the tablespace quota has not been exceeded</span></p><p class="c0"><span class="c1">&#9632; Ensure that no object in the schema has the same name</span></p><p class="c0"><span class="c1">&#9632; Insert rows that define the table into the data dictionary</span></p><p class="c0"><span class="c1">&#9632; Issue a COMMIT if the DDL statement succeeded or a ROLLBACK if it did not</span></p><p class="c0"><span class="c1">See Also: Oracle Database Advanced Application Developer&#39;s Guide to</span></p><p class="c0"><span class="c1">learn about SQL processing for application developersOverview of SQL Processing</span></p><p class="c0"><span class="c1">7-24 Oracle Database Concepts8</span></p><p class="c0"><span class="c1">Server-Side Programming: PL/SQL and Java 8-1</span></p><p class="c0"><span class="c1">Server-Side Programming: PL/SQL and Java 8</span></p><p class="c0"><span class="c1">Chapter 7, &quot;SQL&quot; explains the Structured Query Language (SQL) language and how</span></p><p class="c0"><span class="c1">the database processes SQL statements. This chapter explains how Procedural</span></p><p class="c0"><span class="c1">Language/SQL (PL/SQL) or Java programs stored in the database can use SQL.</span></p><p class="c0"><span class="c1">This chapter includes the following topics:</span></p><p class="c0"><span class="c1">&#9632; Introduction to Server-Side Programming</span></p><p class="c0"><span class="c1">&#9632; Overview of PL/SQL</span></p><p class="c0"><span class="c1">&#9632; Overview of Java in Oracle Database</span></p><p class="c0"><span class="c1">&#9632; Overview of Triggers</span></p><p class="c0"><span class="c1">Introduction to Server-Side Programming</span></p><p class="c0"><span class="c1">In a nonprocedural language such as SQL, the set of data to be operated on is</span></p><p class="c0"><span class="c1">specified, but not the operations to be performed or the manner in which they are to be</span></p><p class="c0"><span class="c1">carried out. In a procedural language program, most statement execution depends on</span></p><p class="c0"><span class="c1">previous or subsequent statements and on control structures, such as loops or</span></p><p class="c0"><span class="c1">conditional branches, that are not available in SQL.</span></p><p class="c0"><span class="c1">For an illustration of the difference between procedural and nonprocedural languages,</span></p><p class="c0"><span class="c1">suppose that the following SQL statement queries the employees table:</span></p><p class="c0"><span class="c1">SELECT employee_id, department_id, last_name, salary FROM employees;</span></p><p class="c0"><span class="c1">The preceding statement requests data, but does not apply logic to the data. However,</span></p><p class="c0"><span class="c1">suppose you want an application to determine whether each employee in the data set</span></p><p class="c0"><span class="c1">deserves a raise based on salary and department performance. A necessary condition</span></p><p class="c0"><span class="c1">of a raise is that the employee did not receive more than three raises in the last five</span></p><p class="c0"><span class="c1">years. If a raise is called for, then the application must adjust the salary and email the</span></p><p class="c0"><span class="c1">manager; otherwise, the application must update a report.</span></p><p class="c0"><span class="c1">The problem is how procedural database applications requiring conditional logic and</span></p><p class="c0"><span class="c1">program flow control can use SQL. The basic development approaches are as follows:</span></p><p class="c0"><span class="c1">&#9632; Use client-side programming to embed SQL statements in applications written in</span></p><p class="c0"><span class="c1">procedural languages such as C, C++, or Java</span></p><p class="c0"><span class="c1">You can place SQL statements in source code and submit it to a precompiler or</span></p><p class="c0"><span class="c1">Java translator before compilation. Alternatively, you can eliminate the</span></p><p class="c0"><span class="c1">precompilation step and use an API such as Java Database Connectivity (JDBC) or</span></p><p class="c0"><span class="c1">Oracle Call Interface (OCI) to enable the application to interact with the database.</span></p><p class="c0"><span class="c1">See Also: Chapter 7, &quot;SQL&quot;Overview of PL/SQL</span></p><p class="c0"><span class="c1">8-2 Oracle Database Concepts</span></p><p class="c0"><span class="c1">&#9632; Use server-side programming to develop data logic that resides in the database</span></p><p class="c0"><span class="c1">An application can explicitly invoke stored subprograms (procedures and</span></p><p class="c0"><span class="c1">functions), written in PL/SQL (pronounced P L sequel) or Java. You can also create</span></p><p class="c0"><span class="c1">a trigger, which is named program unit that is stored in the database and invoked</span></p><p class="c0"><span class="c1">in response to a specified event.</span></p><p class="c0"><span class="c1">This chapter explains the second approach. The principal benefit of server-side</span></p><p class="c0"><span class="c1">programming is that functionality built into the database can be deployed anywhere.</span></p><p class="c0"><span class="c1">The database and not the application determines the best way to perform tasks on a</span></p><p class="c0"><span class="c1">given operating system. Also, subprograms increase scalability by centralizing</span></p><p class="c0"><span class="c1">application processing on the server, enabling clients to reuse code. Because</span></p><p class="c0"><span class="c1">subprogram calls are quick and efficient, a single call can start a compute-intensive</span></p><p class="c0"><span class="c1">stored subprogram, reducing network traffic.</span></p><p class="c0"><span class="c1">You can use the following languages to store data logic in Oracle Database:</span></p><p class="c0"><span class="c1">&#9632; PL/SQL</span></p><p class="c0"><span class="c1">PL/SQL is the Oracle Database procedural extension to SQL. PL/SQL is</span></p><p class="c0"><span class="c1">integrated with the database, supporting all Oracle SQL statements, functions, and</span></p><p class="c0"><span class="c1">data types. Applications written in database APIs can invoke PL/SQL stored</span></p><p class="c0"><span class="c1">subprograms and send PL/SQL code blocks to the database for execution.</span></p><p class="c0"><span class="c1">&#9632; Java</span></p><p class="c0"><span class="c1">Oracle Database also provides support for developing, storing, and deploying Java</span></p><p class="c0"><span class="c1">applications. Java stored subprograms run in the database and are independent of</span></p><p class="c0"><span class="c1">programs that run in the middle tier. Java stored subprograms interface with SQL</span></p><p class="c0"><span class="c1">using a similar execution model to PL/SQL.</span></p><p class="c0"><span class="c1">Overview of PL/SQL</span></p><p class="c0"><span class="c1">PL/SQL provides a server-side, stored procedural language that is easy-to-use,</span></p><p class="c0"><span class="c1">seamless with SQL, robust, portable, and secure. You can access and manipulate</span></p><p class="c0"><span class="c1">database data using procedural schema objects called PL/SQL program units.</span></p><p class="c0"><span class="c1">PL/SQL program units generally are categorized as follows:</span></p><p class="c0"><span class="c1">&#9632; A subprogram is a PL/SQL block that is stored in the database and can be called</span></p><p class="c0"><span class="c1">by name from an application. When you create a subprogram, the database parses</span></p><p class="c0"><span class="c1">the subprogram and stores its parsed representation in the database. You can</span></p><p class="c0"><span class="c1">declare a subprogram as a procedure or a function.</span></p><p class="c0"><span class="c1">&#9632; An anonymous block is a PL/SQL block that appears in your application and is</span></p><p class="c0"><span class="c1">not named or stored in the database. In many applications, PL/SQL blocks can</span></p><p class="c0"><span class="c1">appear wherever SQL statements can appear.</span></p><p class="c0"><span class="c1">The PL/SQL compiler and interpreter are embedded in Oracle SQL Developer, giving</span></p><p class="c0"><span class="c1">developers a consistent and leveraged development model on both client and server.</span></p><p class="c0"><span class="c1">Also, PL/SQL stored procedures can be called from several database clients, such as</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Client-Side Database Programming&quot; on page 19-5 to learn</span></p><p class="c0"><span class="c1">about embedding SQL with precompilers and APIs</span></p><p class="c0"><span class="c1">&#9632; Oracle Database 2 Day Developer&#39;s Guide for an introduction to</span></p><p class="c0"><span class="c1">Oracle Database application development</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Advanced Application Developer&#39;s Guide to learn</span></p><p class="c0"><span class="c1">how to choose a programming environmentOverview of PL/SQL</span></p><p class="c0"><span class="c1">Server-Side Programming: PL/SQL and Java 8-3</span></p><p class="c0"><span class="c1">Pro*C, JDBC, ODBC, or OCI, and from Oracle Reports and Oracle Forms.</span></p><p class="c0"><span class="c1">PL/SQL Subprograms</span></p><p class="c0"><span class="c1">A PL/SQL subprogram is a named PL/SQL block that permits the caller to supply</span></p><p class="c0"><span class="c1">parameters that can be input only, output only, or input and output values. A</span></p><p class="c0"><span class="c1">subprogram solves a specific problem or performs related tasks and serves as a</span></p><p class="c0"><span class="c1">building block for modular, maintainable database applications.</span></p><p class="c0"><span class="c1">A subprogram is either a procedure or a function. Procedures and functions are</span></p><p class="c0"><span class="c1">identical except that functions always return a single value to the caller, whereas</span></p><p class="c0"><span class="c1">procedures do not. The term procedure in this chapter means procedure or function.</span></p><p class="c0"><span class="c1">Advantages of PL/SQL Subprograms</span></p><p class="c0"><span class="c1">As explained in &quot;Introduction to Server-Side Programming&quot; on page 8-1, server-side</span></p><p class="c0"><span class="c1">programming has many advantages over client-side programming. PL/SQL</span></p><p class="c0"><span class="c1">subprograms provide the following advantages:</span></p><p class="c0"><span class="c1">&#9632; Improved performance</span></p><p class="c0"><span class="c1">&ndash; The amount of information that an application must send over a network is</span></p><p class="c0"><span class="c1">small compared with issuing individual SQL statements or sending the text of</span></p><p class="c0"><span class="c1">an entire PL/SQL block to Oracle Database, because the information is sent</span></p><p class="c0"><span class="c1">only once and thereafter invoked when it is used.</span></p><p class="c0"><span class="c1">&ndash; The compiled form of a procedure is readily available in the database, so no</span></p><p class="c0"><span class="c1">compilation is required at execution time.</span></p><p class="c0"><span class="c1">&ndash; If the procedure is present in the shared pool of the SGA, then the database</span></p><p class="c0"><span class="c1">need not retrieve it from disk and can begin execution immediately.</span></p><p class="c0"><span class="c1">&#9632; Memory allocation</span></p><p class="c0"><span class="c1">Because stored procedures take advantage of the shared memory capabilities of</span></p><p class="c0"><span class="c1">Oracle Database, it must load only a single copy of the procedure into memory for</span></p><p class="c0"><span class="c1">execution by multiple users. Sharing code among users results in a substantial</span></p><p class="c0"><span class="c1">reduction in database memory requirements for applications.</span></p><p class="c0"><span class="c1">&#9632; Improved productivity</span></p><p class="c0"><span class="c1">Stored procedures increase development productivity. By designing applications</span></p><p class="c0"><span class="c1">around a common set of procedures, you can avoid redundant coding. For</span></p><p class="c0"><span class="c1">example, you can write procedures to manipulate rows in the employees table.</span></p><p class="c0"><span class="c1">Any application can call these procedures without requiring SQL statements to be</span></p><p class="c0"><span class="c1">rewritten. If the methods of data management change, then only the procedures</span></p><p class="c0"><span class="c1">must be modified, not the applications that use the procedures.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Tools for Database Developers&quot; on page 19-1</span></p><p class="c0"><span class="c1">&#9632; Oracle Database PL/SQL Language Reference for complete</span></p><p class="c0"><span class="c1">information about PL/SQL, including packages</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Pro*C/C++ Programmer&#39;s Guide and Pro*COBOL Programmer&#39;s</span></p><p class="c0"><span class="c1">Guide to learn about stored procedures in these languages</span></p><p class="c0"><span class="c1">&#9632; Oracle Database PL/SQL Language ReferenceOverview of PL/SQL</span></p><p class="c0"><span class="c1">8-4 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Stored procedures are perhaps the best way to achieve code reuse. Because any</span></p><p class="c0"><span class="c1">client application written in any language that connects to the database can invoke</span></p><p class="c0"><span class="c1">stored procedures, they provide maximum code reuse in all environments.</span></p><p class="c0"><span class="c1">&#9632; Integrity</span></p><p class="c0"><span class="c1">Stored procedures improve the integrity and consistency of your applications. By</span></p><p class="c0"><span class="c1">developing applications around a common group of procedures, you reduce the</span></p><p class="c0"><span class="c1">likelihood of coding errors.</span></p><p class="c0"><span class="c1">For example, you can test a subprogram to guarantee that it returns an accurate</span></p><p class="c0"><span class="c1">result and, after it is verified, reuse it in any number of applications without</span></p><p class="c0"><span class="c1">retesting. If the data structures referenced by the procedure are altered, then you</span></p><p class="c0"><span class="c1">must only recompile the procedure. Applications that call the procedure do not</span></p><p class="c0"><span class="c1">necessarily require modifications.</span></p><p class="c0"><span class="c1">&#9632; Security with definer&#39;s rights procedures</span></p><p class="c0"><span class="c1">Stored procedures can help enforce data security (see &quot;Overview of Database</span></p><p class="c0"><span class="c1">Security&quot; on page 17-1). A definer&#39;s rights procedure executes with the privileges</span></p><p class="c0"><span class="c1">of its owner, not its current user. Thus, you can restrict the database operations</span></p><p class="c0"><span class="c1">that users perform by allowing them to access data only through procedures and</span></p><p class="c0"><span class="c1">functions that run with the definer&#39;s privileges.</span></p><p class="c0"><span class="c1">For example, you can grant users access to a procedure that updates a table but</span></p><p class="c0"><span class="c1">not grant access to the table itself. When a user invokes the procedure, it runs with</span></p><p class="c0"><span class="c1">the privileges of its owner. Users who have only the privilege to run the procedure</span></p><p class="c0"><span class="c1">(but not privileges to query, update, or delete from the underlying tables) can</span></p><p class="c0"><span class="c1">invoke the procedure but not manipulate table data in any other way.</span></p><p class="c0"><span class="c1">&#9632; Inherited privileges and schema context with invoker&#39;s rights procedures</span></p><p class="c0"><span class="c1">An invoker&#39;s rights procedure executes in the current user&#39;s schema with the</span></p><p class="c0"><span class="c1">current user&#39;s privileges. In other words, an invoker&#39;s rights procedure is not tied</span></p><p class="c0"><span class="c1">to a particular user or schema. Invoker&#39;s rights procedures make it easy for</span></p><p class="c0"><span class="c1">application developers to centralize application logic, even when the underlying</span></p><p class="c0"><span class="c1">data is divided among user schemas.</span></p><p class="c0"><span class="c1">For example, an hr_manager user who runs an update procedure on the</span></p><p class="c0"><span class="c1">hr.employees table can update salaries, whereas an hr_clerk who runs the same</span></p><p class="c0"><span class="c1">procedure is restricted to updating address data.</span></p><p class="c0"><span class="c1">Creation of PL/SQL Subprograms</span></p><p class="c0"><span class="c1">A subprogram created at the schema level with the CREATE PROCEDURE or CREATE</span></p><p class="c0"><span class="c1">FUNCTION statement is a standalone stored subprogram. Subprograms defined in a</span></p><p class="c0"><span class="c1">package are called package subprograms and are considered a part of the package.</span></p><p class="c0"><span class="c1">The database stores subprograms in the data dictionary as schema objects.</span></p><p class="c0"><span class="c1">A subprogram has a specification, which includes descriptions of any parameters, and</span></p><p class="c0"><span class="c1">a body. Example 8&ndash;1 shows part of a creation statement for the standalone PL/SQL</span></p><p class="c0"><span class="c1">procedure hire_employees. The procedure inserts a row into the employees table.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database PL/SQL Language Reference for an overview of</span></p><p class="c0"><span class="c1">PL/SQL subprograms</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Security Guide to learn more about definer&#39;s and</span></p><p class="c0"><span class="c1">invoker&#39;s rightsOverview of PL/SQL</span></p><p class="c0"><span class="c1">Server-Side Programming: PL/SQL and Java 8-5</span></p><p class="c0"><span class="c1">Example 8&ndash;1 PL/SQL Procedure</span></p><p class="c0"><span class="c1">CREATE PROCEDURE hire_employees</span></p><p class="c0"><span class="c1">(p_last_name VARCHAR2, p_job_id VARCHAR2, p_manager_id NUMBER, p_hire_date DATE,</span></p><p class="c0"><span class="c1">p_salary NUMBER, p_commission_pct NUMBER, p_department_id NUMBER)</span></p><p class="c0"><span class="c1">IS</span></p><p class="c0"><span class="c1">BEGIN</span></p><p class="c0"><span class="c1">. . .</span></p><p class="c0"><span class="c1">INSERT INTO employees (employee_id, last_name, job_id, manager_id, hire_date,</span></p><p class="c0"><span class="c1">salary, commission_pct, department_id)</span></p><p class="c0"><span class="c1">VALUES (emp_sequence.NEXTVAL, p_last_name, p_job_id, p_manager_id, p_hire_date,</span></p><p class="c0"><span class="c1">p_salary, p_commission_pct, p_department_id);</span></p><p class="c0"><span class="c1">. . .</span></p><p class="c0"><span class="c1">END;</span></p><p class="c0"><span class="c1">Execution of PL/SQL Subprograms</span></p><p class="c0"><span class="c1">Users can execute a subprogram interactively by:</span></p><p class="c0"><span class="c1">&#9632; Using an Oracle tool, such as SQL*Plus or SQL Developer (see &quot;Tools for Database</span></p><p class="c0"><span class="c1">Developers&quot; on page 19-1)</span></p><p class="c0"><span class="c1">&#9632; Calling it explicitly in the code of a database application, such as an Oracle Forms</span></p><p class="c0"><span class="c1">or precompiler application (see &quot;Client-Side Database Programming&quot; on page 19-5)</span></p><p class="c0"><span class="c1">&#9632; Calling it explicitly in the code of another procedure or trigger</span></p><p class="c0"><span class="c1">Figure 8&ndash;1 shows different database applications calling hire_employees.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database 2 Day Developer&#39;s Guide to learn how to create</span></p><p class="c0"><span class="c1">subprograms</span></p><p class="c0"><span class="c1">&#9632; Oracle Database PL/SQL Language Reference to learn about the</span></p><p class="c0"><span class="c1">CREATE PROCEDURE commandOverview of PL/SQL</span></p><p class="c0"><span class="c1">8-6 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Figure 8&ndash;1 Calling a PL/SQL Stored Procedure</span></p><p class="c0"><span class="c1">Alternatively, a privileged user can use Oracle Enterprise Manager or SQL*Plus to run</span></p><p class="c0"><span class="c1">the hire_employees procedure using a statement such as the following:</span></p><p class="c0"><span class="c1">EXECUTE hire_employees (&#39;TSMITH&#39;, &#39;CLERK&#39;, 1037, SYSDATE, 500, NULL, 20);</span></p><p class="c0"><span class="c1">The preceding statement inserts a new record for TSMITH in the employees table.</span></p><p class="c0"><span class="c1">A stored procedure depends on the objects referenced in its body. The database</span></p><p class="c0"><span class="c1">automatically tracks and manages these dependencies. For example, if you alter the</span></p><p class="c0"><span class="c1">definition of the employees table referenced by the hire_employees procedure in a</span></p><p class="c0"><span class="c1">manner that would affect this procedure, then the procedure must be recompiled to</span></p><p class="c0"><span class="c1">validate that it still works as designed. Usually, the database automatically administers</span></p><p class="c0"><span class="c1">such dependency management.</span></p><p class="c0"><span class="c1">PL/SQL Packages</span></p><p class="c0"><span class="c1">A PL/SQL package is a group of related subprograms, along with the cursors and</span></p><p class="c0"><span class="c1">variables they use, stored together in the database for continued use as a unit.</span></p><p class="c0"><span class="c1">Packaged subprograms can be called explicitly by applications or users.</span></p><p class="c0"><span class="c1">Oracle Database includes many supplied packages that extend database functionality</span></p><p class="c0"><span class="c1">and provide PL/SQL access to SQL features. For example, the UTL_HTTP package</span></p><p class="c0"><span class="c1">enables HTTP callouts from PL/SQL and SQL to access data on the Internet or to call</span></p><p class="c0"><span class="c1">Oracle Web Server Cartridges. You can use the supplied packages when creating</span></p><p class="c0"><span class="c1">applications or as a source of ideas when creating your own stored procedures.</span></p><p class="c0"><span class="c1">Advantages of PL/SQL Packages</span></p><p class="c0"><span class="c1">PL/SQL packages provide the following advantages:</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database PL/SQL Language Reference to learn how to use</span></p><p class="c0"><span class="c1">PL/SQL subprograms</span></p><p class="c0"><span class="c1">&#9632; SQL*Plus User&#39;s Guide and Reference to learn about the EXECUTE</span></p><p class="c0"><span class="c1">command</span></p><p class="c0"><span class="c1">Program code</span></p><p class="c0"><span class="c1">Program code</span></p><p class="c0"><span class="c1">..</span></p><p class="c0"><span class="c1">Program code</span></p><p class="c0"><span class="c1">Database Applications</span></p><p class="c0"><span class="c1">.. .</span></p><p class="c0"><span class="c1">hire_employees(...);</span></p><p class="c0"><span class="c1">.</span></p><p class="c0"><span class="c1">Program code</span></p><p class="c0"><span class="c1">Program code</span></p><p class="c0"><span class="c1">.</span></p><p class="c0"><span class="c1">hire_employees(...);</span></p><p class="c0"><span class="c1">.</span></p><p class="c0"><span class="c1">Program code</span></p><p class="c0"><span class="c1">Program code</span></p><p class="c0"><span class="c1">.</span></p><p class="c0"><span class="c1">Program code</span></p><p class="c0"><span class="c1">Program code</span></p><p class="c0"><span class="c1">hire_employees(...)</span></p><p class="c0"><span class="c1">BEGIN</span></p><p class="c0"><span class="c1">..</span></p><p class="c0"><span class="c1">END;</span></p><p class="c0"><span class="c1">. .</span></p><p class="c0"><span class="c1">hire_employees(...);</span></p><p class="c0"><span class="c1">.</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">Stored ProcedureOverview of PL/SQL</span></p><p class="c0"><span class="c1">Server-Side Programming: PL/SQL and Java 8-7</span></p><p class="c0"><span class="c1">&#9632; Encapsulation</span></p><p class="c0"><span class="c1">Packages enable you to encapsulate or group stored procedures, variables, data</span></p><p class="c0"><span class="c1">types, and so on in a named, stored unit. Encapsulation provides better</span></p><p class="c0"><span class="c1">organization during development and also more flexibility. You can create</span></p><p class="c0"><span class="c1">specifications and reference public procedures without actually creating the</span></p><p class="c0"><span class="c1">package body. Encapsulation simplifies privilege management. Granting the</span></p><p class="c0"><span class="c1">privilege for a package makes package constructs accessible to the grantee.</span></p><p class="c0"><span class="c1">&#9632; Data security</span></p><p class="c0"><span class="c1">The methods of package definition enable you to specify which variables, cursors,</span></p><p class="c0"><span class="c1">and procedures are public and private. Public means that it is directly accessible to</span></p><p class="c0"><span class="c1">the user of a package. Private means that it is hidden from the user of a package.</span></p><p class="c0"><span class="c1">For example, a package can contain 10 procedures. You can define the package so</span></p><p class="c0"><span class="c1">that only three procedures are public and therefore available for execution by a</span></p><p class="c0"><span class="c1">user of the package. The remaining procedures are private and can only be</span></p><p class="c0"><span class="c1">accessed by the procedures within the package. Do not confuse public and private</span></p><p class="c0"><span class="c1">package variables with grants to PUBLIC.</span></p><p class="c0"><span class="c1">&#9632; Better performance</span></p><p class="c0"><span class="c1">An entire package is loaded into memory in small chunks when a procedure in the</span></p><p class="c0"><span class="c1">package is called for the first time. This load is completed in one operation, as</span></p><p class="c0"><span class="c1">opposed to the separate loads required for standalone procedures. When calls to</span></p><p class="c0"><span class="c1">related packaged procedures occur, no disk I/O is needed to run the compiled</span></p><p class="c0"><span class="c1">code in memory.</span></p><p class="c0"><span class="c1">A package body can be replaced and recompiled without affecting the</span></p><p class="c0"><span class="c1">specification. As a result, schema objects that reference a package&#39;s constructs</span></p><p class="c0"><span class="c1">(always through the specification) need not be recompiled unless the package</span></p><p class="c0"><span class="c1">specification is also replaced. By using packages, unnecessary recompilations can</span></p><p class="c0"><span class="c1">be minimized, resulting in less impact on overall database performance.</span></p><p class="c0"><span class="c1">Creation of PL/SQL Packages</span></p><p class="c0"><span class="c1">You create a package in two parts: the specification and the body. The package</span></p><p class="c0"><span class="c1">specification declares all public constructs of the package, whereas the body defines</span></p><p class="c0"><span class="c1">all constructs (public and private) of the package.</span></p><p class="c0"><span class="c1">Example 8&ndash;1 shows part of a statement that creates the package specification for</span></p><p class="c0"><span class="c1">employees_management, which encapsulates several subprograms used to manage an</span></p><p class="c0"><span class="c1">employee database. Each part of the package is created with a different statement.</span></p><p class="c0"><span class="c1">Example 8&ndash;2 PL/SQL Package</span></p><p class="c0"><span class="c1">CREATE PACKAGE employees_management AS</span></p><p class="c0"><span class="c1">FUNCTION hire_employees (last_name VARCHAR2, job_id VARCHAR2, manager_id NUMBER,</span></p><p class="c0"><span class="c1">salary NUMBER, commission_pct NUMBER, department_id NUMBER) RETURN NUMBER;</span></p><p class="c0"><span class="c1">PROCEDURE fire_employees(employee_id NUMBER);</span></p><p class="c0"><span class="c1">PROCEDURE salary_raise(employee_id NUMBER, salary_incr NUMBER);</span></p><p class="c0"><span class="c1">. . .</span></p><p class="c0"><span class="c1">no_sal EXCEPTION;</span></p><p class="c0"><span class="c1">END employees_management;</span></p><p class="c0"><span class="c1">The specification declares the function hire_employees, the procedures</span></p><p class="c0"><span class="c1">fire_employees and salary_raise, and the exception no_sal. All of these public</span></p><p class="c0"><span class="c1">program objects are available to users who have access to the package.Overview of PL/SQL</span></p><p class="c0"><span class="c1">8-8 Oracle Database Concepts</span></p><p class="c0"><span class="c1">The CREATE PACKAGE BODY command defines objects declared in the specification. The</span></p><p class="c0"><span class="c1">package body must be created in the same schema as the package. After creating the</span></p><p class="c0"><span class="c1">package, you can develop applications that call any of these public procedures or</span></p><p class="c0"><span class="c1">functions or raise any of the public exceptions of the package.</span></p><p class="c0"><span class="c1">Execution of PL/SQL Package Subprograms</span></p><p class="c0"><span class="c1">You can reference package contents from database triggers, stored subprograms, 3GL</span></p><p class="c0"><span class="c1">application programs, and Oracle tools. Figure 8&ndash;2 shows database applications</span></p><p class="c0"><span class="c1">invoking procedures and functions in the employees_management package.</span></p><p class="c0"><span class="c1">Figure 8&ndash;2 Calling Subprograms in a PL/SQL Package</span></p><p class="c0"><span class="c1">Database applications explicitly call packaged procedures as necessary. After being</span></p><p class="c0"><span class="c1">granted the privileges for the employees_management package, a user can explicitly run</span></p><p class="c0"><span class="c1">any of the procedures contained in it. For example, SQL*Plus can issue the following</span></p><p class="c0"><span class="c1">statement to run the hire_employees package procedure:</span></p><p class="c0"><span class="c1">EXECUTE employees_management.hire_employees (&#39;TSMITH&#39;, &#39;CLERK&#39;, 1037, SYSDATE,</span></p><p class="c0"><span class="c1">500, NULL, 20);</span></p><p class="c0"><span class="c1">See Also: Oracle Database PL/SQL Language Reference to learn</span></p><p class="c0"><span class="c1">about the CREATE PACKAGE command</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database PL/SQL Language Reference for an introduction</span></p><p class="c0"><span class="c1">to PL/SQL packages</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Advanced Application Developer&#39;s Guide to learn</span></p><p class="c0"><span class="c1">how to code PL/SQL packages</span></p><p class="c0"><span class="c1">Database Applications employees_management</span></p><p class="c0"><span class="c1">Program code</span></p><p class="c0"><span class="c1">.</span></p><p class="c0"><span class="c1">employees_management.fire_employees(...);</span></p><p class="c0"><span class="c1">Program code</span></p><p class="c0"><span class="c1">.</span></p><p class="c0"><span class="c1">Program code</span></p><p class="c0"><span class="c1">.</span></p><p class="c0"><span class="c1">employees_management.hire_employees(...);</span></p><p class="c0"><span class="c1">.</span></p><p class="c0"><span class="c1">Program code</span></p><p class="c0"><span class="c1">Program code</span></p><p class="c0"><span class="c1">.</span></p><p class="c0"><span class="c1">employees_management.hire_employees(...);</span></p><p class="c0"><span class="c1">Program code</span></p><p class="c0"><span class="c1">.</span></p><p class="c0"><span class="c1">Program code</span></p><p class="c0"><span class="c1">.</span></p><p class="c0"><span class="c1">employees_management.salary_raise(...);</span></p><p class="c0"><span class="c1">.</span></p><p class="c0"><span class="c1">Program code</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">BEGIN</span></p><p class="c0"><span class="c1">fire_employees(...)</span></p><p class="c0"><span class="c1">..</span></p><p class="c0"><span class="c1">END;</span></p><p class="c0"><span class="c1">hire_employees(...)</span></p><p class="c0"><span class="c1">BEGIN</span></p><p class="c0"><span class="c1">..</span></p><p class="c0"><span class="c1">END;</span></p><p class="c0"><span class="c1">salary_raise(...)</span></p><p class="c0"><span class="c1">BEGIN</span></p><p class="c0"><span class="c1">..</span></p><p class="c0"><span class="c1">END;Overview of PL/SQL</span></p><p class="c0"><span class="c1">Server-Side Programming: PL/SQL and Java 8-9</span></p><p class="c0"><span class="c1">PL/SQL Anonymous Blocks</span></p><p class="c0"><span class="c1">An anonymous block is an unnamed, nonpersistent PL/SQL unit. Typical uses for</span></p><p class="c0"><span class="c1">anonymous blocks include:</span></p><p class="c0"><span class="c1">&#9632; Initiating calls to subprograms and package constructs</span></p><p class="c0"><span class="c1">&#9632; Isolating exception handling</span></p><p class="c0"><span class="c1">&#9632; Managing control by nesting code within other PL/SQL blocks</span></p><p class="c0"><span class="c1">Anonymous blocks do not have the code reuse advantages of stored subprograms.</span></p><p class="c0"><span class="c1">Table 8&ndash;1 summarizes the differences between the two types of program units.</span></p><p class="c0"><span class="c1">An anonymous block consists of an optional declarative part, an executable part, and</span></p><p class="c0"><span class="c1">one or more optional exception handlers. The following sample anonymous block</span></p><p class="c0"><span class="c1">selects an employee last name into a variable and prints the name:</span></p><p class="c0"><span class="c1">DECLARE</span></p><p class="c0"><span class="c1">v_lname VARCHAR2(25);</span></p><p class="c0"><span class="c1">BEGIN</span></p><p class="c0"><span class="c1">SELECT last_name INTO v_lname</span></p><p class="c0"><span class="c1">FROM employees</span></p><p class="c0"><span class="c1">WHERE employee_id = 101;</span></p><p class="c0"><span class="c1">DBMS_OUTPUT.PUT_LINE(&#39;Employee last name is &#39;||v_lname);</span></p><p class="c0"><span class="c1">END;</span></p><p class="c0"><span class="c1">Oracle Database compiles the PL/SQL block and places it in the shared pool of the</span></p><p class="c0"><span class="c1">SGA, but it does not store the source code or compiled version in the database for</span></p><p class="c0"><span class="c1">reuse beyond the current instance. Unlike triggers, an anonymous block is compiled</span></p><p class="c0"><span class="c1">each time it is loaded into memory. Shared SQL allows anonymous PL/SQL blocks in</span></p><p class="c0"><span class="c1">the shared pool to be reused and shared until they are flushed out of the shared pool.</span></p><p class="c0"><span class="c1">PL/SQL Language Constructs</span></p><p class="c0"><span class="c1">PL/SQL blocks can include a variety of different PL/SQL language constructs. These</span></p><p class="c0"><span class="c1">constructs including the following:</span></p><p class="c0"><span class="c1">&#9632; Variables and constants</span></p><p class="c0"><span class="c1">You can declare these constructs within a procedure, function, or package. You can</span></p><p class="c0"><span class="c1">use a variable or constant in a SQL or PL/SQL statement to capture or provide a</span></p><p class="c0"><span class="c1">value when one is needed.</span></p><p class="c0"><span class="c1">Table 8&ndash;1 Differences Between Anonymous Blocks and Subprograms</span></p><p class="c0"><span class="c1">Is the PL/SQL Unit ... Anonymous Blocks Subprograms</span></p><p class="c0"><span class="c1">Specified with a name? No Yes</span></p><p class="c0"><span class="c1">Compiled with every reuse? No No</span></p><p class="c0"><span class="c1">Stored in the database? No Yes</span></p><p class="c0"><span class="c1">Invocable by other applications? No Yes</span></p><p class="c0"><span class="c1">Capable of returning bind variable values? Yes Yes</span></p><p class="c0"><span class="c1">Capable of returning function values? No Yes</span></p><p class="c0"><span class="c1">Capable of accepting parameters? No Yes</span></p><p class="c0"><span class="c1">See Also: Oracle Database Advanced Application Developer&#39;s Guide to</span></p><p class="c0"><span class="c1">learn more about anonymous PL/SQL blocksOverview of PL/SQL</span></p><p class="c0"><span class="c1">8-10 Oracle Database Concepts</span></p><p class="c0"><span class="c1">&#9632; Cursors</span></p><p class="c0"><span class="c1">You can declare a cursor explicitly within a procedure, function, or package to</span></p><p class="c0"><span class="c1">facilitate record-oriented processing of Oracle Database data. The PL/SQL engine</span></p><p class="c0"><span class="c1">can also declare cursors implicitly.</span></p><p class="c0"><span class="c1">&#9632; Exceptions</span></p><p class="c0"><span class="c1">PL/SQL lets you explicitly handle internal and user-defined error conditions,</span></p><p class="c0"><span class="c1">called exceptions, that arise during processing of PL/SQL code.</span></p><p class="c0"><span class="c1">PL/SQL can run dynamic SQL statements whose complete text is not known until run</span></p><p class="c0"><span class="c1">time. Dynamic SQL statements are stored in character strings that are entered into, or</span></p><p class="c0"><span class="c1">built by, the program at run time. This technique enables you to create general purpose</span></p><p class="c0"><span class="c1">procedures. For example, you can create a procedure that operates on a table whose</span></p><p class="c0"><span class="c1">name is not known until run time.</span></p><p class="c0"><span class="c1">PL/SQL Collections and Records</span></p><p class="c0"><span class="c1">Many programming techniques use collection types such as arrays, bags, lists, nested</span></p><p class="c0"><span class="c1">tables, sets, and trees. To support these techniques in database applications, PL/SQL</span></p><p class="c0"><span class="c1">provides the data types TABLE and VARRAY, which enable you to declare associative</span></p><p class="c0"><span class="c1">arrays, nested tables, and variable-size arrays.</span></p><p class="c0"><span class="c1">Collections</span></p><p class="c0"><span class="c1">A collection is an ordered group of elements, all of the same type. Each element has a</span></p><p class="c0"><span class="c1">unique subscript that determines its position in the collection. To create a collection,</span></p><p class="c0"><span class="c1">you first define a collection type, and then declare a variable of that type.</span></p><p class="c0"><span class="c1">Collections work like the arrays found in most third-generation programming</span></p><p class="c0"><span class="c1">languages. Also, collections can be passed as parameters. So, you can use them to</span></p><p class="c0"><span class="c1">move columns of data into and out of database tables or between client-side</span></p><p class="c0"><span class="c1">applications and stored subprograms.</span></p><p class="c0"><span class="c1">Records</span></p><p class="c0"><span class="c1">A record is a composite variable that can store data values of different types, similar to</span></p><p class="c0"><span class="c1">a struct type in C, C++, or Java. Records are useful for holding data from table rows, or</span></p><p class="c0"><span class="c1">certain columns from table rows.</span></p><p class="c0"><span class="c1">Suppose you have data about an employee such as name, salary, and hire date. These</span></p><p class="c0"><span class="c1">items are dissimilar in type but logically related. A record containing a field for each</span></p><p class="c0"><span class="c1">item lets you treat the data as a logical unit.</span></p><p class="c0"><span class="c1">You can use the %ROWTYPE attribute to declare a record that represents a table row or</span></p><p class="c0"><span class="c1">row fetched from a cursor. With user-defined records, you can declare your own fields.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database PL/SQL Language Reference for details about</span></p><p class="c0"><span class="c1">dynamic SQL</span></p><p class="c0"><span class="c1">&#9632; Oracle Database PL/SQL Packages and Types Reference to learn how</span></p><p class="c0"><span class="c1">to use dynamic SQL in the DBMS_SQL package</span></p><p class="c0"><span class="c1">See Also: Oracle Database PL/SQL Language Reference for detailed</span></p><p class="c0"><span class="c1">information on using collections and recordsOverview of PL/SQL</span></p><p class="c0"><span class="c1">Server-Side Programming: PL/SQL and Java 8-11</span></p><p class="c0"><span class="c1">How PL/SQL Runs</span></p><p class="c0"><span class="c1">PL/SQL supports both native execution and interpreted execution. In interpreted</span></p><p class="c0"><span class="c1">execution, PL/SQL source code is compiled into a so-called bytecode representation,</span></p><p class="c0"><span class="c1">which is run by a portable virtual computer implemented as part of Oracle Database.</span></p><p class="c0"><span class="c1">In native execution, which offers the best performance on computationally intensive</span></p><p class="c0"><span class="c1">program units, the source code of PL/SQL program units is compiled directly to object</span></p><p class="c0"><span class="c1">code for the given platform. This object code is linked into Oracle Database.</span></p><p class="c0"><span class="c1">The PL/SQL engine is the tool used to define, compile, and run PL/SQL program</span></p><p class="c0"><span class="c1">units. This engine is a special component of many Oracle products, including Oracle</span></p><p class="c0"><span class="c1">Database. While many Oracle products have PL/SQL components, this section</span></p><p class="c0"><span class="c1">specifically covers the program units that can be stored in Oracle Database and</span></p><p class="c0"><span class="c1">processed using Oracle Database PL/SQL engine. The PL/SQL capabilities of each</span></p><p class="c0"><span class="c1">Oracle tool are described in the documentation for this tool.</span></p><p class="c0"><span class="c1">Figure 8&ndash;3 illustrates the PL/SQL engine contained in Oracle Database.</span></p><p class="c0"><span class="c1">Figure 8&ndash;3 The PL/SQL Engine and Oracle Database</span></p><p class="c0"><span class="c1">The program unit is stored in a database. When an application calls a stored</span></p><p class="c0"><span class="c1">procedure, the database loads the compiled program unit into the shared pool in the</span></p><p class="c0"><span class="c1">system global area (SGA) (see &quot;Shared Pool&quot; on page 14-15). The PL/SQL and SQL</span></p><p class="c0"><span class="c1">statement executors work together to process the statements in the procedure.</span></p><p class="c0"><span class="c1">You can call a stored procedure from another PL/SQL block, which can be either an</span></p><p class="c0"><span class="c1">anonymous block or another stored procedure. For example, you can call a stored</span></p><p class="c0"><span class="c1">procedure from Oracle Forms.</span></p><p class="c0"><span class="c1">A PL/SQL procedure executing on Oracle Database can call an external procedure or</span></p><p class="c0"><span class="c1">function written in the C programming language and stored in a shared library. The C</span></p><p class="c0"><span class="c1">routine runs in a separate address space from that of Oracle Database.</span></p><p class="c0"><span class="c1">Instance</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">PL/SQL Engine</span></p><p class="c0"><span class="c1">SQL</span></p><p class="c0"><span class="c1">SQL</span></p><p class="c0"><span class="c1">Statement</span></p><p class="c0"><span class="c1">Executor</span></p><p class="c0"><span class="c1">Procedural</span></p><p class="c0"><span class="c1">Statement</span></p><p class="c0"><span class="c1">Executor</span></p><p class="c0"><span class="c1">Database Application</span></p><p class="c0"><span class="c1">System Global Area</span></p><p class="c0"><span class="c1">(SGA)</span></p><p class="c0"><span class="c1">Program code</span></p><p class="c0"><span class="c1">..</span></p><p class="c0"><span class="c1">Program code</span></p><p class="c0"><span class="c1">.</span></p><p class="c0"><span class="c1">hire_employees(...);</span></p><p class="c0"><span class="c1">.</span></p><p class="c0"><span class="c1">Program code</span></p><p class="c0"><span class="c1">Procedure</span></p><p class="c0"><span class="c1">BEGIN</span></p><p class="c0"><span class="c1">Procedural SQL</span></p><p class="c0"><span class="c1">Procedural SQL</span></p><p class="c0"><span class="c1">Procedural SQL</span></p><p class="c0"><span class="c1">END;Overview of Java in Oracle Database</span></p><p class="c0"><span class="c1">8-12 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Overview of Java in Oracle Database</span></p><p class="c0"><span class="c1">Java has emerged as the object-oriented programming language of choice. Java</span></p><p class="c0"><span class="c1">includes the following features:</span></p><p class="c0"><span class="c1">&#9632; A Java Virtual Machine (JVM), which provides the basis for platform</span></p><p class="c0"><span class="c1">independence</span></p><p class="c0"><span class="c1">&#9632; Automated storage management techniques, such as garbage collection</span></p><p class="c0"><span class="c1">&#9632; Language syntax that borrows from C and enforces strong typing</span></p><p class="c0"><span class="c1">The database provides Java programs with a dynamic data-processing engine that</span></p><p class="c0"><span class="c1">supports complex queries and multiple views of data. Client requests are assembled as</span></p><p class="c0"><span class="c1">data queries for immediate processing. Query results are generated dynamically.</span></p><p class="c0"><span class="c1">The combination of Java and Oracle Database helps you create component-based,</span></p><p class="c0"><span class="c1">network-centric applications that can be easily updated as business needs change. In</span></p><p class="c0"><span class="c1">addition, you can move applications and data stores off the desktop and onto</span></p><p class="c0"><span class="c1">intelligent networks and network-centric servers. More importantly, you can access</span></p><p class="c0"><span class="c1">these applications and data stores from any client device.</span></p><p class="c0"><span class="c1">Figure 8&ndash;4 shows a traditional two-tier, client/server configuration in which clients</span></p><p class="c0"><span class="c1">call Java stored procedures in the same way that they call PL/SQL subprograms.</span></p><p class="c0"><span class="c1">Figure 8&ndash;4 Two-Tier Client/Server Configuration</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database PL/SQL Language Reference to learn about</span></p><p class="c0"><span class="c1">PL/SQL architecture</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Advanced Application Developer&#39;s Guide to learn</span></p><p class="c0"><span class="c1">more about external procedures</span></p><p class="c0"><span class="c1">Note: This chapter assumes that you have some familiarity with the</span></p><p class="c0"><span class="c1">Java language.</span></p><p class="c0"><span class="c1">Oracle Net</span></p><p class="c0"><span class="c1">Oracle Net</span></p><p class="c0"><span class="c1">Oracle Net</span></p><p class="c0"><span class="c1">Client</span></p><p class="c0"><span class="c1">Client</span></p><p class="c0"><span class="c1">Client</span></p><p class="c0"><span class="c1">Java Stored</span></p><p class="c0"><span class="c1">Procedures</span></p><p class="c0"><span class="c1">PL/SQL Stored</span></p><p class="c0"><span class="c1">Procedures</span></p><p class="c0"><span class="c1">Table</span></p><p class="c0"><span class="c1">Table</span></p><p class="c0"><span class="c1">Table</span></p><p class="c0"><span class="c1">Relational DataOverview of Java in Oracle Database</span></p><p class="c0"><span class="c1">Server-Side Programming: PL/SQL and Java 8-13</span></p><p class="c0"><span class="c1">Overview of the Java Virtual Machine (JVM)</span></p><p class="c0"><span class="c1">A JVM is a virtual processor that runs compiled Java code. Java source code compiles</span></p><p class="c0"><span class="c1">to low-level machine instructions, known as bytecodes, that are platform independent.</span></p><p class="c0"><span class="c1">The Java bytecodes are interpreted through the JVM into platform-dependent actions.</span></p><p class="c0"><span class="c1">Overview of Oracle JVM</span></p><p class="c0"><span class="c1">Oracle JVM is a complete, Java2-compliant environment for running pure Java</span></p><p class="c0"><span class="c1">applications. It is compatible with the JLS and the JVM specifications. It supports the</span></p><p class="c0"><span class="c1">standard Java binary format and APIs. In addition, Oracle Database adheres to</span></p><p class="c0"><span class="c1">standard Java language semantics, including dynamic class loading at run time.</span></p><p class="c0"><span class="c1">Figure 8&ndash;5 illustrates how Oracle Java applications reside on top of the Java core class</span></p><p class="c0"><span class="c1">libraries, which reside on top of the Oracle JVM. Because the Oracle Java support</span></p><p class="c0"><span class="c1">system is located within the database, the JVM interacts with database libraries,</span></p><p class="c0"><span class="c1">instead of directly interacting with the operating system.</span></p><p class="c0"><span class="c1">Figure 8&ndash;5 Java Component Structure</span></p><p class="c0"><span class="c1">Unlike other Java environments, Oracle JVM is embedded within Oracle Database.</span></p><p class="c0"><span class="c1">Some important differences exist between Oracle JVM and typical client JVMs. For</span></p><p class="c0"><span class="c1">example, in a standard Java environment, you run a Java application through the</span></p><p class="c0"><span class="c1">interpreter by issuing the following command on the command line, where classname</span></p><p class="c0"><span class="c1">is the name of the class that you want the JVM to interpret first:</span></p><p class="c0"><span class="c1">java classname</span></p><p class="c0"><span class="c1">The preceding command causes the application to run within a process on your</span></p><p class="c0"><span class="c1">operating system. However, if you are not using the command-line interface, then you</span></p><p class="c0"><span class="c1">must load the application into the database, publish the interface, and then run the</span></p><p class="c0"><span class="c1">See Also: Oracle Database 2 Day + Java Developer&#39;s Guide for an</span></p><p class="c0"><span class="c1">introduction to using Java with Oracle Database</span></p><p class="c0"><span class="c1">Data / Persistence Logic</span></p><p class="c0"><span class="c1">Oracle Database JVM</span></p><p class="c0"><span class="c1">JDBC</span></p><p class="c0"><span class="c1">Java Core Class Libraries</span></p><p class="c0"><span class="c1">Oracle Database Libraries</span></p><p class="c0"><span class="c1">Operating SystemOverview of Java in Oracle Database</span></p><p class="c0"><span class="c1">8-14 Oracle Database Concepts</span></p><p class="c0"><span class="c1">application within a database data dictionary.</span></p><p class="c0"><span class="c1">Main Components of Oracle JVM</span></p><p class="c0"><span class="c1">Oracle JVM runs in the same process space and address space as the database kernel</span></p><p class="c0"><span class="c1">by sharing its memory heaps and directly accessing its relational data. This design</span></p><p class="c0"><span class="c1">optimizes memory use and increases throughput.</span></p><p class="c0"><span class="c1">Oracle JVM provides a run-time environment for Java objects. It fully supports Java</span></p><p class="c0"><span class="c1">data structures, method dispatch, exception handling, and language-level threads. It</span></p><p class="c0"><span class="c1">also supports all the core Java class libraries, including java.lang, java.io, java.net,</span></p><p class="c0"><span class="c1">java.math, and java.util.</span></p><p class="c0"><span class="c1">Figure 8&ndash;6 shows the main components of Oracle JVM.</span></p><p class="c0"><span class="c1">Figure 8&ndash;6 Main Components of Oracle JVM</span></p><p class="c0"><span class="c1">Oracle JVM embeds the standard Java namespace in the database schemas. This</span></p><p class="c0"><span class="c1">feature lets Java programs access Java objects stored in Oracle Database and</span></p><p class="c0"><span class="c1">application servers across the enterprise.</span></p><p class="c0"><span class="c1">In addition, Oracle JVM is tightly integrated with the scalable, shared memory</span></p><p class="c0"><span class="c1">architecture of the database. Java programs use call, session, and object lifetimes</span></p><p class="c0"><span class="c1">efficiently without user intervention. As a result, Oracle JVM and middle-tier Java</span></p><p class="c0"><span class="c1">business objects can be scaled, even when they have session-long state.</span></p><p class="c0"><span class="c1">Java Programming Environment</span></p><p class="c0"><span class="c1">Oracle furnishes enterprise application developers with an end-to-end Java solution</span></p><p class="c0"><span class="c1">for creating, deploying, and managing Java applications. The solution consists of</span></p><p class="c0"><span class="c1">client-side and server-side programmatic interfaces, tools to support Java</span></p><p class="c0"><span class="c1">development, and a Java Virtual Machine integrated with Oracle Database. All these</span></p><p class="c0"><span class="c1">products are compatible with Java standards.</span></p><p class="c0"><span class="c1">The Java programming environment consists of the following additional features:</span></p><p class="c0"><span class="c1">See Also: See Oracle Database Java Developer&#39;s Guide for a description</span></p><p class="c0"><span class="c1">of other differences between the Oracle JVM and typical client JVMs</span></p><p class="c0"><span class="c1">See Also: Oracle Database Java Developer&#39;s Guide for a description of</span></p><p class="c0"><span class="c1">the main components of Oracle JVM</span></p><p class="c0"><span class="c1">Interpreter &amp;</span></p><p class="c0"><span class="c1">Run-Time System</span></p><p class="c0"><span class="c1">Memory</span></p><p class="c0"><span class="c1">Oracle JVM</span></p><p class="c0"><span class="c1">loadjava Utility</span></p><p class="c0"><span class="c1">CREATE JAVA Statement</span></p><p class="c0"><span class="c1">RDBMS</span></p><p class="c0"><span class="c1">Library Manager</span></p><p class="c0"><span class="c1">RDBMS</span></p><p class="c0"><span class="c1">Memory Manager</span></p><p class="c0"><span class="c1">SQL Calls Class Loader Garbage Collector</span></p><p class="c0"><span class="c1">Natively</span></p><p class="c0"><span class="c1">Compiled CodeOverview of Java in Oracle Database</span></p><p class="c0"><span class="c1">Server-Side Programming: PL/SQL and Java 8-15</span></p><p class="c0"><span class="c1">&#9632; Java stored procedures as the Java equivalent and companion for PL/SQL. Java</span></p><p class="c0"><span class="c1">stored procedures are tightly integrated with PL/SQL. You can call Java stored</span></p><p class="c0"><span class="c1">procedures from PL/SQL packages and procedures from Java stored procedures.</span></p><p class="c0"><span class="c1">&#9632; The JDBC and SQLJ programming interfaces for accessing SQL data.</span></p><p class="c0"><span class="c1">&#9632; Tools and scripts that assist in developing, loading, and managing classes.</span></p><p class="c0"><span class="c1">Java Stored Procedures</span></p><p class="c0"><span class="c1">A Java stored procedure is a Java method published to SQL and stored in the</span></p><p class="c0"><span class="c1">database. Like a PL/SQL subprogram, a Java procedure can be invoked directly with</span></p><p class="c0"><span class="c1">products like SQL*Plus or indirectly with a trigger. You can access it from any Oracle</span></p><p class="c0"><span class="c1">Net client&mdash;OCI, precompiler, or JDBC.</span></p><p class="c0"><span class="c1">To publish Java methods, you write call specifications, which map Java method</span></p><p class="c0"><span class="c1">names, parameter types, and return types to their SQL counterparts. When called by</span></p><p class="c0"><span class="c1">client applications, a Java stored procedure can accept arguments, reference Java</span></p><p class="c0"><span class="c1">classes, and return Java result values.</span></p><p class="c0"><span class="c1">Applications calling the Java method by referencing the name of the call specification.</span></p><p class="c0"><span class="c1">The run-time system looks up the call specification definition in the Oracle data</span></p><p class="c0"><span class="c1">dictionary and runs the corresponding Java method.</span></p><p class="c0"><span class="c1">In addition, you can use Java to develop powerful programs independently of</span></p><p class="c0"><span class="c1">PL/SQL. Oracle Database provides a fully compliant implementation of the Java</span></p><p class="c0"><span class="c1">programming language and JVM.</span></p><p class="c0"><span class="c1">Java and PL/SQL Integration</span></p><p class="c0"><span class="c1">You can call existing PL/SQL programs from Java and Java programs from PL/SQL.</span></p><p class="c0"><span class="c1">This solution protects and leverages your PL/SQL and Java code.</span></p><p class="c0"><span class="c1">Oracle Database offers two different approaches for accessing SQL data from Java,</span></p><p class="c0"><span class="c1">JDBC and SQLJ. Both approaches are available on the client and server. As a result,</span></p><p class="c0"><span class="c1">you can deploy applications on the client and server without modifying the code.</span></p><p class="c0"><span class="c1">JDBC Drivers JDBC is a database access protocol that enables you to connect to a</span></p><p class="c0"><span class="c1">database and run SQL statements and queries to the database. The core Java class</span></p><p class="c0"><span class="c1">libraries provide only one JDBC API, java.sql. However, JDBC is designed to enable</span></p><p class="c0"><span class="c1">vendors to supply drivers that offer the necessary specialization for a particular</span></p><p class="c0"><span class="c1">database. Oracle provides the distinct JDBC drivers shown in the following table.</span></p><p class="c0"><span class="c1">See Also: Oracle Database Java Developer&#39;s Guide explains how to</span></p><p class="c0"><span class="c1">write stored procedures in Java, how to access them from PL/SQL,</span></p><p class="c0"><span class="c1">and how to access PL/SQL functionality from Java</span></p><p class="c0"><span class="c1">Driver Description</span></p><p class="c0"><span class="c1">JDBC Thin driver You can use the JDBC Thin driver to write pure Java applications and</span></p><p class="c0"><span class="c1">applets that access Oracle SQL data. The JDBC Thin driver is especially</span></p><p class="c0"><span class="c1">well-suited for Web-based applications and applets, because you can</span></p><p class="c0"><span class="c1">dynamically download it from a Web page, similar to any other Java applet.</span></p><p class="c0"><span class="c1">JDBC OCI driver The JDBC OCI driver accesses Oracle-specific native code, that is, non-Java</span></p><p class="c0"><span class="c1">code, and libraries on the client or middle tier, providing a performance</span></p><p class="c0"><span class="c1">boost compared to the JDBC Thin driver, at the cost of significantly larger</span></p><p class="c0"><span class="c1">size and client-side installation.Overview of Triggers</span></p><p class="c0"><span class="c1">8-16 Oracle Database Concepts</span></p><p class="c0"><span class="c1">SQLJ SQLJ is an ANSI standard for embedding SQL statements in Java programs.</span></p><p class="c0"><span class="c1">You can use SQLJ in stored procedures, triggers, and methods within the Oracle</span></p><p class="c0"><span class="c1">Database environment. In addition, you can combine SQLJ programs with JDBC.</span></p><p class="c0"><span class="c1">SQLJ provides a simple, but powerful, way to develop client-side and middle-tier</span></p><p class="c0"><span class="c1">applications that access databases from Java (see &quot;SQLJ&quot; on page 19-6). A developer</span></p><p class="c0"><span class="c1">writes a program using SQLJ and then uses the SQLJ translator to translate embedded</span></p><p class="c0"><span class="c1">SQL to pure JDBC-based Java code. At run time, the program can communicate with</span></p><p class="c0"><span class="c1">multi-vendor databases using standard JDBC drivers.</span></p><p class="c0"><span class="c1">The following example shows a simple SQLJ executable statement:</span></p><p class="c0"><span class="c1">String name;</span></p><p class="c0"><span class="c1">#sql { SELECT first_name INTO :name FROM employees WHERE employee_id=112 };</span></p><p class="c0"><span class="c1">System.out.println(&quot;Name is &quot; + name + &quot;, employee number = &quot; + employee_id);</span></p><p class="c0"><span class="c1">Because Oracle Database provides a complete Java environment, you cannot compile</span></p><p class="c0"><span class="c1">SQLJ programs on a client that will run on the database. Instead, you can compile</span></p><p class="c0"><span class="c1">them directly on the server.</span></p><p class="c0"><span class="c1">Overview of Triggers</span></p><p class="c0"><span class="c1">A database trigger is a compiled stored program unit, written in either PL/SQL or</span></p><p class="c0"><span class="c1">Java, that Oracle Database invokes (&quot;fires&quot;) automatically whenever one of the</span></p><p class="c0"><span class="c1">following operations occurs:</span></p><p class="c0"><span class="c1">1. DML statements on a particular table or view, issued by any user</span></p><p class="c0"><span class="c1">DML statements modify data in schema objects. For example, inserting and</span></p><p class="c0"><span class="c1">deleting rows are DML operations.</span></p><p class="c0"><span class="c1">2. DDL statements issued either by a particular user or any user</span></p><p class="c0"><span class="c1">DDL statements define schema objects. For example, creating a table and adding a</span></p><p class="c0"><span class="c1">column are DDL operations.</span></p><p class="c0"><span class="c1">3. Database events</span></p><p class="c0"><span class="c1">User login or logoff, errors, and database startup or shutdown are events that can</span></p><p class="c0"><span class="c1">invoke triggers.</span></p><p class="c0"><span class="c1">JDBC server-side</span></p><p class="c0"><span class="c1">internal driver</span></p><p class="c0"><span class="c1">Oracle Database uses the server-side internal driver when the Java code</span></p><p class="c0"><span class="c1">runs on the server. It allows Java applications running in Oracle JVM on the</span></p><p class="c0"><span class="c1">server to access locally defined data, that is, data on the same system and in</span></p><p class="c0"><span class="c1">the same process, with JDBC. It provides a performance boost, because of its</span></p><p class="c0"><span class="c1">ability to use the underlying Oracle RDBMS libraries directly, without the</span></p><p class="c0"><span class="c1">overhead of an intervening network connection between the Java code and</span></p><p class="c0"><span class="c1">SQL data. By supporting the same Java-SQL interface on the server, Oracle</span></p><p class="c0"><span class="c1">Database does not require you to rework code when deploying it.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;ODBC and JDBC&quot; on page 19-8</span></p><p class="c0"><span class="c1">&#9632; Oracle Database 2 Day + Java Developer&#39;s Guide and Oracle Database</span></p><p class="c0"><span class="c1">JDBC Developer&#39;s Guide</span></p><p class="c0"><span class="c1">See Also: Oracle Database SQLJ Developer&#39;s Guide</span></p><p class="c0"><span class="c1">Driver DescriptionOverview of Triggers</span></p><p class="c0"><span class="c1">Server-Side Programming: PL/SQL and Java 8-17</span></p><p class="c0"><span class="c1">Triggers are schema objects that are similar to subprograms but differ in the way they</span></p><p class="c0"><span class="c1">are invoked. A subprogram is explicitly run by a user, application, or trigger. Triggers</span></p><p class="c0"><span class="c1">are implicitly invoked by the database when a triggering event occurs.</span></p><p class="c0"><span class="c1">Advantages of Triggers</span></p><p class="c0"><span class="c1">The correct use of triggers enables you to build and deploy applications that are more</span></p><p class="c0"><span class="c1">robust and that use the database more effectively. You can use triggers to:</span></p><p class="c0"><span class="c1">&#9632; Automatically generate derived column values</span></p><p class="c0"><span class="c1">&#9632; Prevent invalid transactions</span></p><p class="c0"><span class="c1">&#9632; Provide auditing and event logging</span></p><p class="c0"><span class="c1">&#9632; Record information about table access</span></p><p class="c0"><span class="c1">You can use triggers to enforce low-level business rules common for all client</span></p><p class="c0"><span class="c1">applications. For example, several applications may access the employees table. If a</span></p><p class="c0"><span class="c1">trigger on this table ensures the format of inserted data, then this business logic does</span></p><p class="c0"><span class="c1">not need to be reproduced in every client. Because the trigger cannot be circumvented</span></p><p class="c0"><span class="c1">by the application, the business logic in the trigger is used automatically.</span></p><p class="c0"><span class="c1">You can use both triggers and integrity constraints to define and enforce any type of</span></p><p class="c0"><span class="c1">integrity rule. However, Oracle strongly recommends that you only use triggers to</span></p><p class="c0"><span class="c1">enforce complex business rules not definable using an integrity constraint (see</span></p><p class="c0"><span class="c1">&quot;Introduction to Data Integrity&quot; on page 5-1).</span></p><p class="c0"><span class="c1">Excessive use of triggers can result in complex interdependencies that can be difficult</span></p><p class="c0"><span class="c1">to maintain in a large application. For example, when a trigger is invoked, a SQL</span></p><p class="c0"><span class="c1">statement within its trigger action potentially can fire other triggers, resulting in</span></p><p class="c0"><span class="c1">cascading triggers that can produce unintended effects.</span></p><p class="c0"><span class="c1">Types of Triggers</span></p><p class="c0"><span class="c1">Triggers can be categorized according to their means of invocation and the type of</span></p><p class="c0"><span class="c1">actions they perform. Oracle Database supports the following types of triggers:</span></p><p class="c0"><span class="c1">&#9632; Row triggers</span></p><p class="c0"><span class="c1">A row trigger fires each time the table is affected by the triggering statement. For</span></p><p class="c0"><span class="c1">example, if a statement updates multiple rows, then a row trigger fires once for</span></p><p class="c0"><span class="c1">each row affected by the UPDATE. If a triggering statement affects no rows, then a</span></p><p class="c0"><span class="c1">row trigger is not run. Row triggers are useful if the code in the trigger action</span></p><p class="c0"><span class="c1">depends on data provided by the triggering statement or rows that are affected.</span></p><p class="c0"><span class="c1">&#9632; Statement triggers</span></p><p class="c0"><span class="c1">A statement trigger is fired once on behalf of the triggering statement, regardless</span></p><p class="c0"><span class="c1">of the number of rows affected by the triggering statement. For example, if a</span></p><p class="c0"><span class="c1">statement deletes 100 rows from a table, a statement-level DELETE trigger is fired</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Overview of SQL Statements&quot; on page 7-3 to learn about DML</span></p><p class="c0"><span class="c1">and DDL</span></p><p class="c0"><span class="c1">&#9632; &quot;Overview of Instance Startup and Shutdown&quot; on page 13-4</span></p><p class="c0"><span class="c1">See Also: Oracle Database 2 Day Developer&#39;s Guide and Oracle Database</span></p><p class="c0"><span class="c1">PL/SQL Language Reference for guidelines and restrictions when</span></p><p class="c0"><span class="c1">planning triggers for your applicationOverview of Triggers</span></p><p class="c0"><span class="c1">8-18 Oracle Database Concepts</span></p><p class="c0"><span class="c1">only once. Statement triggers are useful if the code in the trigger action does not</span></p><p class="c0"><span class="c1">depend on the data provided by the triggering statement or the rows affected.</span></p><p class="c0"><span class="c1">&#9632; INSTEAD OF triggers</span></p><p class="c0"><span class="c1">An INSTEAD OF trigger is fired by Oracle Database instead of executing the</span></p><p class="c0"><span class="c1">triggering statement. These triggers are useful for transparently modifying views</span></p><p class="c0"><span class="c1">that cannot be modified directly through DML statements.</span></p><p class="c0"><span class="c1">&#9632; Event triggers</span></p><p class="c0"><span class="c1">You can use triggers to publish information about database events to subscribers.</span></p><p class="c0"><span class="c1">Event triggers are divided into the following categories:</span></p><p class="c0"><span class="c1">&ndash; A system event trigger can be caused by events such as database instance</span></p><p class="c0"><span class="c1">startup and shutdown or error messages.</span></p><p class="c0"><span class="c1">&ndash; A user event trigger is fired because of events related to user logon and logoff,</span></p><p class="c0"><span class="c1">DDL statements, and DML statements.</span></p><p class="c0"><span class="c1">Timing for Triggers</span></p><p class="c0"><span class="c1">You can define the trigger timing&mdash;whether the trigger action is to be run before or</span></p><p class="c0"><span class="c1">after the triggering statement. A simple trigger is a single trigger on a table that</span></p><p class="c0"><span class="c1">enables you to specify actions for exactly one of the following timing points:</span></p><p class="c0"><span class="c1">&#9632; Before the firing statement</span></p><p class="c0"><span class="c1">&#9632; Before each row affected by the firing statement</span></p><p class="c0"><span class="c1">&#9632; After each row affected by the firing statement</span></p><p class="c0"><span class="c1">&#9632; After the firing statement</span></p><p class="c0"><span class="c1">For statement and row triggers, a BEFORE trigger can enhance security and enable</span></p><p class="c0"><span class="c1">business rules before making changes to the database. The AFTER trigger is ideal for</span></p><p class="c0"><span class="c1">logging actions.</span></p><p class="c0"><span class="c1">A compound trigger can fire at multiple timing points. Compound triggers help</span></p><p class="c0"><span class="c1">program an approach in which the actions that you implement for various timing</span></p><p class="c0"><span class="c1">points share common data.</span></p><p class="c0"><span class="c1">Creation of Triggers</span></p><p class="c0"><span class="c1">The CREATE TRIGGER statement creates or replaces a database trigger. A PL/SQL</span></p><p class="c0"><span class="c1">trigger has the following general syntactic form:</span></p><p class="c0"><span class="c1">CREATE TRIGGER trigger_name</span></p><p class="c0"><span class="c1">triggering_statement</span></p><p class="c0"><span class="c1">[trigger_restriction]</span></p><p class="c0"><span class="c1">BEGIN</span></p><p class="c0"><span class="c1">triggered_action;</span></p><p class="c0"><span class="c1">END;</span></p><p class="c0"><span class="c1">A PL/SQL trigger has the following basic components:</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database 2 Day Developer&#39;s Guide</span></p><p class="c0"><span class="c1">&#9632; Oracle Database PL/SQL Language Reference</span></p><p class="c0"><span class="c1">See Also: Oracle Database PL/SQL Language Reference to learn about</span></p><p class="c0"><span class="c1">compound triggersOverview of Triggers</span></p><p class="c0"><span class="c1">Server-Side Programming: PL/SQL and Java 8-19</span></p><p class="c0"><span class="c1">&#9632; Trigger name</span></p><p class="c0"><span class="c1">The name must be unique with respect to other triggers in the same schema. For</span></p><p class="c0"><span class="c1">example, the name may be part_reorder_trigger.</span></p><p class="c0"><span class="c1">&#9632; The trigger event or statement</span></p><p class="c0"><span class="c1">A triggering event or statement is the SQL statement, database event, or user event</span></p><p class="c0"><span class="c1">that causes a trigger to be invoked. For example, a user updates a table.</span></p><p class="c0"><span class="c1">&#9632; Trigger restriction</span></p><p class="c0"><span class="c1">A trigger restriction specifies a Boolean expression that must be true for the</span></p><p class="c0"><span class="c1">trigger to fire. For example, the trigger is not invoked unless the number of</span></p><p class="c0"><span class="c1">available parts is less than a present reorder amount.</span></p><p class="c0"><span class="c1">&#9632; Triggered action</span></p><p class="c0"><span class="c1">A triggered action is the procedure that contains the SQL statements and code to</span></p><p class="c0"><span class="c1">be run when a triggering statement is issued and the trigger restriction evaluates</span></p><p class="c0"><span class="c1">to true. For example, a user inserts a row into a pending orders table.</span></p><p class="c0"><span class="c1">Suppose that you create the orders and lineitems tables as follows:</span></p><p class="c0"><span class="c1">CREATE TABLE orders</span></p><p class="c0"><span class="c1">( order_id NUMBER PRIMARY KEY,</span></p><p class="c0"><span class="c1">/* other attributes */</span></p><p class="c0"><span class="c1">line_items_count NUMBER DEFAULT 0 );</span></p><p class="c0"><span class="c1">CREATE TABLE lineitems</span></p><p class="c0"><span class="c1">( order_id REFERENCES orders,</span></p><p class="c0"><span class="c1">seq_no NUMBER,</span></p><p class="c0"><span class="c1">/* other attributes */</span></p><p class="c0"><span class="c1">CONSTRAINT lineitems PRIMARY KEY(order_id,seq_no) );</span></p><p class="c0"><span class="c1">The orders table contains a row for each unique order, whereas the lineitems table</span></p><p class="c0"><span class="c1">contains a row for each item in an order. Example 8&ndash;3 shows a sample trigger that</span></p><p class="c0"><span class="c1">automatically updates the orders table with the number of items in an order.</span></p><p class="c0"><span class="c1">Example 8&ndash;3 lineitems_trigger</span></p><p class="c0"><span class="c1">CREATE OR REPLACE TRIGGER lineitems_trigger</span></p><p class="c0"><span class="c1">AFTER INSERT OR UPDATE OR DELETE ON lineitems</span></p><p class="c0"><span class="c1">FOR EACH ROW</span></p><p class="c0"><span class="c1">BEGIN</span></p><p class="c0"><span class="c1">IF (INSERTING OR UPDATING)</span></p><p class="c0"><span class="c1">THEN</span></p><p class="c0"><span class="c1">UPDATE orders SET line_items_count = NVL(line_items_count,0)+1</span></p><p class="c0"><span class="c1">WHERE order_id = :new.order_id;</span></p><p class="c0"><span class="c1">END IF;</span></p><p class="c0"><span class="c1">IF (DELETING OR UPDATING)</span></p><p class="c0"><span class="c1">THEN</span></p><p class="c0"><span class="c1">UPDATE orders SET line_items_count = NVL(line_items_count,0)-1</span></p><p class="c0"><span class="c1">WHERE order_id = :old.order_id;</span></p><p class="c0"><span class="c1">END IF;</span></p><p class="c0"><span class="c1">END;</span></p><p class="c0"><span class="c1">/</span></p><p class="c0"><span class="c1">In Example 8&ndash;3, the triggering statement is an INSERT, UPDATE, or DELETE on the</span></p><p class="c0"><span class="c1">lineitems table. No triggering restriction exists. The trigger is invoked for each row</span></p><p class="c0"><span class="c1">changed. The trigger has access to the old and new column values of the current rowOverview of Triggers</span></p><p class="c0"><span class="c1">8-20 Oracle Database Concepts</span></p><p class="c0"><span class="c1">affected by the triggering statement. Two correlation names exist for every column of</span></p><p class="c0"><span class="c1">the table being modified: the old value (:old), and the new value (:new).</span></p><p class="c0"><span class="c1">If rows in lineitems are inserted or updated for an order, then after the action the</span></p><p class="c0"><span class="c1">trigger calculates the number of items in this order and updates the orders table with</span></p><p class="c0"><span class="c1">the count. Table 8&ndash;2 illustrates a scenario in which a customer initiates two orders and</span></p><p class="c0"><span class="c1">adds and removes line items from the orders.</span></p><p class="c0"><span class="c1">Table 8&ndash;2 Row-Level Trigger Scenario</span></p><p class="c0"><span class="c1">SQL Statement Triggered SQL Statement Description</span></p><p class="c0"><span class="c1">SQL&gt; INSERT INTO orders</span></p><p class="c0"><span class="c1">(order_id) VALUES (78);</span></p><p class="c0"><span class="c1">1 row created.</span></p><p class="c0"><span class="c1">The customer creates an order with ID 78. At</span></p><p class="c0"><span class="c1">this point the customer has no items in the</span></p><p class="c0"><span class="c1">order.</span></p><p class="c0"><span class="c1">Because no action is performed on the</span></p><p class="c0"><span class="c1">lineitems table, the trigger is not invoked.</span></p><p class="c0"><span class="c1">SQL&gt; INSERT INTO orders</span></p><p class="c0"><span class="c1">(order_id) VALUES (92);</span></p><p class="c0"><span class="c1">1 row created.</span></p><p class="c0"><span class="c1">The customer creates a separate order with</span></p><p class="c0"><span class="c1">ID 92. At this point the customer has no</span></p><p class="c0"><span class="c1">items in the order.</span></p><p class="c0"><span class="c1">Because no action is performed on the</span></p><p class="c0"><span class="c1">lineitems table, the trigger is not invoked.</span></p><p class="c0"><span class="c1">SQL&gt; INSERT INTO lineitems</span></p><p class="c0"><span class="c1">(order_id, seq_no) VALUES (78,1);</span></p><p class="c0"><span class="c1">1 row created.</span></p><p class="c0"><span class="c1">UPDATE orders SET</span></p><p class="c0"><span class="c1">line_items_count = NVL(NULL,0)+1</span></p><p class="c0"><span class="c1">WHERE order_id = 78;</span></p><p class="c0"><span class="c1">The customer adds an item to order 78.</span></p><p class="c0"><span class="c1">The INSERT invokes the trigger. The</span></p><p class="c0"><span class="c1">triggered statement increases the line item</span></p><p class="c0"><span class="c1">count for order 78 from 0 to 1.</span></p><p class="c0"><span class="c1">SQL&gt; INSERT INTO lineitems</span></p><p class="c0"><span class="c1">(order_id, seq_no) VALUES (78,2);</span></p><p class="c0"><span class="c1">1 row created.</span></p><p class="c0"><span class="c1">UPDATE orders SET</span></p><p class="c0"><span class="c1">line_items_count = NVL(1,0)+1</span></p><p class="c0"><span class="c1">WHERE order_id = 78;</span></p><p class="c0"><span class="c1">The customer adds an additional item to</span></p><p class="c0"><span class="c1">order 78.</span></p><p class="c0"><span class="c1">The INSERT invokes the trigger. The</span></p><p class="c0"><span class="c1">triggered statement increases the line item</span></p><p class="c0"><span class="c1">count for order 78 from 1 to 2.</span></p><p class="c0"><span class="c1">SQL&gt; SELECT * FROM orders;</span></p><p class="c0"><span class="c1">ORDER_ID LINE_ITEMS_COUNT</span></p><p class="c0"><span class="c1">--------- ----------------</span></p><p class="c0"><span class="c1">78 2</span></p><p class="c0"><span class="c1">92 0</span></p><p class="c0"><span class="c1">The customer queries the status of the two</span></p><p class="c0"><span class="c1">orders. Order 78 contains two items. Order</span></p><p class="c0"><span class="c1">92 contains no items.</span></p><p class="c0"><span class="c1">SQL&gt; SELECT * FROM lineitems;</span></p><p class="c0"><span class="c1">ORDER_ID SEQ_NO</span></p><p class="c0"><span class="c1">---------- ----------</span></p><p class="c0"><span class="c1">78 1</span></p><p class="c0"><span class="c1">78 2</span></p><p class="c0"><span class="c1">The customer queries the status of the line</span></p><p class="c0"><span class="c1">items. Each item is uniquely identified by</span></p><p class="c0"><span class="c1">the order ID and the sequence number.</span></p><p class="c0"><span class="c1">SQL&gt; UPDATE lineitems SET order_id</span></p><p class="c0"><span class="c1">= 92;</span></p><p class="c0"><span class="c1">2 rows updated.</span></p><p class="c0"><span class="c1">UPDATE orders SET</span></p><p class="c0"><span class="c1">line_items_count = NVL(NULL,0)+1</span></p><p class="c0"><span class="c1">WHERE order_id = 92;</span></p><p class="c0"><span class="c1">UPDATE orders SET</span></p><p class="c0"><span class="c1">line_items_count = NVL(2,0)-1</span></p><p class="c0"><span class="c1">WHERE order_id = 78;</span></p><p class="c0"><span class="c1">UPDATE orders SET</span></p><p class="c0"><span class="c1">line_items_count = NVL(1,0)+1</span></p><p class="c0"><span class="c1">WHERE order_id = 92;</span></p><p class="c0"><span class="c1">UPDATE orders SET</span></p><p class="c0"><span class="c1">line_items_count = NVL(1,0)-1</span></p><p class="c0"><span class="c1">WHERE order_id = 78;</span></p><p class="c0"><span class="c1">The customer moves the line items that were</span></p><p class="c0"><span class="c1">in order 78 to order 92.</span></p><p class="c0"><span class="c1">The UPDATE statement changes 2 rows in the</span></p><p class="c0"><span class="c1">lineitems tables, which invokes the trigger</span></p><p class="c0"><span class="c1">once for each row.</span></p><p class="c0"><span class="c1">Each time the trigger is invoked, both IF</span></p><p class="c0"><span class="c1">conditions in the trigger are met. The first</span></p><p class="c0"><span class="c1">condition increments the count for order 92,</span></p><p class="c0"><span class="c1">whereas the second condition decreases the</span></p><p class="c0"><span class="c1">count for order 78. Thus, four total UPDATE</span></p><p class="c0"><span class="c1">statements are run.Overview of Triggers</span></p><p class="c0"><span class="c1">Server-Side Programming: PL/SQL and Java 8-21</span></p><p class="c0"><span class="c1">Execution of Triggers</span></p><p class="c0"><span class="c1">Oracle Database executes a trigger internally using the same steps as for subprogram</span></p><p class="c0"><span class="c1">execution. The only subtle difference is that a user has the right to fire a trigger if he or</span></p><p class="c0"><span class="c1">she has the privilege to run the triggering statement. With this exception, the database</span></p><p class="c0"><span class="c1">validates and runs triggers the same way as stored subprograms.</span></p><p class="c0"><span class="c1">Storage of Triggers</span></p><p class="c0"><span class="c1">Oracle Database stores PL/SQL triggers in compiled form in a database schema, just</span></p><p class="c0"><span class="c1">like PL/SQL stored procedures. When a CREATE TRIGGER statement commits, the</span></p><p class="c0"><span class="c1">compiled PL/SQL code is stored in the database and the source code of the PL/SQL</span></p><p class="c0"><span class="c1">trigger is removed from the shared pool.</span></p><p class="c0"><span class="c1">SQL&gt; SELECT * FROM orders;</span></p><p class="c0"><span class="c1">ORDER_ID LINE_ITEMS_COUNT</span></p><p class="c0"><span class="c1">--------- ----------------</span></p><p class="c0"><span class="c1">78 0</span></p><p class="c0"><span class="c1">92 2</span></p><p class="c0"><span class="c1">The customer queries the status of the two</span></p><p class="c0"><span class="c1">orders. The net effect is that the line item</span></p><p class="c0"><span class="c1">count for order 92 has increased from 0 to 2,</span></p><p class="c0"><span class="c1">whereas the count for order 78 has</span></p><p class="c0"><span class="c1">decreased from 2 to 0.</span></p><p class="c0"><span class="c1">SQL&gt; SELECT * FROM lineitems;</span></p><p class="c0"><span class="c1">ORDER_ID SEQ_NO</span></p><p class="c0"><span class="c1">---------- ----------</span></p><p class="c0"><span class="c1">92 1</span></p><p class="c0"><span class="c1">92 2</span></p><p class="c0"><span class="c1">The customer queries the status of the line</span></p><p class="c0"><span class="c1">items. Each item is uniquely identified by</span></p><p class="c0"><span class="c1">the order ID and the sequence number.</span></p><p class="c0"><span class="c1">SQL&gt; DELETE FROM lineitems;</span></p><p class="c0"><span class="c1">2 rows deleted.</span></p><p class="c0"><span class="c1">UPDATE orders SET</span></p><p class="c0"><span class="c1">line_items_count = NVL(2,0)-1</span></p><p class="c0"><span class="c1">WHERE order_id = 92;</span></p><p class="c0"><span class="c1">UPDATE orders SET</span></p><p class="c0"><span class="c1">line_items_count = NVL(1,0)-1</span></p><p class="c0"><span class="c1">WHERE order_id = 92;</span></p><p class="c0"><span class="c1">The customer now removes all line items</span></p><p class="c0"><span class="c1">from all orders.</span></p><p class="c0"><span class="c1">The DELETE statement changes 2 rows in the</span></p><p class="c0"><span class="c1">lineitems tables, which invokes the trigger</span></p><p class="c0"><span class="c1">once for each row. For each trigger</span></p><p class="c0"><span class="c1">invocation, only one IF condition in the</span></p><p class="c0"><span class="c1">trigger is met. Each time the condition</span></p><p class="c0"><span class="c1">decreases the count for order 92 by 1. Thus,</span></p><p class="c0"><span class="c1">two total UPDATE statements are run.</span></p><p class="c0"><span class="c1">SQL&gt; SELECT * FROM orders;</span></p><p class="c0"><span class="c1">ORDER_ID LINE_ITEMS_COUNT</span></p><p class="c0"><span class="c1">--------- ----------------</span></p><p class="c0"><span class="c1">78 0</span></p><p class="c0"><span class="c1">92 0</span></p><p class="c0"><span class="c1">SQL&gt; SELECT * FROM lineitems;</span></p><p class="c0"><span class="c1">no rows selected</span></p><p class="c0"><span class="c1">The customer queries the status of the two</span></p><p class="c0"><span class="c1">orders. Neither order contains line items.</span></p><p class="c0"><span class="c1">The customer also queries the status of the</span></p><p class="c0"><span class="c1">line items. No items exist.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database 2 Day Developer&#39;s Guide and Oracle Database</span></p><p class="c0"><span class="c1">PL/SQL Language Reference to learn how to create triggers</span></p><p class="c0"><span class="c1">&#9632; Oracle Database PL/SQL Language Reference to learn about the</span></p><p class="c0"><span class="c1">CREATE TRIGGER command</span></p><p class="c0"><span class="c1">See Also: Oracle Database PL/SQL Language Reference to learn more</span></p><p class="c0"><span class="c1">about trigger execution</span></p><p class="c0"><span class="c1">Table 8&ndash;2 (Cont.) Row-Level Trigger Scenario</span></p><p class="c0"><span class="c1">SQL Statement Triggered SQL Statement DescriptionOverview of Triggers</span></p><p class="c0"><span class="c1">8-22 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Figure 8&ndash;7 shows a database application with SQL statements that implicitly invoke</span></p><p class="c0"><span class="c1">PL/SQL triggers. The triggers are stored separately from their associated tables.</span></p><p class="c0"><span class="c1">Figure 8&ndash;7 Triggers</span></p><p class="c0"><span class="c1">Java triggers are stored in the same manner as PL/SQL triggers. However, a Java</span></p><p class="c0"><span class="c1">trigger references Java code that was separately compiled with a CALL statement. Thus,</span></p><p class="c0"><span class="c1">creating a Java trigger involves creating Java code and creating the trigger that</span></p><p class="c0"><span class="c1">references this Java code.</span></p><p class="c0"><span class="c1">See Also: Oracle Database PL/SQL Language Reference to learn</span></p><p class="c0"><span class="c1">about compiling and storing triggers</span></p><p class="c0"><span class="c1">Oracle Database</span></p><p class="c0"><span class="c1">Update Trigger</span></p><p class="c0"><span class="c1">BEGIN</span></p><p class="c0"><span class="c1">. . . Insert Trigger</span></p><p class="c0"><span class="c1">BEGIN</span></p><p class="c0"><span class="c1">. . . Delete Trigger</span></p><p class="c0"><span class="c1">BEGIN</span></p><p class="c0"><span class="c1">. . .</span></p><p class="c0"><span class="c1">Data Dictionary</span></p><p class="c0"><span class="c1">Table t</span></p><p class="c0"><span class="c1">Database Application</span></p><p class="c0"><span class="c1">Program code</span></p><p class="c0"><span class="c1">..</span></p><p class="c0"><span class="c1">UPDATE t SET ...;</span></p><p class="c0"><span class="c1">..</span></p><p class="c0"><span class="c1">INSERT INTO t ...;</span></p><p class="c0"><span class="c1">..</span></p><p class="c0"><span class="c1">DELETE FROM t ...;Part III</span></p><p class="c0"><span class="c1">Part IIIOracle Transaction Management</span></p><p class="c0"><span class="c1">This part contains the following chapters:</span></p><p class="c0"><span class="c1">&#9632; Chapter 10, &quot;Transactions&quot;</span></p><p class="c0"><span class="c1">&#9632; Chapter 9, &quot;Data Concurrency and Consistency&quot;9</span></p><p class="c0"><span class="c1">Data Concurrency and Consistency 9-1</span></p><p class="c0"><span class="c1">Data Concurrency and Consistency 9</span></p><p class="c0"><span class="c1">This chapter explains how Oracle Database maintains consistent data in a multiuser</span></p><p class="c0"><span class="c1">database environment.</span></p><p class="c0"><span class="c1">This chapter contains the following sections:</span></p><p class="c0"><span class="c1">&#9632; Introduction to Data Concurrency and Consistency</span></p><p class="c0"><span class="c1">&#9632; Overview of Oracle Database Transaction Isolation Levels</span></p><p class="c0"><span class="c1">&#9632; Overview of the Oracle Database Locking Mechanism</span></p><p class="c0"><span class="c1">&#9632; Overview of Automatic Locks</span></p><p class="c0"><span class="c1">&#9632; Overview of Manual Data Locks</span></p><p class="c0"><span class="c1">&#9632; Overview of User-Defined Locks</span></p><p class="c0"><span class="c1">Introduction to Data Concurrency and Consistency</span></p><p class="c0"><span class="c1">In a single-user database, a user can modify data without concern for other users</span></p><p class="c0"><span class="c1">modifying the same data at the same time. However, in a multiuser database,</span></p><p class="c0"><span class="c1">statements within multiple simultaneous transactions can update the same data.</span></p><p class="c0"><span class="c1">Transactions executing simultaneously must produce meaningful and consistent</span></p><p class="c0"><span class="c1">results. Therefore, a multiuser database must provide the following:</span></p><p class="c0"><span class="c1">&#9632; Data concurrency, which ensures that users can access data at the same time</span></p><p class="c0"><span class="c1">&#9632; Data consistency, which ensures that each user sees a consistent view of the data,</span></p><p class="c0"><span class="c1">including visible changes made by the user&#39;s own transactions and committed</span></p><p class="c0"><span class="c1">transactions of other users</span></p><p class="c0"><span class="c1">To describe consistent transaction behavior when transactions run concurrently,</span></p><p class="c0"><span class="c1">database researchers have defined a transaction isolation model called serializability.</span></p><p class="c0"><span class="c1">A serializable transaction operates in an environment that makes it appear as if no</span></p><p class="c0"><span class="c1">other users were modifying data in the database.</span></p><p class="c0"><span class="c1">While this degree of isolation between transactions is generally desirable, running</span></p><p class="c0"><span class="c1">many applications in serializable mode can seriously compromise application</span></p><p class="c0"><span class="c1">throughput. Complete isolation of concurrently running transactions could mean that</span></p><p class="c0"><span class="c1">one transaction cannot perform an insertion into a table being queried by another</span></p><p class="c0"><span class="c1">transaction. In short, real-world considerations usually require a compromise between</span></p><p class="c0"><span class="c1">perfect transaction isolation and performance.</span></p><p class="c0"><span class="c1">Oracle Database maintains data consistency by using a multiversion consistency</span></p><p class="c0"><span class="c1">model and various types of locks and transactions. In this way, the database can</span></p><p class="c0"><span class="c1">present a view of data to multiple concurrent users, with each view consistent to a</span></p><p class="c0"><span class="c1">point in time. Because different versions of data blocks can exist simultaneously,Introduction to Data Concurrency and Consistency</span></p><p class="c0"><span class="c1">9-2 Oracle Database Concepts</span></p><p class="c0"><span class="c1">transactions can read the version of data committed at the point in time required by a</span></p><p class="c0"><span class="c1">query and return results that are consistent to a single point in time.</span></p><p class="c0"><span class="c1">Multiversion Read Consistency</span></p><p class="c0"><span class="c1">In Oracle Database, multiversioning is the ability to simultaneously materialize</span></p><p class="c0"><span class="c1">multiple versions of data. Oracle Database maintains multiversion read consistency,</span></p><p class="c0"><span class="c1">which means that database queries have the following characteristics:</span></p><p class="c0"><span class="c1">&#9632; Read-consistent queries</span></p><p class="c0"><span class="c1">The data returned by a query is committed and consistent with respect to a single</span></p><p class="c0"><span class="c1">point in time.</span></p><p class="c0"><span class="c1">To illustrate the problem with dirty reads, suppose one transaction updates a</span></p><p class="c0"><span class="c1">column value without committing. A second transaction reads the updated and</span></p><p class="c0"><span class="c1">dirty (uncommitted) value. The first session rolls back the transaction so that the</span></p><p class="c0"><span class="c1">column has its old value, but the second transaction proceeds using the updated</span></p><p class="c0"><span class="c1">value, corrupting the database. Dirty reads compromise data integrity, violate</span></p><p class="c0"><span class="c1">foreign keys, and ignore unique constraints.</span></p><p class="c0"><span class="c1">&#9632; Nonblocking queries</span></p><p class="c0"><span class="c1">Readers and writers of data do not block one another (see &quot;Summary of Locking</span></p><p class="c0"><span class="c1">Behavior&quot; on page 9-12).</span></p><p class="c0"><span class="c1">Statement-Level Read Consistency</span></p><p class="c0"><span class="c1">Oracle Database always enforces statement-level read consistency, which guarantees</span></p><p class="c0"><span class="c1">that data returned by a single query is committed and consistent with respect to a</span></p><p class="c0"><span class="c1">single point in time. The point in time to which a single SQL statement is consistent</span></p><p class="c0"><span class="c1">depends on the transaction isolation level and the nature of the query:</span></p><p class="c0"><span class="c1">&#9632; In the read committed isolation level, this point is the time at which the statement</span></p><p class="c0"><span class="c1">was opened. For example, if a SELECT statement opens at SCN 1000, then this</span></p><p class="c0"><span class="c1">statement is consistent to SCN 1000.</span></p><p class="c0"><span class="c1">&#9632; In a serializable or read-only transaction this point is the time the transaction</span></p><p class="c0"><span class="c1">began. For example, if a transaction begins at SCN 1000, and if multiple SELECT</span></p><p class="c0"><span class="c1">statements occur in this transaction, then each statement is consistent to SCN 1000.</span></p><p class="c0"><span class="c1">&#9632; In a Flashback Query operation (SELECT ... AS OF), the SELECT statement</span></p><p class="c0"><span class="c1">explicitly specifies the point in time. For example, you can query a table as it</span></p><p class="c0"><span class="c1">appeared last Thursday at 2 p.m.</span></p><p class="c0"><span class="c1">Transaction-Level Read Consistency</span></p><p class="c0"><span class="c1">Oracle Database can also provide read consistency to all queries in a transaction,</span></p><p class="c0"><span class="c1">known as transaction-level read consistency. In this case, each statement in a</span></p><p class="c0"><span class="c1">See Also: Chapter 5, &quot;Data Integrity&quot; and Chapter 10,</span></p><p class="c0"><span class="c1">&quot;Transactions&quot;</span></p><p class="c0"><span class="c1">Important: Oracle Database never permits dirty reads, which occur</span></p><p class="c0"><span class="c1">when a transaction reads uncommitted data in another transaction.</span></p><p class="c0"><span class="c1">See Also: Oracle Database Advanced Application Developer&#39;s Guide to</span></p><p class="c0"><span class="c1">learn about Flashback QueryIntroduction to Data Concurrency and Consistency</span></p><p class="c0"><span class="c1">Data Concurrency and Consistency 9-3</span></p><p class="c0"><span class="c1">transaction sees data from the same point in time, which is the time at which the</span></p><p class="c0"><span class="c1">transaction began.</span></p><p class="c0"><span class="c1">Queries made by a serializable transaction see changes made by the transaction itself.</span></p><p class="c0"><span class="c1">For example, a transaction that updates employees and then queries employees will</span></p><p class="c0"><span class="c1">see the updates. Transaction-level read consistency produces repeatable reads and</span></p><p class="c0"><span class="c1">does not expose a query to phantom reads.</span></p><p class="c0"><span class="c1">Read Consistency and Undo Segments</span></p><p class="c0"><span class="c1">To manage the multiversion read consistency model, the database must create a</span></p><p class="c0"><span class="c1">read-consistent set of data when a table is simultaneously queried and updated. Oracle</span></p><p class="c0"><span class="c1">Database achieves this goal through undo data.</span></p><p class="c0"><span class="c1">Whenever a user modifies data, Oracle Database creates undo entries, which it writes</span></p><p class="c0"><span class="c1">to undo segments (&quot;Undo Segments&quot; on page 12-24). The undo segments contain the</span></p><p class="c0"><span class="c1">old values of data that have been changed by uncommitted or recently committed</span></p><p class="c0"><span class="c1">transactions. Thus, multiple versions of the same data, all at different points in time,</span></p><p class="c0"><span class="c1">can exist in the database. The database can use snapshots of data at different points in</span></p><p class="c0"><span class="c1">time to provide read-consistent views of the data and enable nonblocking queries.</span></p><p class="c0"><span class="c1">Read consistency is guaranteed in single-instance and Oracle Real Application</span></p><p class="c0"><span class="c1">Clusters (Oracle RAC) environments. Oracle RAC uses a cache-to-cache block transfer</span></p><p class="c0"><span class="c1">mechanism known as Cache Fusion to transfer read-consistent images of data blocks</span></p><p class="c0"><span class="c1">from one database instance to another.</span></p><p class="c0"><span class="c1">Read Consistency: Example Figure 9&ndash;1 shows a query that uses undo data to provide</span></p><p class="c0"><span class="c1">statement-level read consistency in the read committed isolation level.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Internal LOBs&quot; on page 19-12 to learn about read consistency</span></p><p class="c0"><span class="c1">mechanisms for LOBs</span></p><p class="c0"><span class="c1">&#9632; Oracle Database 2 Day + Real Application Clusters Guide to learn</span></p><p class="c0"><span class="c1">about Cache FusionIntroduction to Data Concurrency and Consistency</span></p><p class="c0"><span class="c1">9-4 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Figure 9&ndash;1 Read Consistency in the Read Committed Isolation Level</span></p><p class="c0"><span class="c1">As the database retrieves data blocks on behalf of a query, the database ensures that</span></p><p class="c0"><span class="c1">the data in each block reflects the contents of the block when the query began. The</span></p><p class="c0"><span class="c1">database rolls back changes to the block as needed to reconstruct the block to the point</span></p><p class="c0"><span class="c1">in time the query started processing.</span></p><p class="c0"><span class="c1">The database uses a mechanism called an SCN to guarantee the order of transactions.</span></p><p class="c0"><span class="c1">As the SELECT statement enters the execution phase, the database determines the SCN</span></p><p class="c0"><span class="c1">recorded at the time the query began executing. In Figure 9&ndash;1, this SCN is 10023. The</span></p><p class="c0"><span class="c1">query only sees committed data with respect to SCN 10023.</span></p><p class="c0"><span class="c1">In Figure 9&ndash;1, blocks with SCNs after 10023 indicate changed data, as shown by the</span></p><p class="c0"><span class="c1">two blocks with SCN 10024. The SELECT statement requires a version of the block that</span></p><p class="c0"><span class="c1">is consistent with committed changes. The database copies current data blocks to a</span></p><p class="c0"><span class="c1">new buffer and applies undo data to reconstruct previous versions of the blocks. These</span></p><p class="c0"><span class="c1">reconstructed data blocks are called consistent read (CR) clones.</span></p><p class="c0"><span class="c1">In Figure 9&ndash;1, the database creates two CR clones: one block consistent to SCN 10006</span></p><p class="c0"><span class="c1">and the other block consistent to SCN 10021. The database returns the reconstructed</span></p><p class="c0"><span class="c1">data for the query. In this way, Oracle Database prevents dirty reads.</span></p><p class="c0"><span class="c1">See Also: &quot;Database Buffer Cache&quot; on page 14-9 and &quot;System</span></p><p class="c0"><span class="c1">Change Numbers (SCNs)&quot; on page 10-5</span></p><p class="c0"><span class="c1">SELECT . . .</span></p><p class="c0"><span class="c1">(SCN 10023)</span></p><p class="c0"><span class="c1">Undo</span></p><p class="c0"><span class="c1">Segment</span></p><p class="c0"><span class="c1">SCN 10021</span></p><p class="c0"><span class="c1">SCN 10021</span></p><p class="c0"><span class="c1">SCN 10024</span></p><p class="c0"><span class="c1">SCN 10008</span></p><p class="c0"><span class="c1">SCN 10024</span></p><p class="c0"><span class="c1">SCN 10011</span></p><p class="c0"><span class="c1">SCN 10021</span></p><p class="c0"><span class="c1">SCN 10006 SCN 10021Introduction to Data Concurrency and Consistency</span></p><p class="c0"><span class="c1">Data Concurrency and Consistency 9-5</span></p><p class="c0"><span class="c1">Read Consistency and Transaction Tables The database uses information in the block</span></p><p class="c0"><span class="c1">header, also called an interested transaction list (ITL), to determine whether a</span></p><p class="c0"><span class="c1">transaction was uncommitted when the database began modifying the block. The</span></p><p class="c0"><span class="c1">block header of every segment block contains an ITL.</span></p><p class="c0"><span class="c1">Entries in the ITL describe which transactions have rows locked and which rows in the</span></p><p class="c0"><span class="c1">block contain committed and uncommitted changes. The ITL points to the transaction</span></p><p class="c0"><span class="c1">table in the undo segment, which provides information about the timing of changes</span></p><p class="c0"><span class="c1">made to the database.</span></p><p class="c0"><span class="c1">In a sense, the block header contains a recent history of transactions that affected each</span></p><p class="c0"><span class="c1">row in the block. The INITRANS parameter of the CREATE TABLE and ALTER TABLE</span></p><p class="c0"><span class="c1">statements controls the amount of transaction history that is kept.</span></p><p class="c0"><span class="c1">Locking Mechanisms</span></p><p class="c0"><span class="c1">In general, multiuser databases use some form of data locking to solve the problems</span></p><p class="c0"><span class="c1">associated with data concurrency, consistency, and integrity. Locks are mechanisms</span></p><p class="c0"><span class="c1">that prevent destructive interaction between transactions accessing the same resource.</span></p><p class="c0"><span class="c1">ANSI/ISO Transaction Isolation Levels</span></p><p class="c0"><span class="c1">The SQL standard, which has been adopted by both ANSI and ISO/IEC, defines four</span></p><p class="c0"><span class="c1">levels of transaction isolation. These levels have differing degrees of impact on</span></p><p class="c0"><span class="c1">transaction processing throughput.</span></p><p class="c0"><span class="c1">These isolation levels are defined in terms of phenomena that must be prevented</span></p><p class="c0"><span class="c1">between concurrently executing transactions. The preventable phenomena are:</span></p><p class="c0"><span class="c1">&#9632; Dirty reads</span></p><p class="c0"><span class="c1">A transaction reads data that has been written by another transaction that has not</span></p><p class="c0"><span class="c1">been committed yet.</span></p><p class="c0"><span class="c1">&#9632; Nonrepeatable (fuzzy) reads</span></p><p class="c0"><span class="c1">A transaction rereads data it has previously read and finds that another committed</span></p><p class="c0"><span class="c1">transaction has modified or deleted the data. For example, a user queries a row</span></p><p class="c0"><span class="c1">and then later queries the same row, only to discover that the data has changed.</span></p><p class="c0"><span class="c1">&#9632; Phantom reads</span></p><p class="c0"><span class="c1">A transaction reruns a query returning a set of rows that satisfies a search</span></p><p class="c0"><span class="c1">condition and finds that another committed transaction has inserted additional</span></p><p class="c0"><span class="c1">rows that satisfy the condition.</span></p><p class="c0"><span class="c1">For example, a transaction queries the number of employees. Five minutes later it</span></p><p class="c0"><span class="c1">performs the same query, but now the number has increased by one because</span></p><p class="c0"><span class="c1">another user inserted a record for a new hire. More data satisfies the query criteria</span></p><p class="c0"><span class="c1">than before, but unlike in a fuzzy read the previously read data is unchanged.</span></p><p class="c0"><span class="c1">The SQL standard defines four levels of isolation in terms of the phenomena that a</span></p><p class="c0"><span class="c1">transaction running at a particular isolation level is permitted to experience. Table 9&ndash;1</span></p><p class="c0"><span class="c1">shows the levels.</span></p><p class="c0"><span class="c1">See Also: Oracle Database SQL Language Reference to learn about the</span></p><p class="c0"><span class="c1">INITRANS parameter</span></p><p class="c0"><span class="c1">See Also: &quot;Overview of the Oracle Database Locking Mechanism&quot;</span></p><p class="c0"><span class="c1">on page 9-11Overview of Oracle Database Transaction Isolation Levels</span></p><p class="c0"><span class="c1">9-6 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Oracle Database offers the read committed (default) and serializable isolation levels.</span></p><p class="c0"><span class="c1">Also, the database offers a read-only mode.</span></p><p class="c0"><span class="c1">Overview of Oracle Database Transaction Isolation Levels</span></p><p class="c0"><span class="c1">Table 9&ndash;1 summarizes the ANSI standard for transaction isolation levels. The standard</span></p><p class="c0"><span class="c1">is defined in terms of the phenomena that are either permitted or prevented for each</span></p><p class="c0"><span class="c1">isolation level. Oracle Database provides the transaction isolation levels:</span></p><p class="c0"><span class="c1">&#9632; Read Committed Isolation Level</span></p><p class="c0"><span class="c1">&#9632; Serializable Isolation Level</span></p><p class="c0"><span class="c1">&#9632; Read-Only Isolation Level</span></p><p class="c0"><span class="c1">Read Committed Isolation Level</span></p><p class="c0"><span class="c1">In the read committed isolation level, which is the default, every query executed by a</span></p><p class="c0"><span class="c1">transaction sees only data committed before the query&mdash;not the transaction&mdash;began.</span></p><p class="c0"><span class="c1">This level of isolation is appropriate for database environments in which few</span></p><p class="c0"><span class="c1">transactions are likely to conflict.</span></p><p class="c0"><span class="c1">A query in a read committed transaction avoids reading data that commits while the</span></p><p class="c0"><span class="c1">query is in progress. For example, if a query is halfway through a scan of a million-row</span></p><p class="c0"><span class="c1">table, and if a different transaction commits an update to row 950,000, then the query</span></p><p class="c0"><span class="c1">does not see this change when it reads row 950,000. However, because the database</span></p><p class="c0"><span class="c1">does not prevent other transactions from modifying data read by a query, other</span></p><p class="c0"><span class="c1">transactions may change data between query executions. Thus, a transaction that runs</span></p><p class="c0"><span class="c1">the same query twice may experience fuzzy reads and phantoms.</span></p><p class="c0"><span class="c1">Table 9&ndash;1 Preventable Read Phenomena by Isolation Level</span></p><p class="c0"><span class="c1">Isolation Level Dirty Read Nonrepeatable Read Phantom Read</span></p><p class="c0"><span class="c1">Read uncommitted Possible Possible Possible</span></p><p class="c0"><span class="c1">Read committed Not possible Possible Possible</span></p><p class="c0"><span class="c1">Repeatable read Not possible Not possible Possible</span></p><p class="c0"><span class="c1">Serializable Not possible Not possible Not possible</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Overview of Oracle Database Transaction Isolation Levels&quot; on</span></p><p class="c0"><span class="c1">page 9-6 to learn about read committed, serializable, and</span></p><p class="c0"><span class="c1">read-only isolation levels</span></p><p class="c0"><span class="c1">&#9632; Oracle Database SQL Language Reference for a discussion of Oracle</span></p><p class="c0"><span class="c1">Database conformance to SQL standards</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Advanced Application Developer&#39;s Guide to learn</span></p><p class="c0"><span class="c1">more about transaction isolation levels</span></p><p class="c0"><span class="c1">&#9632; Oracle Database SQL Language Reference and Oracle Database</span></p><p class="c0"><span class="c1">PL/SQL Language Reference to learn about SET TRANSACTION</span></p><p class="c0"><span class="c1">ISOLATION LEVELOverview of Oracle Database Transaction Isolation Levels</span></p><p class="c0"><span class="c1">Data Concurrency and Consistency 9-7</span></p><p class="c0"><span class="c1">Read Consistency in the Read Committed Isolation Level</span></p><p class="c0"><span class="c1">A consistent result set is provided for every query, guaranteeing data consistency, with</span></p><p class="c0"><span class="c1">no action by the user. An implicit query, such as a query implied by a WHERE clause in</span></p><p class="c0"><span class="c1">an UPDATE statement, is guaranteed a consistent set of results. However, each statement</span></p><p class="c0"><span class="c1">in an implicit query does not see the changes made by the DML statement itself, but</span></p><p class="c0"><span class="c1">sees the data as it existed before changes were made.</span></p><p class="c0"><span class="c1">If a SELECT list contains a PL/SQL function, then the database applies statement-level</span></p><p class="c0"><span class="c1">read consistency at the statement level for SQL run within the PL/SQL function code,</span></p><p class="c0"><span class="c1">rather than at the parent SQL level. For example, a function could access a table whose</span></p><p class="c0"><span class="c1">data is changed and committed by another user. For each execution of the SELECT in</span></p><p class="c0"><span class="c1">the function, a new read-consistent snapshot is established.</span></p><p class="c0"><span class="c1">Conflicting Writes in Read Committed Transactions</span></p><p class="c0"><span class="c1">In a read committed transaction, a conflicting write occurs when the transaction</span></p><p class="c0"><span class="c1">attempts to change a row updated by an uncommitted concurrent transaction,</span></p><p class="c0"><span class="c1">sometimes called a blocking transaction. The read committed transaction waits for the</span></p><p class="c0"><span class="c1">blocking transaction to end and release its row lock. The options are as follows:</span></p><p class="c0"><span class="c1">&#9632; If the blocking transaction rolls back, then the waiting transaction proceeds to</span></p><p class="c0"><span class="c1">change the previously locked row as if the other transaction never existed.</span></p><p class="c0"><span class="c1">&#9632; If the blocking transaction commits and releases its locks, then the waiting</span></p><p class="c0"><span class="c1">transaction proceeds with its intended update to the newly changed row.</span></p><p class="c0"><span class="c1">Table 9&ndash;2 shows how transaction 1, which can be either serializable or read committed,</span></p><p class="c0"><span class="c1">interacts with read committed transaction 2. Table 9&ndash;2 shows a classic situation known</span></p><p class="c0"><span class="c1">as a lost update (see &quot;Use of Locks&quot; on page 9-12). The update made by transaction 1 is</span></p><p class="c0"><span class="c1">not in the table even though transaction 1 committed it. Devising a strategy to handle lost</span></p><p class="c0"><span class="c1">updates is an important part of application development.</span></p><p class="c0"><span class="c1">See Also: &quot;Subqueries and Implicit Queries&quot; on page 7-7</span></p><p class="c0"><span class="c1">Table 9&ndash;2 Conflicting Writes and Lost Updates in a READ COMMITTED Transaction</span></p><p class="c0"><span class="c1">Session 1 Session 2 Explanation</span></p><p class="c0"><span class="c1">SQL&gt; SELECT last_name, salary</span></p><p class="c0"><span class="c1">FROM employees WHERE last_name</span></p><p class="c0"><span class="c1">IN (&#39;Banda&#39;,&#39;Greene&#39;,&#39;Hintz&#39;);</span></p><p class="c0"><span class="c1">LAST_NAME SALARY</span></p><p class="c0"><span class="c1">------------- ----------</span></p><p class="c0"><span class="c1">Banda 6200</span></p><p class="c0"><span class="c1">Greene 9500</span></p><p class="c0"><span class="c1">Session 1 queries the salaries for Banda,</span></p><p class="c0"><span class="c1">Greene, and Hintz. No employee named</span></p><p class="c0"><span class="c1">Hintz is found.</span></p><p class="c0"><span class="c1">SQL&gt; UPDATE employees SET salary</span></p><p class="c0"><span class="c1">= 7000 WHERE last_name = &#39;Banda&#39;;</span></p><p class="c0"><span class="c1">Session 1 begins a transaction by updating</span></p><p class="c0"><span class="c1">the Banda salary. The default isolation level</span></p><p class="c0"><span class="c1">for transaction 1 is READ COMMITTED.</span></p><p class="c0"><span class="c1">SQL&gt; SET TRANSACTION ISOLATION</span></p><p class="c0"><span class="c1">LEVEL READ COMMITTED;</span></p><p class="c0"><span class="c1">Session 2 begins transaction 2 and sets the</span></p><p class="c0"><span class="c1">isolation level explicitly to READ COMMITTED.</span></p><p class="c0"><span class="c1">SQL&gt; SELECT last_name, salary</span></p><p class="c0"><span class="c1">FROM employees WHERE last_name IN</span></p><p class="c0"><span class="c1">(&#39;Banda&#39;,&#39;Greene&#39;,&#39;Hintz&#39;);</span></p><p class="c0"><span class="c1">LAST_NAME SALARY</span></p><p class="c0"><span class="c1">------------- ----------</span></p><p class="c0"><span class="c1">Banda 6200</span></p><p class="c0"><span class="c1">Greene 9500</span></p><p class="c0"><span class="c1">Transaction 2 queries the salaries for</span></p><p class="c0"><span class="c1">Banda, Greene, and Hintz. Oracle Database</span></p><p class="c0"><span class="c1">uses read consistency to show the salary for</span></p><p class="c0"><span class="c1">Banda before the uncommitted update</span></p><p class="c0"><span class="c1">made by transaction 1.Overview of Oracle Database Transaction Isolation Levels</span></p><p class="c0"><span class="c1">9-8 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Serializable Isolation Level</span></p><p class="c0"><span class="c1">In the serialization isolation level, a transaction sees only changes committed at the</span></p><p class="c0"><span class="c1">time the transaction&mdash;not the query&mdash;began and changes made by the transaction</span></p><p class="c0"><span class="c1">itself. A serializable transaction operates in an environment that makes it appear as if</span></p><p class="c0"><span class="c1">no other users were modifying data in the database.</span></p><p class="c0"><span class="c1">Serializable isolation is suitable for environments:</span></p><p class="c0"><span class="c1">&#9632; With large databases and short transactions that update only a few rows</span></p><p class="c0"><span class="c1">SQL&gt; UPDATE employees SET salary =</span></p><p class="c0"><span class="c1">9900 WHERE last_name = &#39;Greene&#39;;</span></p><p class="c0"><span class="c1">Transaction 2 updates the salary for Greene</span></p><p class="c0"><span class="c1">successfully because transaction 1 locked</span></p><p class="c0"><span class="c1">only the Banda row (see &quot;Row Locks (TX)&quot;</span></p><p class="c0"><span class="c1">on page 9-18).</span></p><p class="c0"><span class="c1">SQL&gt; INSERT INTO employees</span></p><p class="c0"><span class="c1">(employee_id, last_name, email,</span></p><p class="c0"><span class="c1">hire_date, job_id) VALUES (210,</span></p><p class="c0"><span class="c1">&#39;Hintz&#39;, &#39;JHINTZ&#39;, SYSDATE,</span></p><p class="c0"><span class="c1">&#39;SH_CLERK&#39;);</span></p><p class="c0"><span class="c1">Transaction 1 inserts a row for employee</span></p><p class="c0"><span class="c1">Hintz, but does not commit.</span></p><p class="c0"><span class="c1">SQL&gt; SELECT last_name, salary</span></p><p class="c0"><span class="c1">FROM employees WHERE last_name IN</span></p><p class="c0"><span class="c1">(&#39;Banda&#39;,&#39;Greene&#39;,&#39;Hintz&#39;);</span></p><p class="c0"><span class="c1">LAST_NAME SALARY</span></p><p class="c0"><span class="c1">------------- ----------</span></p><p class="c0"><span class="c1">Banda 6200</span></p><p class="c0"><span class="c1">Greene 9900</span></p><p class="c0"><span class="c1">Transaction 2 queries the salaries for</span></p><p class="c0"><span class="c1">employees Banda, Greene, and Hintz.</span></p><p class="c0"><span class="c1">Transaction 2 sees its own update to the</span></p><p class="c0"><span class="c1">salary for Greene. Transaction 2 does not</span></p><p class="c0"><span class="c1">see the uncommitted update to the salary</span></p><p class="c0"><span class="c1">for Banda or the insertion for Hintz made</span></p><p class="c0"><span class="c1">by transaction 1.</span></p><p class="c0"><span class="c1">SQL&gt; UPDATE employees SET salary =</span></p><p class="c0"><span class="c1">6300 WHERE last_name = &#39;Banda&#39;;</span></p><p class="c0"><span class="c1">-- prompt does not return</span></p><p class="c0"><span class="c1">Transaction 2 attempts to update the row</span></p><p class="c0"><span class="c1">for Banda, which is currently locked by</span></p><p class="c0"><span class="c1">transaction 1, creating a conflicting write.</span></p><p class="c0"><span class="c1">Transaction 2 waits until transaction 1 ends.</span></p><p class="c0"><span class="c1">SQL&gt; COMMIT; Transaction 1 commits its work, ending the</span></p><p class="c0"><span class="c1">transaction.</span></p><p class="c0"><span class="c1">1 row updated.</span></p><p class="c0"><span class="c1">SQL&gt;</span></p><p class="c0"><span class="c1">The lock on the Banda row is now released,</span></p><p class="c0"><span class="c1">so transaction 2 proceeds with its update to</span></p><p class="c0"><span class="c1">the salary for Banda.</span></p><p class="c0"><span class="c1">SQL&gt; SELECT last_name, salary</span></p><p class="c0"><span class="c1">FROM employees WHERE last_name IN</span></p><p class="c0"><span class="c1">(&#39;Banda&#39;,&#39;Greene&#39;,&#39;Hintz&#39;);</span></p><p class="c0"><span class="c1">LAST_NAME SALARY</span></p><p class="c0"><span class="c1">------------- ----------</span></p><p class="c0"><span class="c1">Banda 6300</span></p><p class="c0"><span class="c1">Greene 9900</span></p><p class="c0"><span class="c1">Hintz</span></p><p class="c0"><span class="c1">Transaction 2 queries the salaries for</span></p><p class="c0"><span class="c1">employees Banda, Greene, and Hintz. The</span></p><p class="c0"><span class="c1">Hintz insert committed by transaction 1 is</span></p><p class="c0"><span class="c1">now visible to transaction 2. Transaction 2</span></p><p class="c0"><span class="c1">sees its own update to the Banda salary.</span></p><p class="c0"><span class="c1">COMMIT; Transaction 2 commits its work, ending the</span></p><p class="c0"><span class="c1">transaction.</span></p><p class="c0"><span class="c1">SQL&gt; SELECT last_name, salary</span></p><p class="c0"><span class="c1">FROM employees WHERE last_name</span></p><p class="c0"><span class="c1">IN (&#39;Banda&#39;,&#39;Greene&#39;,&#39;Hintz&#39;);</span></p><p class="c0"><span class="c1">LAST_NAME SALARY</span></p><p class="c0"><span class="c1">------------- ----------</span></p><p class="c0"><span class="c1">Banda 6300</span></p><p class="c0"><span class="c1">Greene 9900</span></p><p class="c0"><span class="c1">Hintz</span></p><p class="c0"><span class="c1">Session 1 queries the rows for Banda,</span></p><p class="c0"><span class="c1">Greene, and Hintz. The salary for Banda is</span></p><p class="c0"><span class="c1">6300, which is the update made by</span></p><p class="c0"><span class="c1">transaction 2. The update of Banda&#39;s salary</span></p><p class="c0"><span class="c1">to 7000 made by transaction 1 is now &quot;lost.&quot;</span></p><p class="c0"><span class="c1">Table 9&ndash;2 (Cont.) Conflicting Writes and Lost Updates in a READ COMMITTED Transaction</span></p><p class="c0"><span class="c1">Session 1 Session 2 ExplanationOverview of Oracle Database Transaction Isolation Levels</span></p><p class="c0"><span class="c1">Data Concurrency and Consistency 9-9</span></p><p class="c0"><span class="c1">&#9632; Where the chance that two concurrent transactions will modify the same rows is</span></p><p class="c0"><span class="c1">relatively low</span></p><p class="c0"><span class="c1">&#9632; Where relatively long-running transactions are primarily read only</span></p><p class="c0"><span class="c1">In serializable isolation, the read consistency normally obtained at the statement level</span></p><p class="c0"><span class="c1">extends to the entire transaction. Any row read by the transaction is assured to be the</span></p><p class="c0"><span class="c1">same when reread. Any query is guaranteed to return the same results for the duration</span></p><p class="c0"><span class="c1">of the transaction, so changes made by other transactions are not visible to the query</span></p><p class="c0"><span class="c1">regardless of how long it has been running. Serializable transactions do not experience</span></p><p class="c0"><span class="c1">dirty reads, fuzzy reads, or phantom reads.</span></p><p class="c0"><span class="c1">Oracle Database permits a serializable transaction to modify a row only if changes to</span></p><p class="c0"><span class="c1">the row made by other transactions were already committed when the serializable</span></p><p class="c0"><span class="c1">transaction began. The database generates an error when a serializable transaction</span></p><p class="c0"><span class="c1">tries to update or delete data changed by a different transaction that committed after</span></p><p class="c0"><span class="c1">the serializable transaction began:</span></p><p class="c0"><span class="c1">ORA-08177: Cannot serialize access for this transaction</span></p><p class="c0"><span class="c1">When a serializable transaction fails with the ORA-08177 error, an application can take</span></p><p class="c0"><span class="c1">several actions, including the following:</span></p><p class="c0"><span class="c1">&#9632; Commit the work executed to that point</span></p><p class="c0"><span class="c1">&#9632; Execute additional (but different) statements, perhaps after rolling back to a</span></p><p class="c0"><span class="c1">savepoint established earlier in the transaction</span></p><p class="c0"><span class="c1">&#9632; Roll back the entire transaction</span></p><p class="c0"><span class="c1">Table 9&ndash;3 shows how a serializable transaction interacts with other transactions. If the</span></p><p class="c0"><span class="c1">serializable transaction does not try to change a row committed by another transaction</span></p><p class="c0"><span class="c1">after the serializable transaction began, then a serialized access problem is avoided.</span></p><p class="c0"><span class="c1">Table 9&ndash;3 Serializable Transaction</span></p><p class="c0"><span class="c1">Session 1 Session 2 Explanation</span></p><p class="c0"><span class="c1">SQL&gt; SELECT last_name, salary</span></p><p class="c0"><span class="c1">FROM employees WHERE last_name</span></p><p class="c0"><span class="c1">IN (&#39;Banda&#39;,&#39;Greene&#39;,&#39;Hintz&#39;);</span></p><p class="c0"><span class="c1">LAST_NAME SALARY</span></p><p class="c0"><span class="c1">------------- ----------</span></p><p class="c0"><span class="c1">Banda 6200</span></p><p class="c0"><span class="c1">Greene 9500</span></p><p class="c0"><span class="c1">Session 1 queries the salaries for Banda,</span></p><p class="c0"><span class="c1">Greene, and Hintz. No employee named</span></p><p class="c0"><span class="c1">Hintz is found.</span></p><p class="c0"><span class="c1">SQL&gt; UPDATE employees SET salary</span></p><p class="c0"><span class="c1">= 7000 WHERE last_name = &#39;Banda&#39;;</span></p><p class="c0"><span class="c1">Session 1 begins transaction 1 by updating</span></p><p class="c0"><span class="c1">the Banda salary. The default isolation level</span></p><p class="c0"><span class="c1">for is READ COMMITTED.</span></p><p class="c0"><span class="c1">SQL&gt; SET TRANSACTION ISOLATION</span></p><p class="c0"><span class="c1">LEVEL SERIALIZABLE;</span></p><p class="c0"><span class="c1">Session 2 begins transaction 2 and sets it to</span></p><p class="c0"><span class="c1">the SERIALIZABLE isolation level.</span></p><p class="c0"><span class="c1">SQL&gt; SELECT last_name, salary</span></p><p class="c0"><span class="c1">FROM employees WHERE last_name</span></p><p class="c0"><span class="c1">IN (&#39;Banda&#39;,&#39;Greene&#39;,&#39;Hintz&#39;);</span></p><p class="c0"><span class="c1">LAST_NAME SALARY</span></p><p class="c0"><span class="c1">------------- ----------</span></p><p class="c0"><span class="c1">Banda 6200</span></p><p class="c0"><span class="c1">Greene 9500</span></p><p class="c0"><span class="c1">Transaction 2 queries the salaries for</span></p><p class="c0"><span class="c1">Banda, Greene, and Hintz. Oracle Database</span></p><p class="c0"><span class="c1">uses read consistency to show the salary for</span></p><p class="c0"><span class="c1">Banda before the uncommitted update made</span></p><p class="c0"><span class="c1">by transaction 1.</span></p><p class="c0"><span class="c1">SQL&gt; UPDATE employees SET salary =</span></p><p class="c0"><span class="c1">9900 WHERE last_name = &#39;Greene&#39;;</span></p><p class="c0"><span class="c1">Transaction 2 updates the Greene salary</span></p><p class="c0"><span class="c1">successfully because only the Banda row is</span></p><p class="c0"><span class="c1">locked.Overview of Oracle Database Transaction Isolation Levels</span></p><p class="c0"><span class="c1">9-10 Oracle Database Concepts</span></p><p class="c0"><span class="c1">SQL&gt; INSERT INTO employees</span></p><p class="c0"><span class="c1">(employee_id, last_name, email,</span></p><p class="c0"><span class="c1">hire_date, job_id) VALUES (210,</span></p><p class="c0"><span class="c1">&#39;Hintz&#39;, &#39;JHINTZ&#39;, SYSDATE,</span></p><p class="c0"><span class="c1">&#39;SH_CLERK&#39;);</span></p><p class="c0"><span class="c1">Transaction 1 inserts a row for employee</span></p><p class="c0"><span class="c1">Hintz.</span></p><p class="c0"><span class="c1">SQL&gt; COMMIT; Transaction 1 commits its work, ending the</span></p><p class="c0"><span class="c1">transaction.</span></p><p class="c0"><span class="c1">SQL&gt; SELECT last_name, salary</span></p><p class="c0"><span class="c1">FROM employees WHERE last_name</span></p><p class="c0"><span class="c1">IN (&#39;Banda&#39;,&#39;Greene&#39;,&#39;Hintz&#39;);</span></p><p class="c0"><span class="c1">LAST_NAME SALARY</span></p><p class="c0"><span class="c1">------------- ----------</span></p><p class="c0"><span class="c1">Banda 7000</span></p><p class="c0"><span class="c1">Greene 9500</span></p><p class="c0"><span class="c1">Hintz</span></p><p class="c0"><span class="c1">SQL&gt; SELECT last_name, salary</span></p><p class="c0"><span class="c1">FROM employees WHERE last_name IN</span></p><p class="c0"><span class="c1">(&#39;Banda&#39;,&#39;Greene&#39;,&#39;Hintz&#39;);</span></p><p class="c0"><span class="c1">LAST_NAME SALARY</span></p><p class="c0"><span class="c1">------------- ----------</span></p><p class="c0"><span class="c1">Banda 6200</span></p><p class="c0"><span class="c1">Greene 9900</span></p><p class="c0"><span class="c1">Session 1 queries the salaries for employees</span></p><p class="c0"><span class="c1">Banda, Greene, and Hintz and sees changes</span></p><p class="c0"><span class="c1">committed by transaction 1. Session 1 does</span></p><p class="c0"><span class="c1">not see the uncommitted Greene update</span></p><p class="c0"><span class="c1">made by transaction 2.</span></p><p class="c0"><span class="c1">Transaction 2 queries the salaries for</span></p><p class="c0"><span class="c1">employees Banda, Greene, and Hintz.</span></p><p class="c0"><span class="c1">Oracle Database read consistency ensures</span></p><p class="c0"><span class="c1">that the Hintz insert and Banda update</span></p><p class="c0"><span class="c1">committed by transaction 1 are not visible</span></p><p class="c0"><span class="c1">to transaction 2. Transaction 2 sees its own</span></p><p class="c0"><span class="c1">update to the Banda salary.</span></p><p class="c0"><span class="c1">COMMIT; Transaction 2 commits its work, ending the</span></p><p class="c0"><span class="c1">transaction.</span></p><p class="c0"><span class="c1">SQL&gt; SELECT last_name, salary</span></p><p class="c0"><span class="c1">FROM employees WHERE last_name</span></p><p class="c0"><span class="c1">IN (&#39;Banda&#39;,&#39;Greene&#39;,&#39;Hintz&#39;);</span></p><p class="c0"><span class="c1">LAST_NAME SALARY</span></p><p class="c0"><span class="c1">------------- ----------</span></p><p class="c0"><span class="c1">Banda 7000</span></p><p class="c0"><span class="c1">Greene 9900</span></p><p class="c0"><span class="c1">Hintz</span></p><p class="c0"><span class="c1">SQL&gt; SELECT last_name, salary</span></p><p class="c0"><span class="c1">FROM employees WHERE last_name</span></p><p class="c0"><span class="c1">IN (&#39;Banda&#39;,&#39;Greene&#39;,&#39;Hintz&#39;);</span></p><p class="c0"><span class="c1">LAST_NAME SALARY</span></p><p class="c0"><span class="c1">------------- ----------</span></p><p class="c0"><span class="c1">Banda 7000</span></p><p class="c0"><span class="c1">Greene 9900</span></p><p class="c0"><span class="c1">Hintz</span></p><p class="c0"><span class="c1">Both sessions query the salaries for Banda,</span></p><p class="c0"><span class="c1">Greene, and Hintz. Each session sees all</span></p><p class="c0"><span class="c1">committed changes made by transaction 1</span></p><p class="c0"><span class="c1">and transaction 2.</span></p><p class="c0"><span class="c1">SQL&gt; UPDATE employees SET salary</span></p><p class="c0"><span class="c1">= 7100 WHERE last_name = &#39;Hintz&#39;;</span></p><p class="c0"><span class="c1">Session 1 begins transaction 3 by updating</span></p><p class="c0"><span class="c1">the Hintz salary. The default isolation level</span></p><p class="c0"><span class="c1">for transaction 3 is READ COMMITTED.</span></p><p class="c0"><span class="c1">SQL&gt; SET TRANSACTION ISOLATION</span></p><p class="c0"><span class="c1">LEVEL SERIALIZABLE;</span></p><p class="c0"><span class="c1">Session 2 begins transaction 4 and sets it to</span></p><p class="c0"><span class="c1">the SERIALIZABLE isolation level.</span></p><p class="c0"><span class="c1">SQL&gt; UPDATE employees SET salary =</span></p><p class="c0"><span class="c1">7200 WHERE last_name = &#39;Hintz&#39;;</span></p><p class="c0"><span class="c1">-- prompt does not return</span></p><p class="c0"><span class="c1">Transaction 4 attempts to update the salary</span></p><p class="c0"><span class="c1">for Hintz, but is blocked because</span></p><p class="c0"><span class="c1">transaction 3 locked the Hintz row (see</span></p><p class="c0"><span class="c1">&quot;Row Locks (TX)&quot; on page 9-18).</span></p><p class="c0"><span class="c1">Transaction 4 queues behind transaction 3.</span></p><p class="c0"><span class="c1">SQL&gt; COMMIT; Transaction 3 commits its update of the</span></p><p class="c0"><span class="c1">Hintz salary, ending the transaction.</span></p><p class="c0"><span class="c1">UPDATE employees SET salary = 7200</span></p><p class="c0"><span class="c1">WHERE last_name = &#39;Hintz&#39;</span></p><p class="c0"><span class="c1">*</span></p><p class="c0"><span class="c1">ERROR at line 1:</span></p><p class="c0"><span class="c1">ORA-08177: can&#39;t serialize access</span></p><p class="c0"><span class="c1">for this transaction</span></p><p class="c0"><span class="c1">The commit that ends transaction 3 causes</span></p><p class="c0"><span class="c1">the Hintz update in transaction 4 to fail</span></p><p class="c0"><span class="c1">with the ORA-08177 error. The problem</span></p><p class="c0"><span class="c1">error occurs because transaction 3</span></p><p class="c0"><span class="c1">committed the Hintz update after</span></p><p class="c0"><span class="c1">transaction 4 began.</span></p><p class="c0"><span class="c1">SQL&gt; ROLLBACK; Session 2 rolls back transaction 4, which</span></p><p class="c0"><span class="c1">ends the transaction.</span></p><p class="c0"><span class="c1">SQL&gt; SET TRANSACTION ISOLATION</span></p><p class="c0"><span class="c1">LEVEL SERIALIZABLE;</span></p><p class="c0"><span class="c1">Session 2 begins transaction 5 and sets it to</span></p><p class="c0"><span class="c1">the SERIALIZABLE isolation level.</span></p><p class="c0"><span class="c1">Table 9&ndash;3 (Cont.) Serializable Transaction</span></p><p class="c0"><span class="c1">Session 1 Session 2 ExplanationOverview of the Oracle Database Locking Mechanism</span></p><p class="c0"><span class="c1">Data Concurrency and Consistency 9-11</span></p><p class="c0"><span class="c1">Read-Only Isolation Level</span></p><p class="c0"><span class="c1">The read-only isolation level is similar to the serializable isolation level, but read-only</span></p><p class="c0"><span class="c1">transactions do not permit data to be modified in the transaction unless the user is SYS.</span></p><p class="c0"><span class="c1">Thus, read-only transactions are not susceptible to the ORA-08177 error. Read-only</span></p><p class="c0"><span class="c1">transactions are useful for generating reports in which the contents must be consistent</span></p><p class="c0"><span class="c1">with respect to the time when the transaction began.</span></p><p class="c0"><span class="c1">Oracle Database achieves read consistency by reconstructing data as needed from the</span></p><p class="c0"><span class="c1">undo segments. Because undo segments are used in a circular fashion, the database</span></p><p class="c0"><span class="c1">can overwrite undo data. Long-running reports run the risk that undo data required</span></p><p class="c0"><span class="c1">for read consistency may have been reused by a different transaction, raising a</span></p><p class="c0"><span class="c1">snapshot too old error. Setting an undo retention period, which is the minimum</span></p><p class="c0"><span class="c1">amount of time that the database attempts to retain old undo data before overwriting</span></p><p class="c0"><span class="c1">it, appropriately avoids this problem.</span></p><p class="c0"><span class="c1">Overview of the Oracle Database Locking Mechanism</span></p><p class="c0"><span class="c1">A lock is a mechanism that prevents destructive interactions, which are interactions</span></p><p class="c0"><span class="c1">that incorrectly update data or incorrectly alter underlying data structures, between</span></p><p class="c0"><span class="c1">transactions accessing shared data. Locks play a crucial role in maintaining database</span></p><p class="c0"><span class="c1">concurrency and consistency.</span></p><p class="c0"><span class="c1">SQL&gt; SELECT last_name, salary</span></p><p class="c0"><span class="c1">FROM employees WHERE last_name</span></p><p class="c0"><span class="c1">IN (&#39;Banda&#39;,&#39;Greene&#39;,&#39;Hintz&#39;);</span></p><p class="c0"><span class="c1">LAST_NAME SALARY</span></p><p class="c0"><span class="c1">------------- ----------</span></p><p class="c0"><span class="c1">Banda 7100</span></p><p class="c0"><span class="c1">Greene 9500</span></p><p class="c0"><span class="c1">Hintz 7100</span></p><p class="c0"><span class="c1">Transaction 5 queries the salaries for</span></p><p class="c0"><span class="c1">Banda, Greene, and Hintz. The Hintz salary</span></p><p class="c0"><span class="c1">update committed by transaction 3 is</span></p><p class="c0"><span class="c1">visible.</span></p><p class="c0"><span class="c1">SQL&gt; UPDATE employees SET salary =</span></p><p class="c0"><span class="c1">7200 WHERE last_name = &#39;Hintz&#39;;</span></p><p class="c0"><span class="c1">1 row updated.</span></p><p class="c0"><span class="c1">Transaction 5 updates the Hintz salary to a</span></p><p class="c0"><span class="c1">different value. Because the Hintz update</span></p><p class="c0"><span class="c1">made by transaction 3 committed before the</span></p><p class="c0"><span class="c1">start of transaction 5, the serialized access</span></p><p class="c0"><span class="c1">problem is avoided.</span></p><p class="c0"><span class="c1">Note: If a different transaction updated and</span></p><p class="c0"><span class="c1">committed the Hintz row after transaction</span></p><p class="c0"><span class="c1">transaction 5 began, then the serialized</span></p><p class="c0"><span class="c1">access problem would occur again.</span></p><p class="c0"><span class="c1">SQL&gt; COMMIT; Session 2 commits the update without any</span></p><p class="c0"><span class="c1">problems, ending the transaction.</span></p><p class="c0"><span class="c1">See Also: &quot;Overview of Transaction Control&quot; on page 10-6</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Undo Segments&quot; on page 12-24</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn how to set the undo</span></p><p class="c0"><span class="c1">retention period</span></p><p class="c0"><span class="c1">Table 9&ndash;3 (Cont.) Serializable Transaction</span></p><p class="c0"><span class="c1">Session 1 Session 2 ExplanationOverview of the Oracle Database Locking Mechanism</span></p><p class="c0"><span class="c1">9-12 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Summary of Locking Behavior</span></p><p class="c0"><span class="c1">The database maintains several different types of locks, depending on the operation</span></p><p class="c0"><span class="c1">that acquired the lock. In general, the database uses two types of locks: exclusive locks</span></p><p class="c0"><span class="c1">and share locks. Only one exclusive lock can be obtained on a resource such as a row</span></p><p class="c0"><span class="c1">or a table, but many share locks can be obtained on a single resource.</span></p><p class="c0"><span class="c1">Locks affect the interaction of readers and writers. A reader is a query of a resource,</span></p><p class="c0"><span class="c1">whereas a writer is a statement modifying a resource. The following rules summarize</span></p><p class="c0"><span class="c1">the locking behavior of Oracle Database for readers and writers:</span></p><p class="c0"><span class="c1">&#9632; A row is locked only when modified by a writer.</span></p><p class="c0"><span class="c1">When a statement updates one row, the transaction acquires a lock for this row</span></p><p class="c0"><span class="c1">only. By locking table data at the row level, the database minimizes contention for</span></p><p class="c0"><span class="c1">the same data. Under normal circumstances1 the database does not escalate a row</span></p><p class="c0"><span class="c1">lock to the block or table level.</span></p><p class="c0"><span class="c1">&#9632; A writer of a row blocks a concurrent writer of the same row.</span></p><p class="c0"><span class="c1">If one transaction is modifying a row, then a row lock prevents a different</span></p><p class="c0"><span class="c1">transaction from modifying the same row simultaneously.</span></p><p class="c0"><span class="c1">&#9632; A reader never blocks a writer.</span></p><p class="c0"><span class="c1">Because a reader of a row does not lock it, a writer can modify this row. The only</span></p><p class="c0"><span class="c1">exception is a SELECT ... FOR UPDATE statement, which is a special type of SELECT</span></p><p class="c0"><span class="c1">statement that does lock the row that it is reading.</span></p><p class="c0"><span class="c1">&#9632; A writer never blocks a reader.</span></p><p class="c0"><span class="c1">When a row is being changed by a writer, the database uses undo data data to</span></p><p class="c0"><span class="c1">provide readers with a consistent view of the row.</span></p><p class="c0"><span class="c1">Use of Locks</span></p><p class="c0"><span class="c1">In a single-user database, locks are not necessary because only one user is modifying</span></p><p class="c0"><span class="c1">information. However, when multiple users are accessing and modifying data, the</span></p><p class="c0"><span class="c1">database must provide a way to prevent concurrent modification of the same data.</span></p><p class="c0"><span class="c1">Locks achieve the following important database requirements:</span></p><p class="c0"><span class="c1">&#9632; Consistency</span></p><p class="c0"><span class="c1">The data a session is viewing or changing must not be changed by other sessions</span></p><p class="c0"><span class="c1">until the user is finished.</span></p><p class="c0"><span class="c1">1 When processing a distributed two-phase commit, the database may briefly prevent read</span></p><p class="c0"><span class="c1">access in special circumstances. Specifically, if a query starts between the prepare and commit</span></p><p class="c0"><span class="c1">phases and attempts to read the data before the commit, then the database may escalate a lock</span></p><p class="c0"><span class="c1">from row-level to block-level to guarantee read consistency.</span></p><p class="c0"><span class="c1">Note: Readers of data may have to wait for writers of the same data</span></p><p class="c0"><span class="c1">blocks in very special cases of pending distributed transactions.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database SQL Language Reference to learn about SELECT ...</span></p><p class="c0"><span class="c1">FOR UPDATE</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn about waits</span></p><p class="c0"><span class="c1">associated with in-doubt distributed transactionsOverview of the Oracle Database Locking Mechanism</span></p><p class="c0"><span class="c1">Data Concurrency and Consistency 9-13</span></p><p class="c0"><span class="c1">&#9632; Integrity</span></p><p class="c0"><span class="c1">The data and structures must reflect all changes made to them in the correct</span></p><p class="c0"><span class="c1">sequence.</span></p><p class="c0"><span class="c1">Oracle Database provides data concurrency, consistency, and integrity among</span></p><p class="c0"><span class="c1">transactions through its locking mechanisms. Locking is performed automatically and</span></p><p class="c0"><span class="c1">requires no user action.</span></p><p class="c0"><span class="c1">The need for locks can be illustrated by a concurrent update of a single row. In the</span></p><p class="c0"><span class="c1">following example, a simple web-based application presents the end user with an</span></p><p class="c0"><span class="c1">employee email and phone number. The application uses an UPDATE statement such as</span></p><p class="c0"><span class="c1">the following to modify the data:</span></p><p class="c0"><span class="c1">UPDATE employees</span></p><p class="c0"><span class="c1">SET email = ?, phone_number = ?</span></p><p class="c0"><span class="c1">WHERE employee_id = ?</span></p><p class="c0"><span class="c1">AND email = ?</span></p><p class="c0"><span class="c1">AND phone_number = ?</span></p><p class="c0"><span class="c1">In the preceding UPDATE statement, the email and phone number values in the WHERE</span></p><p class="c0"><span class="c1">clause are the original, unmodified values for the specified employee. This update</span></p><p class="c0"><span class="c1">ensures that the row that the application modifies was not changed after the</span></p><p class="c0"><span class="c1">application last read and displayed it to the user. In this way, the application avoids</span></p><p class="c0"><span class="c1">the lost update database problem in which one user overwrites changes made by</span></p><p class="c0"><span class="c1">another user, effectively losing the update by the second user (Table 9&ndash;2 on page 9-7</span></p><p class="c0"><span class="c1">shows an example of a lost update).</span></p><p class="c0"><span class="c1">Table 9&ndash;4 shows the sequence of events when two sessions attempt to modify the same</span></p><p class="c0"><span class="c1">row in the employees table at roughly the same time.</span></p><p class="c0"><span class="c1">Table 9&ndash;4 Row Locking Example</span></p><p class="c0"><span class="c1">Time Session 1 Session 2 Explanation</span></p><p class="c0"><span class="c1">t0 SELECT employee_id, email,</span></p><p class="c0"><span class="c1">phone_number</span></p><p class="c0"><span class="c1">FROM hr.employees</span></p><p class="c0"><span class="c1">WHERE last_name = &#39;Himuro&#39;;</span></p><p class="c0"><span class="c1">EMPLOYEE_ID EMAIL PHONE_NUMBER</span></p><p class="c0"><span class="c1">----------- ------- ------------</span></p><p class="c0"><span class="c1">118 GHIMURO 515.127.4565</span></p><p class="c0"><span class="c1">In session 1, the hr1 user queries</span></p><p class="c0"><span class="c1">hr.employees for the Himuro record</span></p><p class="c0"><span class="c1">and displays the employee_id (118),</span></p><p class="c0"><span class="c1">email (GHIMURO), and phone number</span></p><p class="c0"><span class="c1">(515.127.4565) attributes.</span></p><p class="c0"><span class="c1">t1 SELECT employee_id, email,</span></p><p class="c0"><span class="c1">phone_number</span></p><p class="c0"><span class="c1">FROM hr.employees</span></p><p class="c0"><span class="c1">WHERE last_name = &#39;Himuro&#39;;</span></p><p class="c0"><span class="c1">EMPLOYEE_ID EMAIL PHONE_NUMBER</span></p><p class="c0"><span class="c1">----------- ------- ------------</span></p><p class="c0"><span class="c1">118 GHIMURO 515.127.4565</span></p><p class="c0"><span class="c1">In session 2, the hr2 user queries</span></p><p class="c0"><span class="c1">hr.employees for the Himuro record</span></p><p class="c0"><span class="c1">and displays the employee_id (118),</span></p><p class="c0"><span class="c1">email (GHIMURO), and phone number</span></p><p class="c0"><span class="c1">(515.127.4565) attributes.</span></p><p class="c0"><span class="c1">t2 UPDATE hr.employees</span></p><p class="c0"><span class="c1">SET phone_number=&#39;515.555.1234&#39;</span></p><p class="c0"><span class="c1">WHERE employee_id=118</span></p><p class="c0"><span class="c1">AND email=&#39;GHIMURO&#39;</span></p><p class="c0"><span class="c1">AND phone_number=&#39;515.127.4565&#39;;</span></p><p class="c0"><span class="c1">1 row updated.</span></p><p class="c0"><span class="c1">In session 1, the hr1 user updates the</span></p><p class="c0"><span class="c1">phone number in the row to</span></p><p class="c0"><span class="c1">515.555.1234, which acquires a lock on</span></p><p class="c0"><span class="c1">the GHIMURO row.Overview of the Oracle Database Locking Mechanism</span></p><p class="c0"><span class="c1">9-14 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Oracle Database automatically obtains necessary locks when executing SQL</span></p><p class="c0"><span class="c1">statements. For example, before the database permits a session to modify data, the</span></p><p class="c0"><span class="c1">t3 UPDATE hr.employees</span></p><p class="c0"><span class="c1">SET phone_number=&#39;515.555.1235&#39;</span></p><p class="c0"><span class="c1">WHERE employee_id=118</span></p><p class="c0"><span class="c1">AND email=&#39;GHIMURO&#39;</span></p><p class="c0"><span class="c1">AND phone_number=&#39;515.127.4565&#39;;</span></p><p class="c0"><span class="c1">-- SQL*Plus does not show</span></p><p class="c0"><span class="c1">-- a row updated message or</span></p><p class="c0"><span class="c1">-- return the prompt.</span></p><p class="c0"><span class="c1">In session 2, the hr2 user attempts to</span></p><p class="c0"><span class="c1">update the same row, but is blocked</span></p><p class="c0"><span class="c1">because hr1 is currently processing the</span></p><p class="c0"><span class="c1">row.</span></p><p class="c0"><span class="c1">The attempted update by hr2 occurs</span></p><p class="c0"><span class="c1">almost simultaneously with the hr1</span></p><p class="c0"><span class="c1">update.</span></p><p class="c0"><span class="c1">t4 COMMIT;</span></p><p class="c0"><span class="c1">Commit complete.</span></p><p class="c0"><span class="c1">In session 1, the hr1 user commits the</span></p><p class="c0"><span class="c1">transaction.</span></p><p class="c0"><span class="c1">The commit makes the change for</span></p><p class="c0"><span class="c1">Himuro permanent and unblocks</span></p><p class="c0"><span class="c1">session 2, which has been waiting.</span></p><p class="c0"><span class="c1">t5 0 rows updated. In session 2, the hr2 user discovers that</span></p><p class="c0"><span class="c1">the GHIMURO row was modified in such a</span></p><p class="c0"><span class="c1">way that it no longer matches its</span></p><p class="c0"><span class="c1">predicate.</span></p><p class="c0"><span class="c1">Because the predicates do not match,</span></p><p class="c0"><span class="c1">session 2 updates no records.</span></p><p class="c0"><span class="c1">t6 UPDATE hr.employees</span></p><p class="c0"><span class="c1">SET phone_number=&#39;515.555.1235&#39;</span></p><p class="c0"><span class="c1">WHERE employee_id=118</span></p><p class="c0"><span class="c1">AND email=&#39;GHIMURO&#39;</span></p><p class="c0"><span class="c1">AND phone_number=&#39;515.555.1234&#39;;</span></p><p class="c0"><span class="c1">1 row updated.</span></p><p class="c0"><span class="c1">In session 1, the hr1 user realizes that it</span></p><p class="c0"><span class="c1">updated the GHIMURO row with the</span></p><p class="c0"><span class="c1">wrong phone number. The user starts a</span></p><p class="c0"><span class="c1">new transaction and updates the phone</span></p><p class="c0"><span class="c1">number in the row to 515.555.1235,</span></p><p class="c0"><span class="c1">which locks the GHIMURO row.</span></p><p class="c0"><span class="c1">t7 SELECT employee_id, email,</span></p><p class="c0"><span class="c1">phone_number</span></p><p class="c0"><span class="c1">FROM hr.employees</span></p><p class="c0"><span class="c1">WHERE last_name = &#39;Himuro&#39;;</span></p><p class="c0"><span class="c1">EMPLOYEE_ID EMAIL PHONE_NUMBER</span></p><p class="c0"><span class="c1">----------- ------- ------------</span></p><p class="c0"><span class="c1">118 GHIMURO 515.555.1234</span></p><p class="c0"><span class="c1">In session 2, the hr2 user queries</span></p><p class="c0"><span class="c1">hr.employees for the Himuro record.</span></p><p class="c0"><span class="c1">The record shows the phone number</span></p><p class="c0"><span class="c1">update committed by session 1 at t4.</span></p><p class="c0"><span class="c1">Oracle Database read consistency</span></p><p class="c0"><span class="c1">ensures that session 2 does not see the</span></p><p class="c0"><span class="c1">uncommitted change made at t6.</span></p><p class="c0"><span class="c1">t8 UPDATE hr.employees</span></p><p class="c0"><span class="c1">SET phone_number=&#39;515.555.1235&#39;</span></p><p class="c0"><span class="c1">WHERE employee_id=118</span></p><p class="c0"><span class="c1">AND email=&#39;GHIMURO&#39;</span></p><p class="c0"><span class="c1">AND phone_number=&#39;515.555.1234&#39;;</span></p><p class="c0"><span class="c1">-- SQL*Plus does not show</span></p><p class="c0"><span class="c1">-- a row updated message or</span></p><p class="c0"><span class="c1">-- return the prompt.</span></p><p class="c0"><span class="c1">In session 2, the hr2 user attempts to</span></p><p class="c0"><span class="c1">update the same row, but is blocked</span></p><p class="c0"><span class="c1">because hr1 is currently processing the</span></p><p class="c0"><span class="c1">row.</span></p><p class="c0"><span class="c1">t9 ROLLBACK;</span></p><p class="c0"><span class="c1">Rollback complete.</span></p><p class="c0"><span class="c1">In session 1, the hr1 user rolls back the</span></p><p class="c0"><span class="c1">transaction, which ends it.</span></p><p class="c0"><span class="c1">t10 1 row updated. In session 2, the update of the phone</span></p><p class="c0"><span class="c1">number succeeds because the session 1</span></p><p class="c0"><span class="c1">update was rolled back. The GHIMURO</span></p><p class="c0"><span class="c1">row matches its predicate, so the update</span></p><p class="c0"><span class="c1">succeeds.</span></p><p class="c0"><span class="c1">t11 COMMIT;</span></p><p class="c0"><span class="c1">Commit complete.</span></p><p class="c0"><span class="c1">Session 2 commits the update, ending</span></p><p class="c0"><span class="c1">the transaction.</span></p><p class="c0"><span class="c1">Table 9&ndash;4 (Cont.) Row Locking Example</span></p><p class="c0"><span class="c1">Time Session 1 Session 2 ExplanationOverview of the Oracle Database Locking Mechanism</span></p><p class="c0"><span class="c1">Data Concurrency and Consistency 9-15</span></p><p class="c0"><span class="c1">session must first lock the data. The lock gives the session exclusive control over the</span></p><p class="c0"><span class="c1">data so that no other transaction can modify the locked data until the lock is released.</span></p><p class="c0"><span class="c1">Because the locking mechanisms of Oracle Database are tied closely to transaction</span></p><p class="c0"><span class="c1">control, application designers need only define transactions properly, and Oracle</span></p><p class="c0"><span class="c1">Database automatically manages locking. Users never need to lock any resource</span></p><p class="c0"><span class="c1">explicitly, although Oracle Database also enables users to lock data manually.</span></p><p class="c0"><span class="c1">The following sections explain concepts that are important for understanding how</span></p><p class="c0"><span class="c1">Oracle Database achieves data concurrency.</span></p><p class="c0"><span class="c1">Lock Modes</span></p><p class="c0"><span class="c1">Oracle Database automatically uses the lowest applicable level of restrictiveness to</span></p><p class="c0"><span class="c1">provide the highest degree of data concurrency yet also provide fail-safe data integrity.</span></p><p class="c0"><span class="c1">The less restrictive the level, the more available the data is for access by other users.</span></p><p class="c0"><span class="c1">Conversely, the more restrictive the level, the more limited other transactions are in the</span></p><p class="c0"><span class="c1">types of locks that they can acquire.</span></p><p class="c0"><span class="c1">Oracle Database uses two modes of locking in a multiuser database:</span></p><p class="c0"><span class="c1">&#9632; Exclusive lock mode</span></p><p class="c0"><span class="c1">This mode prevents the associated resource from being shared. A transaction</span></p><p class="c0"><span class="c1">obtains an exclusive lock when it modifies data. The first transaction to lock a</span></p><p class="c0"><span class="c1">resource exclusively is the only transaction that can alter the resource until the</span></p><p class="c0"><span class="c1">exclusive lock is released.</span></p><p class="c0"><span class="c1">&#9632; Share lock mode</span></p><p class="c0"><span class="c1">This mode allows the associated resource to be shared, depending on the</span></p><p class="c0"><span class="c1">operations involved. Multiple users reading data can share the data, holding share</span></p><p class="c0"><span class="c1">locks to prevent concurrent access by a writer who needs an exclusive lock.</span></p><p class="c0"><span class="c1">Several transactions can acquire share locks on the same resource.</span></p><p class="c0"><span class="c1">Assume that a transaction uses a SELECT ... FOR UPDATE statement to select a single</span></p><p class="c0"><span class="c1">table row. The transaction acquires an exclusive row lock and a row share table lock.</span></p><p class="c0"><span class="c1">The row lock allows other sessions to modify any rows other than the locked row, while</span></p><p class="c0"><span class="c1">the table lock prevents sessions from altering the structure of the table. Thus, the</span></p><p class="c0"><span class="c1">database permits as many statements as possible to execute.</span></p><p class="c0"><span class="c1">Lock Conversion and Escalation</span></p><p class="c0"><span class="c1">Oracle Database performs lock conversion as necessary. In lock conversion, the</span></p><p class="c0"><span class="c1">database automatically converts a table lock of lower restrictiveness to one of higher</span></p><p class="c0"><span class="c1">restrictiveness.</span></p><p class="c0"><span class="c1">For example, suppose a transaction issues a SELECT ... FOR UPDATE for an employee</span></p><p class="c0"><span class="c1">and later updates the locked row. In this case, the database automatically converts the</span></p><p class="c0"><span class="c1">row share table lock to a row exclusive table lock. A transaction holds exclusive row</span></p><p class="c0"><span class="c1">locks for all rows inserted, updated, or deleted within the transaction. Because row</span></p><p class="c0"><span class="c1">locks are acquired at the highest degree of restrictiveness, no lock conversion is</span></p><p class="c0"><span class="c1">required or performed.</span></p><p class="c0"><span class="c1">Lock conversion is different from lock escalation, which occurs when numerous locks</span></p><p class="c0"><span class="c1">are held at one level of granularity (for example, rows) and a database raises the locks</span></p><p class="c0"><span class="c1">to a higher level of granularity (for example, table). If a user locks many rows in a</span></p><p class="c0"><span class="c1">See Also: Oracle Database PL/SQL Packages and Types Reference to</span></p><p class="c0"><span class="c1">learn about the OWA_OPT_LOCK package, which contains subprograms</span></p><p class="c0"><span class="c1">that can help prevent lost updatesOverview of the Oracle Database Locking Mechanism</span></p><p class="c0"><span class="c1">9-16 Oracle Database Concepts</span></p><p class="c0"><span class="c1">table, then some databases automatically escalate the row locks to a single table. The</span></p><p class="c0"><span class="c1">number of locks decreases, but the restrictiveness of what is locked increases.</span></p><p class="c0"><span class="c1">Oracle Database never escalates locks. Lock escalation greatly increases the likelihood of</span></p><p class="c0"><span class="c1">deadlocks. Assume that a system is trying to escalate locks on behalf of transaction 1</span></p><p class="c0"><span class="c1">but cannot because of the locks held by transaction 2. A deadlock is created if</span></p><p class="c0"><span class="c1">transaction 2 also requires lock escalation of the same data before it can proceed.</span></p><p class="c0"><span class="c1">Lock Duration</span></p><p class="c0"><span class="c1">Oracle Database automatically releases a lock when some event occurs so that the</span></p><p class="c0"><span class="c1">transaction no longer requires the resource. In most cases, the database holds locks</span></p><p class="c0"><span class="c1">acquired by statements within a transaction for the duration of the transaction. These</span></p><p class="c0"><span class="c1">locks prevent destructive interference such as dirty reads, lost updates, and destructive</span></p><p class="c0"><span class="c1">DDL from concurrent transactions.</span></p><p class="c0"><span class="c1">Oracle Database releases all locks acquired by the statements within a transaction</span></p><p class="c0"><span class="c1">when it commits or rolls back. Oracle Database also releases locks acquired after a</span></p><p class="c0"><span class="c1">savepoint when rolling back to the savepoint. However, only transactions not waiting</span></p><p class="c0"><span class="c1">for the previously locked resources can acquire locks on the now available resources.</span></p><p class="c0"><span class="c1">Waiting transactions continue to wait until after the original transaction commits or</span></p><p class="c0"><span class="c1">rolls back completely (see Table 10&ndash;2 on page 10-9 for an example).</span></p><p class="c0"><span class="c1">Locks and Deadlocks</span></p><p class="c0"><span class="c1">A deadlock is a situation in which two or more users are waiting for data locked by</span></p><p class="c0"><span class="c1">each other. Deadlocks prevent some transactions from continuing to work.</span></p><p class="c0"><span class="c1">Oracle Database automatically detects deadlocks and resolves them by rolling back</span></p><p class="c0"><span class="c1">one statement involved in the deadlock, releasing one set of the conflicting row locks.</span></p><p class="c0"><span class="c1">The database returns a corresponding message to the transaction that undergoes</span></p><p class="c0"><span class="c1">statement-level rollback. The statement rolled back belongs to the transaction that</span></p><p class="c0"><span class="c1">detects the deadlock. Usually, the signalled transaction should be rolled back explicitly,</span></p><p class="c0"><span class="c1">but it can retry the rolled-back statement after waiting.</span></p><p class="c0"><span class="c1">Table 9&ndash;5 illustrates two transactions in a deadlock.</span></p><p class="c0"><span class="c1">Note: A table lock taken on a child table because of an unindexed</span></p><p class="c0"><span class="c1">foreign key is held for the duration of the statement, not the</span></p><p class="c0"><span class="c1">transaction. Also, as explained in &quot;Overview of User-Defined Locks&quot;</span></p><p class="c0"><span class="c1">on page 9-27, the DBMS_LOCK package enables user-defined locks to be</span></p><p class="c0"><span class="c1">released and allocated at will and even held over transaction</span></p><p class="c0"><span class="c1">boundaries.</span></p><p class="c0"><span class="c1">See Also: &quot;Rollback to Savepoint&quot; on page 10-8Overview of Automatic Locks</span></p><p class="c0"><span class="c1">Data Concurrency and Consistency 9-17</span></p><p class="c0"><span class="c1">Deadlocks most often occur when transactions explicitly override the default locking</span></p><p class="c0"><span class="c1">of Oracle Database. Because Oracle Database does not escalate locks and does not use</span></p><p class="c0"><span class="c1">read locks for queries, but does use row-level (rather than page-level) locking,</span></p><p class="c0"><span class="c1">deadlocks occur infrequently.</span></p><p class="c0"><span class="c1">Overview of Automatic Locks</span></p><p class="c0"><span class="c1">Oracle Database automatically locks a resource on behalf of a transaction to prevent</span></p><p class="c0"><span class="c1">other transactions from doing something that requires exclusive access to the same</span></p><p class="c0"><span class="c1">resource. The database automatically acquires different types of locks at different</span></p><p class="c0"><span class="c1">levels of restrictiveness depending on the resource and the operation being performed.</span></p><p class="c0"><span class="c1">Oracle Database locks are divided into the following categories.</span></p><p class="c0"><span class="c1">Table 9&ndash;5 Deadlocked Transactions</span></p><p class="c0"><span class="c1">Time Session 1 Session 2 Explanation</span></p><p class="c0"><span class="c1">t0 SQL&gt; UPDATE employees</span></p><p class="c0"><span class="c1">SET salary = salary*1.1</span></p><p class="c0"><span class="c1">WHERE employee_id = 100;</span></p><p class="c0"><span class="c1">1 row updated.</span></p><p class="c0"><span class="c1">SQL&gt; UPDATE employees</span></p><p class="c0"><span class="c1">SET salary = salary*1.1</span></p><p class="c0"><span class="c1">WHERE employee_id = 200;</span></p><p class="c0"><span class="c1">1 row updated.</span></p><p class="c0"><span class="c1">Session 1 starts transaction 1 and updates</span></p><p class="c0"><span class="c1">the salary for employee 100. Session 2 starts</span></p><p class="c0"><span class="c1">transaction 2 and updates the salary for</span></p><p class="c0"><span class="c1">employee 200. No problem exists because</span></p><p class="c0"><span class="c1">each transaction locks only the row that it</span></p><p class="c0"><span class="c1">attempts to update.</span></p><p class="c0"><span class="c1">t1 SQL&gt; UPDATE employees</span></p><p class="c0"><span class="c1">SET salary = salary*1.1</span></p><p class="c0"><span class="c1">WHERE employee_id = 200;</span></p><p class="c0"><span class="c1">-- prompt does not return</span></p><p class="c0"><span class="c1">SQL&gt; UPDATE employees</span></p><p class="c0"><span class="c1">salary = salary*1.1</span></p><p class="c0"><span class="c1">WHERE employee_id = 100;</span></p><p class="c0"><span class="c1">-- prompt does not return</span></p><p class="c0"><span class="c1">Transaction 1 attempts to update the</span></p><p class="c0"><span class="c1">employee 200 row, which is currently locked</span></p><p class="c0"><span class="c1">by transaction 2. Transaction 2 attempts to</span></p><p class="c0"><span class="c1">update the employee 100 row, which is</span></p><p class="c0"><span class="c1">currently locked by transaction 1.</span></p><p class="c0"><span class="c1">A deadlock results because neither</span></p><p class="c0"><span class="c1">transaction can obtain the resource it needs</span></p><p class="c0"><span class="c1">to proceed or terminate. No matter how long</span></p><p class="c0"><span class="c1">each transaction waits, the conflicting locks</span></p><p class="c0"><span class="c1">are held.</span></p><p class="c0"><span class="c1">t2 UPDATE employees</span></p><p class="c0"><span class="c1">*</span></p><p class="c0"><span class="c1">ERROR at line 1:</span></p><p class="c0"><span class="c1">ORA-00060: deadlock detected</span></p><p class="c0"><span class="c1">while waiting for resource</span></p><p class="c0"><span class="c1">SQL&gt;</span></p><p class="c0"><span class="c1">Transaction 1 signals the deadlock and rolls</span></p><p class="c0"><span class="c1">back the UPDATE statement issued at t1.</span></p><p class="c0"><span class="c1">However, the update made at t0 is not rolled</span></p><p class="c0"><span class="c1">back. The prompt is returned in session 1.</span></p><p class="c0"><span class="c1">Note: Only one session in the deadlock</span></p><p class="c0"><span class="c1">actually gets the deadlock error, but either</span></p><p class="c0"><span class="c1">session could get the error.</span></p><p class="c0"><span class="c1">t3 SQL&gt; COMMIT;</span></p><p class="c0"><span class="c1">Commit complete.</span></p><p class="c0"><span class="c1">Session 1 commits the update made at t0,</span></p><p class="c0"><span class="c1">ending transaction 1. The update</span></p><p class="c0"><span class="c1">unsuccessfully attempted at t1 is not</span></p><p class="c0"><span class="c1">committed.</span></p><p class="c0"><span class="c1">t4 1 row updated.</span></p><p class="c0"><span class="c1">SQL&gt;</span></p><p class="c0"><span class="c1">The update at t1 in transaction 2, which was</span></p><p class="c0"><span class="c1">being blocked by transaction 1, is executed.</span></p><p class="c0"><span class="c1">The prompt is returned.</span></p><p class="c0"><span class="c1">t5 SQL&gt; COMMIT;</span></p><p class="c0"><span class="c1">Commit complete.</span></p><p class="c0"><span class="c1">Session 2 commits the updates made at t0</span></p><p class="c0"><span class="c1">and t1, which ends transaction 2.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Overview of Manual Data Locks&quot; on page 9-26</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Advanced Application Developer&#39;s Guide to learn</span></p><p class="c0"><span class="c1">how to handle deadlocks when you lock tables explicitly</span></p><p class="c0"><span class="c1">Note: The database never locks rows when performing simple reads.Overview of Automatic Locks</span></p><p class="c0"><span class="c1">9-18 Oracle Database Concepts</span></p><p class="c0"><span class="c1">DML Locks</span></p><p class="c0"><span class="c1">A DML lock, also called a data lock, guarantees the integrity of data accessed</span></p><p class="c0"><span class="c1">concurrently by multiple users. For example, a DML lock prevents two customers</span></p><p class="c0"><span class="c1">from buying the last copy of a book available from an online bookseller. DML locks</span></p><p class="c0"><span class="c1">prevent destructive interference of simultaneous conflicting DML or DDL operations.</span></p><p class="c0"><span class="c1">DML statements automatically acquire the following types of locks:</span></p><p class="c0"><span class="c1">&#9632; Row Locks (TX)</span></p><p class="c0"><span class="c1">&#9632; Table Locks (TM)</span></p><p class="c0"><span class="c1">In the following sections, the acronym in parentheses after each type of lock or lock</span></p><p class="c0"><span class="c1">mode is the abbreviation used in the Locks Monitor of Oracle Enterprise Manager</span></p><p class="c0"><span class="c1">(Enterprise Manager). Enterprise Manager might display TM for any table lock, rather</span></p><p class="c0"><span class="c1">than indicate the mode of table lock (such as RS or SRX).</span></p><p class="c0"><span class="c1">Row Locks (TX)</span></p><p class="c0"><span class="c1">A row lock, also called a TX lock, is a lock on a single row of table. A transaction</span></p><p class="c0"><span class="c1">acquires a row lock for each row modified by an INSERT, UPDATE, DELETE, MERGE, or</span></p><p class="c0"><span class="c1">SELECT ... FOR UPDATE statement. The row lock exists until the transaction commits or</span></p><p class="c0"><span class="c1">rolls back.</span></p><p class="c0"><span class="c1">Row locks primarily serve as a queuing mechanism to prevent two transactions from</span></p><p class="c0"><span class="c1">modifying the same row. The database always locks a modified row in exclusive mode</span></p><p class="c0"><span class="c1">so that other transactions cannot modify the row until the transaction holding the lock</span></p><p class="c0"><span class="c1">commits or rolls back. Row locking provides the finest grain locking possible and so</span></p><p class="c0"><span class="c1">provides the best possible concurrency and throughput.</span></p><p class="c0"><span class="c1">If a transaction obtains a lock for a row, then the transaction also acquires a lock for the</span></p><p class="c0"><span class="c1">table containing the row. The table lock prevents conflicting DDL operations that</span></p><p class="c0"><span class="c1">would override data changes in a current transaction. Figure 9&ndash;2 illustrates an update</span></p><p class="c0"><span class="c1">of the third row in a table. Oracle Database automatically places an exclusive lock on</span></p><p class="c0"><span class="c1">the updated row and a subexclusive lock on the table.</span></p><p class="c0"><span class="c1">Lock Description</span></p><p class="c0"><span class="c1">DML Locks Protect data. For example, table locks lock entire tables, while</span></p><p class="c0"><span class="c1">row locks lock selected rows. See &quot;DML Locks&quot; on page 9-18.</span></p><p class="c0"><span class="c1">DDL Locks Protect the structure of schema objects&mdash;for example, the</span></p><p class="c0"><span class="c1">dictionary definitions of tables and views. See &quot;DDL Locks&quot; on</span></p><p class="c0"><span class="c1">page 9-24.</span></p><p class="c0"><span class="c1">System Locks Protect internal database structures such as data files. Latches,</span></p><p class="c0"><span class="c1">mutexes, and internal locks are entirely automatic. See &quot;System</span></p><p class="c0"><span class="c1">Locks&quot; on page 9-25.</span></p><p class="c0"><span class="c1">See Also: &quot;Oracle Enterprise Manager&quot; on page 18-2</span></p><p class="c0"><span class="c1">Note: If a transaction terminates because of database instance</span></p><p class="c0"><span class="c1">failure, then block-level recovery makes a row available before the</span></p><p class="c0"><span class="c1">entire transaction is recovered.Overview of Automatic Locks</span></p><p class="c0"><span class="c1">Data Concurrency and Consistency 9-19</span></p><p class="c0"><span class="c1">Figure 9&ndash;2 Row and Table Locks</span></p><p class="c0"><span class="c1">Row Locks and Concurrency Table 9&ndash;6 illustrates how Oracle Database uses row locks for</span></p><p class="c0"><span class="c1">concurrency. Three sessions query the same rows simultaneously. Session 1 and 2</span></p><p class="c0"><span class="c1">proceed to make uncommitted updates to different rows, while session 3 makes no</span></p><p class="c0"><span class="c1">updates. Each session sees its own uncommitted updates but not the uncommitted</span></p><p class="c0"><span class="c1">updates of any other session.</span></p><p class="c0"><span class="c1">Table 9&ndash;6 Data Concurrency Example</span></p><p class="c0"><span class="c1">Time Session 1 Session 2 Session 3 Explanation</span></p><p class="c0"><span class="c1">t0 SELECT employee_id,</span></p><p class="c0"><span class="c1">salary FROM employees</span></p><p class="c0"><span class="c1">WHERE employee_id</span></p><p class="c0"><span class="c1">IN ( 100, 101 );</span></p><p class="c0"><span class="c1">EMPLOYEE_ID SALARY</span></p><p class="c0"><span class="c1">----------- ------</span></p><p class="c0"><span class="c1">100 512</span></p><p class="c0"><span class="c1">101 600</span></p><p class="c0"><span class="c1">SELECT employee_id,</span></p><p class="c0"><span class="c1">salary FROM employees</span></p><p class="c0"><span class="c1">WHERE employee_id</span></p><p class="c0"><span class="c1">IN ( 100, 101 );</span></p><p class="c0"><span class="c1">EMPLOYEE_ID SALARY</span></p><p class="c0"><span class="c1">----------- ------</span></p><p class="c0"><span class="c1">100 512</span></p><p class="c0"><span class="c1">101 600</span></p><p class="c0"><span class="c1">SELECT employee_id,</span></p><p class="c0"><span class="c1">salary FROM employees</span></p><p class="c0"><span class="c1">WHERE employee_id</span></p><p class="c0"><span class="c1">IN ( 100, 101 );</span></p><p class="c0"><span class="c1">EMPLOYEE_ID SALARY</span></p><p class="c0"><span class="c1">----------- ------</span></p><p class="c0"><span class="c1">100 512</span></p><p class="c0"><span class="c1">101 600</span></p><p class="c0"><span class="c1">Three different sessions</span></p><p class="c0"><span class="c1">simultaneously query the ID and</span></p><p class="c0"><span class="c1">salary of employees 100 and 101.</span></p><p class="c0"><span class="c1">The results returned by each</span></p><p class="c0"><span class="c1">query are identical.</span></p><p class="c0"><span class="c1">t1 UPDATE hr.employees</span></p><p class="c0"><span class="c1">SET salary=salary+100</span></p><p class="c0"><span class="c1">WHERE employee_id=100;</span></p><p class="c0"><span class="c1">Session 1 updates the salary of</span></p><p class="c0"><span class="c1">employee 100, but does not</span></p><p class="c0"><span class="c1">commit. In the update, the writer</span></p><p class="c0"><span class="c1">acquires a row-level lock for the</span></p><p class="c0"><span class="c1">updated row only, thereby</span></p><p class="c0"><span class="c1">preventing other writers from</span></p><p class="c0"><span class="c1">modifying this row.</span></p><p class="c0"><span class="c1">EMPLOYEE_ID</span></p><p class="c0"><span class="c1">Table EMPLOYEES</span></p><p class="c0"><span class="c1">Exclusive row lock (TX) acquired</span></p><p class="c0"><span class="c1">Row being updated</span></p><p class="c0"><span class="c1">Table lock acquired</span></p><p class="c0"><span class="c1">LAST_NAME EMAIL HIRE_DATE JOB_ID MANAGER_ID DEPARTMENT_ID</span></p><p class="c0"><span class="c1">100</span></p><p class="c0"><span class="c1">101</span></p><p class="c0"><span class="c1">102</span></p><p class="c0"><span class="c1">103</span></p><p class="c0"><span class="c1">King</span></p><p class="c0"><span class="c1">Kochhar</span></p><p class="c0"><span class="c1">De Hann</span></p><p class="c0"><span class="c1">Hunold</span></p><p class="c0"><span class="c1">SKING</span></p><p class="c0"><span class="c1">NKOCHHAR</span></p><p class="c0"><span class="c1">LDEHANN</span></p><p class="c0"><span class="c1">AHUNOLD</span></p><p class="c0"><span class="c1">17-JUN-87</span></p><p class="c0"><span class="c1">21-SEP-89</span></p><p class="c0"><span class="c1">13-JAN-93</span></p><p class="c0"><span class="c1">03-JAN-90</span></p><p class="c0"><span class="c1">AD_PRES</span></p><p class="c0"><span class="c1">AD_VP</span></p><p class="c0"><span class="c1">AD_VP</span></p><p class="c0"><span class="c1">IT_PROG</span></p><p class="c0"><span class="c1">100</span></p><p class="c0"><span class="c1">100</span></p><p class="c0"><span class="c1">102</span></p><p class="c0"><span class="c1">90</span></p><p class="c0"><span class="c1">90</span></p><p class="c0"><span class="c1">90</span></p><p class="c0"><span class="c1">60Overview of Automatic Locks</span></p><p class="c0"><span class="c1">9-20 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Storage of Row Locks Unlike some databases, which use a lock manager to maintain a</span></p><p class="c0"><span class="c1">list of locks in memory, Oracle Database stores lock information in the data block that</span></p><p class="c0"><span class="c1">contains the locked row.</span></p><p class="c0"><span class="c1">The database uses a queuing mechanism for acquisition of row locks. If a transaction</span></p><p class="c0"><span class="c1">requires a lock for an unlocked row, then the transaction places a lock in the data</span></p><p class="c0"><span class="c1">block. Each row modified by this transaction points to a copy of the transaction ID</span></p><p class="c0"><span class="c1">stored in the block header (see &quot;Overview of Data Blocks&quot; on page 12-6).</span></p><p class="c0"><span class="c1">When a transaction ends, the transaction ID remains in the block header. If a different</span></p><p class="c0"><span class="c1">transaction wants to modify a row, then it uses the transaction ID to determine</span></p><p class="c0"><span class="c1">whether the lock is active. If the lock is active, then the session asks to be notified</span></p><p class="c0"><span class="c1">when the lock is released. Otherwise, the transaction acquires the lock.</span></p><p class="c0"><span class="c1">Table Locks (TM)</span></p><p class="c0"><span class="c1">A table lock, also called a TM lock, is acquired by a transaction when a table is</span></p><p class="c0"><span class="c1">modified by an INSERT, UPDATE, DELETE, MERGE, SELECT with the FOR UPDATE clause, or</span></p><p class="c0"><span class="c1">LOCK TABLE statement. DML operations require table locks to reserve DML access to</span></p><p class="c0"><span class="c1">the table on behalf of a transaction and to prevent DDL operations that would conflict</span></p><p class="c0"><span class="c1">with the transaction.</span></p><p class="c0"><span class="c1">t2 SELECT employee_id,</span></p><p class="c0"><span class="c1">salary FROM employees</span></p><p class="c0"><span class="c1">WHERE employee_id</span></p><p class="c0"><span class="c1">IN ( 100, 101 );</span></p><p class="c0"><span class="c1">EMPLOYEE_ID SALARY</span></p><p class="c0"><span class="c1">----------- ------</span></p><p class="c0"><span class="c1">100 612</span></p><p class="c0"><span class="c1">101 600</span></p><p class="c0"><span class="c1">SELECT employee_id,</span></p><p class="c0"><span class="c1">salary FROM employees</span></p><p class="c0"><span class="c1">WHERE employee_id</span></p><p class="c0"><span class="c1">IN ( 100, 101 );</span></p><p class="c0"><span class="c1">EMPLOYEE_ID SALARY</span></p><p class="c0"><span class="c1">----------- ------</span></p><p class="c0"><span class="c1">100 512</span></p><p class="c0"><span class="c1">101 600</span></p><p class="c0"><span class="c1">SELECT employee_id,</span></p><p class="c0"><span class="c1">salary FROM employees</span></p><p class="c0"><span class="c1">WHERE employee_id</span></p><p class="c0"><span class="c1">IN ( 100, 101 );</span></p><p class="c0"><span class="c1">EMPLOYEE_ID SALARY</span></p><p class="c0"><span class="c1">----------- ------</span></p><p class="c0"><span class="c1">100 512</span></p><p class="c0"><span class="c1">101 600</span></p><p class="c0"><span class="c1">Each session simultaneously</span></p><p class="c0"><span class="c1">issues the original query. Session</span></p><p class="c0"><span class="c1">1 shows the salary of 612</span></p><p class="c0"><span class="c1">resulting from the t1 update. The</span></p><p class="c0"><span class="c1">readers in session 2 and 3 return</span></p><p class="c0"><span class="c1">rows immediately and do not</span></p><p class="c0"><span class="c1">wait for session 1 to end its</span></p><p class="c0"><span class="c1">transaction. The database uses</span></p><p class="c0"><span class="c1">multiversion read consistency to</span></p><p class="c0"><span class="c1">show the salary as it existed</span></p><p class="c0"><span class="c1">before the update in session 1.</span></p><p class="c0"><span class="c1">t3 UPDATE hr.employees</span></p><p class="c0"><span class="c1">SET salary=salary+100</span></p><p class="c0"><span class="c1">WHERE employee_id=101;</span></p><p class="c0"><span class="c1">Session 2 updates the salary of</span></p><p class="c0"><span class="c1">employee 101, but does not</span></p><p class="c0"><span class="c1">commit the transaction. In the</span></p><p class="c0"><span class="c1">update, the writer acquires a</span></p><p class="c0"><span class="c1">row-level lock for the updated</span></p><p class="c0"><span class="c1">row only, preventing other</span></p><p class="c0"><span class="c1">writers from modifying this row.</span></p><p class="c0"><span class="c1">t4 SELECT employee_id,</span></p><p class="c0"><span class="c1">salary FROM employees</span></p><p class="c0"><span class="c1">WHERE employee_id</span></p><p class="c0"><span class="c1">IN ( 100, 101 );</span></p><p class="c0"><span class="c1">EMPLOYEE_ID SALARY</span></p><p class="c0"><span class="c1">----------- ------</span></p><p class="c0"><span class="c1">100 612</span></p><p class="c0"><span class="c1">101 600</span></p><p class="c0"><span class="c1">SELECT employee_id,</span></p><p class="c0"><span class="c1">salaryFROM employees</span></p><p class="c0"><span class="c1">WHERE employee_id</span></p><p class="c0"><span class="c1">IN ( 100, 101 );</span></p><p class="c0"><span class="c1">EMPLOYEE_ID SALARY</span></p><p class="c0"><span class="c1">----------- ------</span></p><p class="c0"><span class="c1">100 512</span></p><p class="c0"><span class="c1">101 700</span></p><p class="c0"><span class="c1">SELECT employee_id,</span></p><p class="c0"><span class="c1">salary FROM employees</span></p><p class="c0"><span class="c1">WHERE employee_id</span></p><p class="c0"><span class="c1">IN ( 100, 101 );</span></p><p class="c0"><span class="c1">EMPLOYEE_ID SALARY</span></p><p class="c0"><span class="c1">----------- ------</span></p><p class="c0"><span class="c1">100 512</span></p><p class="c0"><span class="c1">101 600</span></p><p class="c0"><span class="c1">Each session simultaneously</span></p><p class="c0"><span class="c1">issues the original query. Session</span></p><p class="c0"><span class="c1">1 shows the salary of 612</span></p><p class="c0"><span class="c1">resulting from the t1 update, but</span></p><p class="c0"><span class="c1">not the salary update for</span></p><p class="c0"><span class="c1">employee 101 made in session 2.</span></p><p class="c0"><span class="c1">The reader in session 2 shows the</span></p><p class="c0"><span class="c1">salary update made in session 2,</span></p><p class="c0"><span class="c1">but not the salary update made in</span></p><p class="c0"><span class="c1">session 1. The reader in session 3</span></p><p class="c0"><span class="c1">uses read consistency to show the</span></p><p class="c0"><span class="c1">salaries before modification by</span></p><p class="c0"><span class="c1">session 1 and 2.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database SQL Language Reference</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Reference to learn about V$LOCK</span></p><p class="c0"><span class="c1">See Also: Oracle Database Reference to learn about V$TRANSACTION</span></p><p class="c0"><span class="c1">Table 9&ndash;6 (Cont.) Data Concurrency Example</span></p><p class="c0"><span class="c1">Time Session 1 Session 2 Session 3 ExplanationOverview of Automatic Locks</span></p><p class="c0"><span class="c1">Data Concurrency and Consistency 9-21</span></p><p class="c0"><span class="c1">A table lock can be held in any of the following modes:</span></p><p class="c0"><span class="c1">&#9632; Row Share (RS)</span></p><p class="c0"><span class="c1">This lock, also called a subshare table lock (SS), indicates that the transaction</span></p><p class="c0"><span class="c1">holding the lock on the table has locked rows in the table and intends to update</span></p><p class="c0"><span class="c1">them. A row share lock is the least restrictive mode of table lock, offering the</span></p><p class="c0"><span class="c1">highest degree of concurrency for a table.</span></p><p class="c0"><span class="c1">&#9632; Row Exclusive Table Lock (RX)</span></p><p class="c0"><span class="c1">This lock, also called a subexclusive table lock (SX), generally indicates that the</span></p><p class="c0"><span class="c1">transaction holding the lock has updated table rows or issued SELECT ... FOR</span></p><p class="c0"><span class="c1">UPDATE. An SX lock allows other transactions to query, insert, update, delete, or</span></p><p class="c0"><span class="c1">lock rows concurrently in the same table. Therefore, SX locks allow multiple</span></p><p class="c0"><span class="c1">transactions to obtain simultaneous SX and subshare table locks for the same table.</span></p><p class="c0"><span class="c1">&#9632; Share Table Lock (S)</span></p><p class="c0"><span class="c1">A share table lock held by a transaction allows other transactions to query the</span></p><p class="c0"><span class="c1">table (without using SELECT ... FOR UPDATE), but updates are allowed only if a</span></p><p class="c0"><span class="c1">single transaction holds the share table lock. Because multiple transactions may</span></p><p class="c0"><span class="c1">hold a share table lock concurrently, holding this lock is not sufficient to ensure</span></p><p class="c0"><span class="c1">that a transaction can modify the table.</span></p><p class="c0"><span class="c1">&#9632; Share Row Exclusive Table Lock (SRX)</span></p><p class="c0"><span class="c1">This lock, also called a share-subexclusive table lock (SSX), is more restrictive</span></p><p class="c0"><span class="c1">than a share table lock. Only one transaction at a time can acquire an SSX lock on a</span></p><p class="c0"><span class="c1">given table. An SSX lock held by a transaction allows other transactions to query</span></p><p class="c0"><span class="c1">the table (except for SELECT ... FOR UPDATE) but not to update the table.</span></p><p class="c0"><span class="c1">&#9632; Exclusive Table Lock (X)</span></p><p class="c0"><span class="c1">This lock is the most restrictive, prohibiting other transactions from performing</span></p><p class="c0"><span class="c1">any type of DML statement or placing any type of lock on the table.</span></p><p class="c0"><span class="c1">Locks and Foreign Keys</span></p><p class="c0"><span class="c1">Oracle Database maximizes the concurrency control of parent keys in relation to</span></p><p class="c0"><span class="c1">dependent foreign keys. In heap-organized tables, locking behavior depends on the</span></p><p class="c0"><span class="c1">indexing of foreign key columns. If foreign keys are not indexed, then the child table</span></p><p class="c0"><span class="c1">will probably be locked more frequently, deadlocks will occur, and concurrency will be</span></p><p class="c0"><span class="c1">decreased. For this reason, Oracle recommends indexing foreign keys in most cases</span></p><p class="c0"><span class="c1">except when the matching unique or primary key is never updated or deleted.</span></p><p class="c0"><span class="c1">Locks and Unindexed Foreign Keys When both of the following conditions are true, the</span></p><p class="c0"><span class="c1">database acquires a full table lock on the child table:</span></p><p class="c0"><span class="c1">&#9632; No index exists on the foreign key column of the child table.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database SQL Language Reference</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Advanced Application Developer&#39;s Guide to learn</span></p><p class="c0"><span class="c1">more about table locks</span></p><p class="c0"><span class="c1">Note: Additional considerations apply to non-heap data structures</span></p><p class="c0"><span class="c1">such as index-organized tables and table clusters.Overview of Automatic Locks</span></p><p class="c0"><span class="c1">9-22 Oracle Database Concepts</span></p><p class="c0"><span class="c1">&#9632; A session modifies a primary key in the parent table (for example, deletes a row or</span></p><p class="c0"><span class="c1">modifies primary key attributes) or merges rows into the parent table. Inserts into</span></p><p class="c0"><span class="c1">the parent table do not acquire table locks on the child table.</span></p><p class="c0"><span class="c1">Suppose that hr.departments table is a parent of hr.employees, which contains</span></p><p class="c0"><span class="c1">the unindexed foreign key department_id. Figure 9&ndash;3 shows a session modifying</span></p><p class="c0"><span class="c1">the primary key attributes of department 60 in the departments table.</span></p><p class="c0"><span class="c1">Figure 9&ndash;3 Locking Mechanisms with Unindexed Foreign Key</span></p><p class="c0"><span class="c1">In Figure 9&ndash;3, the database acquires a full table lock on employees during the primary</span></p><p class="c0"><span class="c1">key modification of department 60. This lock enables other sessions to query but not</span></p><p class="c0"><span class="c1">update the employees table. For example, employee phone numbers cannot be</span></p><p class="c0"><span class="c1">updated. The table lock on employees releases immediately after the primary key</span></p><p class="c0"><span class="c1">modification on the departments table completes. If multiple rows in departments</span></p><p class="c0"><span class="c1">undergo primary key modifications, then a table lock on employees is obtained and</span></p><p class="c0"><span class="c1">released once for each row that is modified in departments.</span></p><p class="c0"><span class="c1">Note: DML on a child table does not acquire a table lock on the</span></p><p class="c0"><span class="c1">parent table.</span></p><p class="c0"><span class="c1">Unindexed</span></p><p class="c0"><span class="c1">Foreign Key</span></p><p class="c0"><span class="c1">(values in dependent</span></p><p class="c0"><span class="c1">table must match a</span></p><p class="c0"><span class="c1">value in unique key</span></p><p class="c0"><span class="c1">or primary key of</span></p><p class="c0"><span class="c1">referenced table)</span></p><p class="c0"><span class="c1">DEPARTMENT_ID DEPARTMENT_NAME MANAGER_ID</span></p><p class="c0"><span class="c1">60</span></p><p class="c0"><span class="c1">90</span></p><p class="c0"><span class="c1">IT</span></p><p class="c0"><span class="c1">Executive</span></p><p class="c0"><span class="c1">103</span></p><p class="c0"><span class="c1">100</span></p><p class="c0"><span class="c1">LOCATION_ID</span></p><p class="c0"><span class="c1">1400</span></p><p class="c0"><span class="c1">1700</span></p><p class="c0"><span class="c1">Parent Key</span></p><p class="c0"><span class="c1">Primary key of</span></p><p class="c0"><span class="c1">referenced table</span></p><p class="c0"><span class="c1">EMPLOYEE_ID</span></p><p class="c0"><span class="c1">Table EMPLOYEES</span></p><p class="c0"><span class="c1">Exclusive row lock (TX) acquired</span></p><p class="c0"><span class="c1">Primary key modified</span></p><p class="c0"><span class="c1">Full table lock acquired</span></p><p class="c0"><span class="c1">LAST_NAME EMAIL HIRE_DATE JOB_ID MANAGER_ID DEPARTMENT_ID</span></p><p class="c0"><span class="c1">100</span></p><p class="c0"><span class="c1">101</span></p><p class="c0"><span class="c1">102</span></p><p class="c0"><span class="c1">103</span></p><p class="c0"><span class="c1">King</span></p><p class="c0"><span class="c1">Kochhar</span></p><p class="c0"><span class="c1">De Hann</span></p><p class="c0"><span class="c1">Hunold</span></p><p class="c0"><span class="c1">SKING</span></p><p class="c0"><span class="c1">NKOCHHAR</span></p><p class="c0"><span class="c1">LDEHANN</span></p><p class="c0"><span class="c1">AHUNOLD</span></p><p class="c0"><span class="c1">17-JUN-87</span></p><p class="c0"><span class="c1">21-SEP-89</span></p><p class="c0"><span class="c1">13-JAN-93</span></p><p class="c0"><span class="c1">03-JAN-90</span></p><p class="c0"><span class="c1">AD_PRES</span></p><p class="c0"><span class="c1">AD_VP</span></p><p class="c0"><span class="c1">AD_VP</span></p><p class="c0"><span class="c1">IT_PROG</span></p><p class="c0"><span class="c1">100</span></p><p class="c0"><span class="c1">100</span></p><p class="c0"><span class="c1">102</span></p><p class="c0"><span class="c1">90</span></p><p class="c0"><span class="c1">90</span></p><p class="c0"><span class="c1">90</span></p><p class="c0"><span class="c1">60</span></p><p class="c0"><span class="c1">Dependent or Child Table</span></p><p class="c0"><span class="c1">Table DEPARTMENTS</span></p><p class="c0"><span class="c1">Referenced or Parent Table</span></p><p class="c0"><span class="c1">10,rowid</span></p><p class="c0"><span class="c1">20,rowid</span></p><p class="c0"><span class="c1">. . . .</span></p><p class="c0"><span class="c1">60,rowid</span></p><p class="c0"><span class="c1">Index Leaf BlockOverview of Automatic Locks</span></p><p class="c0"><span class="c1">Data Concurrency and Consistency 9-23</span></p><p class="c0"><span class="c1">Locks and Indexed Foreign Keys When both of the following conditions are true, the</span></p><p class="c0"><span class="c1">database does not acquire a full table lock on the child table:</span></p><p class="c0"><span class="c1">&#9632; A foreign key column in the child table is indexed.</span></p><p class="c0"><span class="c1">&#9632; A session modifies a primary key in the parent table (for example, deletes a row or</span></p><p class="c0"><span class="c1">modifies primary key attributes) or merges rows into the parent table.</span></p><p class="c0"><span class="c1">A lock on the parent table prevents transactions from acquiring exclusive table locks,</span></p><p class="c0"><span class="c1">but does not prevent DML on the parent or child table during the primary key</span></p><p class="c0"><span class="c1">modification. This situation is preferable if primary key modifications occur on the</span></p><p class="c0"><span class="c1">parent table while updates occur on the child table.</span></p><p class="c0"><span class="c1">Figure 9&ndash;4 shows child table employees with an indexed department_id column. A</span></p><p class="c0"><span class="c1">transaction deletes department 280 from departments. This deletion does not cause the</span></p><p class="c0"><span class="c1">database to acquire a full table lock on the employees table as in the scenario described</span></p><p class="c0"><span class="c1">in &quot;Locks and Unindexed Foreign Keys&quot; on page 9-21.</span></p><p class="c0"><span class="c1">Figure 9&ndash;4 Locking Mechanisms with Indexed Foreign Key</span></p><p class="c0"><span class="c1">If the child table specifies ON DELETE CASCADE, then deletions from the parent table can</span></p><p class="c0"><span class="c1">result in deletions from the child table. For example, the deletion of department 280</span></p><p class="c0"><span class="c1">can cause the deletion of records from employees for employees in the deleted</span></p><p class="c0"><span class="c1">Indexed</span></p><p class="c0"><span class="c1">Foreign Key</span></p><p class="c0"><span class="c1">(values in dependent</span></p><p class="c0"><span class="c1">table must match a</span></p><p class="c0"><span class="c1">value in unique key</span></p><p class="c0"><span class="c1">or primary key of</span></p><p class="c0"><span class="c1">referenced table)</span></p><p class="c0"><span class="c1">DEPARTMENT_ID DEPARTMENT_NAME MANAGER_ID</span></p><p class="c0"><span class="c1">60</span></p><p class="c0"><span class="c1">90</span></p><p class="c0"><span class="c1">IT 103</span></p><p class="c0"><span class="c1">100</span></p><p class="c0"><span class="c1">LOCATION_ID</span></p><p class="c0"><span class="c1">1400</span></p><p class="c0"><span class="c1">1700</span></p><p class="c0"><span class="c1">280</span></p><p class="c0"><span class="c1">Executive</span></p><p class="c0"><span class="c1">Event Planning 1700</span></p><p class="c0"><span class="c1">Parent Key</span></p><p class="c0"><span class="c1">Primary key of</span></p><p class="c0"><span class="c1">referenced table</span></p><p class="c0"><span class="c1">EMPLOYEE_ID</span></p><p class="c0"><span class="c1">Table EMPLOYEES</span></p><p class="c0"><span class="c1">Exclusive row lock (TX) acquired</span></p><p class="c0"><span class="c1">Row being deleted</span></p><p class="c0"><span class="c1">Full table lock acquired</span></p><p class="c0"><span class="c1">LAST_NAME EMAIL HIRE_DATE JOB_ID MANAGER_ID DEPARTMENT_ID</span></p><p class="c0"><span class="c1">100</span></p><p class="c0"><span class="c1">101</span></p><p class="c0"><span class="c1">102</span></p><p class="c0"><span class="c1">103</span></p><p class="c0"><span class="c1">King</span></p><p class="c0"><span class="c1">Kochhar</span></p><p class="c0"><span class="c1">De Hann</span></p><p class="c0"><span class="c1">Hunold</span></p><p class="c0"><span class="c1">SKING</span></p><p class="c0"><span class="c1">NKOCHHAR</span></p><p class="c0"><span class="c1">LDEHANN</span></p><p class="c0"><span class="c1">AHUNOLD</span></p><p class="c0"><span class="c1">17-JUN-87</span></p><p class="c0"><span class="c1">21-SEP-89</span></p><p class="c0"><span class="c1">13-JAN-93</span></p><p class="c0"><span class="c1">03-JAN-90</span></p><p class="c0"><span class="c1">AD_PRES</span></p><p class="c0"><span class="c1">AD_VP</span></p><p class="c0"><span class="c1">AD_VP</span></p><p class="c0"><span class="c1">IT_PROG</span></p><p class="c0"><span class="c1">100</span></p><p class="c0"><span class="c1">100</span></p><p class="c0"><span class="c1">102</span></p><p class="c0"><span class="c1">90</span></p><p class="c0"><span class="c1">90</span></p><p class="c0"><span class="c1">90</span></p><p class="c0"><span class="c1">60</span></p><p class="c0"><span class="c1">Dependent or Child Table</span></p><p class="c0"><span class="c1">Table DEPARTMENTS</span></p><p class="c0"><span class="c1">Referenced or Parent Table</span></p><p class="c0"><span class="c1">10,rowid</span></p><p class="c0"><span class="c1">20,rowid</span></p><p class="c0"><span class="c1">. . . .</span></p><p class="c0"><span class="c1">280,rowid</span></p><p class="c0"><span class="c1">Index Leaf BlockOverview of Automatic Locks</span></p><p class="c0"><span class="c1">9-24 Oracle Database Concepts</span></p><p class="c0"><span class="c1">department. In this case, waiting and locking rules are the same as if you deleted rows</span></p><p class="c0"><span class="c1">from the child table after deleting rows from the parent table.</span></p><p class="c0"><span class="c1">DDL Locks</span></p><p class="c0"><span class="c1">A data dictionary (DDL) lock protects the definition of a schema object while an</span></p><p class="c0"><span class="c1">ongoing DDL operation acts on or refers to the object. Only individual schema objects</span></p><p class="c0"><span class="c1">that are modified or referenced are locked during DDL operations. The database never</span></p><p class="c0"><span class="c1">locks the whole data dictionary.</span></p><p class="c0"><span class="c1">Oracle Database acquires a DDL lock automatically on behalf of any DDL transaction</span></p><p class="c0"><span class="c1">requiring it. Users cannot explicitly request DDL locks. For example, if a user creates a</span></p><p class="c0"><span class="c1">stored procedure, then Oracle Database automatically acquires DDL locks for all</span></p><p class="c0"><span class="c1">schema objects referenced in the procedure definition. The DDL locks prevent these</span></p><p class="c0"><span class="c1">objects from being altered or dropped before procedure compilation is complete.</span></p><p class="c0"><span class="c1">Exclusive DDL Locks</span></p><p class="c0"><span class="c1">An exclusive DDL lock prevents other sessions from obtaining a DDL or DML lock.</span></p><p class="c0"><span class="c1">Most DDL operations, except for those described in &quot;Share DDL Locks&quot; on page 9-24,</span></p><p class="c0"><span class="c1">require exclusive DDL locks for a resource to prevent destructive interference with</span></p><p class="c0"><span class="c1">other DDL operations that might modify or reference the same schema object. For</span></p><p class="c0"><span class="c1">example, DROP TABLE is not allowed to drop a table while ALTER TABLE is adding a</span></p><p class="c0"><span class="c1">column to it, and vice versa.</span></p><p class="c0"><span class="c1">Exclusive DDL locks last for the duration of DDL statement execution and automatic</span></p><p class="c0"><span class="c1">commit. During the acquisition of an exclusive DDL lock, if another DDL lock is held</span></p><p class="c0"><span class="c1">on the schema object by another operation, then the acquisition waits until the older</span></p><p class="c0"><span class="c1">DDL lock is released and then proceeds.</span></p><p class="c0"><span class="c1">Share DDL Locks</span></p><p class="c0"><span class="c1">A share DDL lock for a resource prevents destructive interference with conflicting</span></p><p class="c0"><span class="c1">DDL operations, but allows data concurrency for similar DDL operations.</span></p><p class="c0"><span class="c1">For example, when a CREATE PROCEDURE statement is run, the containing transaction</span></p><p class="c0"><span class="c1">acquires share DDL locks for all referenced tables. Other transactions can concurrently</span></p><p class="c0"><span class="c1">create procedures that reference the same tables and acquire concurrent share DDL</span></p><p class="c0"><span class="c1">locks on the same tables, but no transaction can acquire an exclusive DDL lock on any</span></p><p class="c0"><span class="c1">referenced table.</span></p><p class="c0"><span class="c1">A share DDL lock lasts for the duration of DDL statement execution and automatic</span></p><p class="c0"><span class="c1">commit. Thus, a transaction holding a share DDL lock is guaranteed that the definition</span></p><p class="c0"><span class="c1">of the referenced schema object remains constant during the transaction.</span></p><p class="c0"><span class="c1">Breakable Parse Locks</span></p><p class="c0"><span class="c1">A parse lock is held by a SQL statement or PL/SQL program unit for each schema</span></p><p class="c0"><span class="c1">object that it references. Parse locks are acquired so that the associated shared SQL</span></p><p class="c0"><span class="c1">area can be invalidated if a referenced object is altered or dropped. A parse lock is</span></p><p class="c0"><span class="c1">called a breakable parse lock because it does not disallow any DDL operation and can</span></p><p class="c0"><span class="c1">be broken to allow conflicting DDL operations.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Foreign Key Constraints&quot; on page 5-6</span></p><p class="c0"><span class="c1">&#9632; &quot;Overview of Indexes&quot; on page 3-1Overview of Automatic Locks</span></p><p class="c0"><span class="c1">Data Concurrency and Consistency 9-25</span></p><p class="c0"><span class="c1">A parse lock is acquired in the shared pool during the parse phase of SQL statement</span></p><p class="c0"><span class="c1">execution. The lock is held as long as the shared SQL area for that statement remains in</span></p><p class="c0"><span class="c1">the shared pool.</span></p><p class="c0"><span class="c1">System Locks</span></p><p class="c0"><span class="c1">Oracle Database uses various types of system locks to protect internal database and</span></p><p class="c0"><span class="c1">memory structures. These mechanisms are inaccessible to users because users have no</span></p><p class="c0"><span class="c1">control over their occurrence or duration.</span></p><p class="c0"><span class="c1">Latches</span></p><p class="c0"><span class="c1">Latches are simple, low-level serialization mechanisms that coordinate multiuser</span></p><p class="c0"><span class="c1">access to shared data structures, objects, and files. Latches protect shared memory</span></p><p class="c0"><span class="c1">resources from corruption when accessed by multiple processes. Specifically, latches</span></p><p class="c0"><span class="c1">protect data structures from the following situations:</span></p><p class="c0"><span class="c1">&#9632; Concurrent modification by multiple sessions</span></p><p class="c0"><span class="c1">&#9632; Being read by one session while being modified by another session</span></p><p class="c0"><span class="c1">&#9632; Deallocation (aging out) of memory while being accessed</span></p><p class="c0"><span class="c1">Typically, a single latch protects multiple objects in the SGA. For example, background</span></p><p class="c0"><span class="c1">processes such as DBWn and LGWR allocate memory from the shared pool to create</span></p><p class="c0"><span class="c1">data structures. To allocate this memory, these processes use a shared pool latch that</span></p><p class="c0"><span class="c1">serializes access to prevent two processes from trying to inspect or modify the shared</span></p><p class="c0"><span class="c1">pool simultaneously. After the memory is allocated, other processes may need to</span></p><p class="c0"><span class="c1">access shared pool areas such as the library cache, which is required for parsing. In</span></p><p class="c0"><span class="c1">this case, processes latch only the library cache, not the entire shared pool.</span></p><p class="c0"><span class="c1">Unlike enqueue latches such as row locks, latches do not permit sessions to queue.</span></p><p class="c0"><span class="c1">When a latch becomes available, the first session to request the latch obtains exclusive</span></p><p class="c0"><span class="c1">access to it. Latch spinning occurs when a process repeatedly requests a latch in a</span></p><p class="c0"><span class="c1">loop, whereas latch sleeping occurs when a process releases the CPU before renewing</span></p><p class="c0"><span class="c1">the latch request.</span></p><p class="c0"><span class="c1">Typically, an Oracle process acquires a latch for an extremely short time while</span></p><p class="c0"><span class="c1">manipulating or looking at a data structure. For example, while processing a salary</span></p><p class="c0"><span class="c1">update of a single employee, the database may obtain and release thousands of</span></p><p class="c0"><span class="c1">latches. The implementation of latches is operating system-dependent, especially in</span></p><p class="c0"><span class="c1">respect to whether and how long a process waits for a latch.</span></p><p class="c0"><span class="c1">An increase in latching means a decrease in concurrency. For example, excessive hard</span></p><p class="c0"><span class="c1">parse operations create contention for the library cache latch. The V$LATCH view</span></p><p class="c0"><span class="c1">contains detailed latch usage statistics for each latch, including the number of times</span></p><p class="c0"><span class="c1">each latch was requested and waited for.</span></p><p class="c0"><span class="c1">See Also: &quot;Shared Pool&quot; on page 14-15</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;SQL Parsing&quot; on page 7-16</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Reference to learn about V$LATCH</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Performance Tuning Guide to learn about wait event</span></p><p class="c0"><span class="c1">statisticsOverview of Manual Data Locks</span></p><p class="c0"><span class="c1">9-26 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Mutexes</span></p><p class="c0"><span class="c1">A mutual exclusion object (mutex) is a low-level mechanism that prevents an object in</span></p><p class="c0"><span class="c1">memory from aging out or from being corrupted when accessed by concurrent</span></p><p class="c0"><span class="c1">processes. A mutex is similar to a latch, but whereas a latch typically protects a group</span></p><p class="c0"><span class="c1">of objects, a mutex protects a single object.</span></p><p class="c0"><span class="c1">Mutexes provide several benefits:</span></p><p class="c0"><span class="c1">&#9632; A mutex can reduce the possibility of contention.</span></p><p class="c0"><span class="c1">Because a latch protects multiple objects, it can become a bottleneck when</span></p><p class="c0"><span class="c1">processes attempt to access any of these objects concurrently. By serializing access</span></p><p class="c0"><span class="c1">to an individual object rather than a group, a mutex increases availability.</span></p><p class="c0"><span class="c1">&#9632; A mutex consumes less memory than a latch.</span></p><p class="c0"><span class="c1">&#9632; When in shared mode, a mutex permits concurrent reference by multiple sessions.</span></p><p class="c0"><span class="c1">Internal Locks</span></p><p class="c0"><span class="c1">Internal locks are higher-level, more complex mechanisms than latches and mutexes</span></p><p class="c0"><span class="c1">and serve various purposes. The database uses the following types of internal locks:</span></p><p class="c0"><span class="c1">&#9632; Dictionary cache locks</span></p><p class="c0"><span class="c1">These locks are of very short duration and are held on entries in dictionary caches</span></p><p class="c0"><span class="c1">while the entries are being modified or used. They guarantee that statements being</span></p><p class="c0"><span class="c1">parsed do not see inconsistent object definitions. Dictionary cache locks can be</span></p><p class="c0"><span class="c1">shared or exclusive. Shared locks are released when the parse is complete, whereas</span></p><p class="c0"><span class="c1">exclusive locks are released when the DDL operation is complete.</span></p><p class="c0"><span class="c1">&#9632; File and log management locks</span></p><p class="c0"><span class="c1">These locks protect various files. For example, an internal lock protects the control</span></p><p class="c0"><span class="c1">file so that only one process at a time can change it. Another lock coordinates the</span></p><p class="c0"><span class="c1">use and archiving of the online redo log files. Data files are locked to ensure that</span></p><p class="c0"><span class="c1">multiple instances mount a database in shared mode or that one instance mounts</span></p><p class="c0"><span class="c1">it in exclusive mode. Because file and log locks indicate the status of files, these</span></p><p class="c0"><span class="c1">locks are necessarily held for a long time.</span></p><p class="c0"><span class="c1">&#9632; Tablespace and undo segment locks</span></p><p class="c0"><span class="c1">These locks protect tablespaces and undo segments. For example, all instances</span></p><p class="c0"><span class="c1">accessing a database must agree on whether a tablespace is online or offline. Undo</span></p><p class="c0"><span class="c1">segments are locked so that only one database instance can write to a segment.</span></p><p class="c0"><span class="c1">Overview of Manual Data Locks</span></p><p class="c0"><span class="c1">Oracle Database performs locking automatically to ensure data concurrency, data</span></p><p class="c0"><span class="c1">integrity, and statement-level read consistency. However, you can manually override</span></p><p class="c0"><span class="c1">the Oracle Database default locking mechanisms. Overriding the default locking is</span></p><p class="c0"><span class="c1">useful in situations such as the following:</span></p><p class="c0"><span class="c1">&#9632; Applications require transaction-level read consistency or repeatable reads.</span></p><p class="c0"><span class="c1">In this case, queries must produce consistent data for the duration of the</span></p><p class="c0"><span class="c1">transaction, not reflecting changes by other transactions. You can achieve</span></p><p class="c0"><span class="c1">transaction-level read consistency by using explicit locking, read-only transactions,</span></p><p class="c0"><span class="c1">serializable transactions, or by overriding default locking.</span></p><p class="c0"><span class="c1">See Also: &quot;Data Dictionary Cache&quot; on page 14-19Overview of User-Defined Locks</span></p><p class="c0"><span class="c1">Data Concurrency and Consistency 9-27</span></p><p class="c0"><span class="c1">&#9632; Applications require that a transaction have exclusive access to a resource so that</span></p><p class="c0"><span class="c1">the transaction does not have to wait for other transactions to complete.</span></p><p class="c0"><span class="c1">You can override Oracle Database automatic locking at the session or transaction level.</span></p><p class="c0"><span class="c1">At the session level, a session can set the required transaction isolation level with the</span></p><p class="c0"><span class="c1">ALTER SESSION statement. At the transaction level, transactions that include the</span></p><p class="c0"><span class="c1">following SQL statements override Oracle Database default locking:</span></p><p class="c0"><span class="c1">&#9632; The SET TRANSACTION ISOLATION LEVEL statement</span></p><p class="c0"><span class="c1">&#9632; The LOCK TABLE statement (which locks either a table or, when used with views,</span></p><p class="c0"><span class="c1">the base tables)</span></p><p class="c0"><span class="c1">&#9632; The SELECT ... FOR UPDATE statement</span></p><p class="c0"><span class="c1">Locks acquired by the preceding statements are released after the transaction ends or a</span></p><p class="c0"><span class="c1">rollback to savepoint releases them.</span></p><p class="c0"><span class="c1">If Oracle Database default locking is overridden at any level, then the database</span></p><p class="c0"><span class="c1">administrator or application developer should ensure that the overriding locking</span></p><p class="c0"><span class="c1">procedures operate correctly. The locking procedures must satisfy the following</span></p><p class="c0"><span class="c1">criteria: data integrity is guaranteed, data concurrency is acceptable, and deadlocks are</span></p><p class="c0"><span class="c1">not possible or are appropriately handled.</span></p><p class="c0"><span class="c1">Overview of User-Defined Locks</span></p><p class="c0"><span class="c1">With Oracle Database Lock Management services, you can define your own locks for a</span></p><p class="c0"><span class="c1">specific application. For example, you might create a lock to serialize access to a</span></p><p class="c0"><span class="c1">message log on the file system. Because a reserved user lock is the same as an Oracle</span></p><p class="c0"><span class="c1">Database lock, it has all the Oracle Database lock functionality including deadlock</span></p><p class="c0"><span class="c1">detection. User locks never conflict with Oracle Database locks, because they are</span></p><p class="c0"><span class="c1">identified with the prefix UL.</span></p><p class="c0"><span class="c1">The Oracle Database Lock Management services are available through procedures in</span></p><p class="c0"><span class="c1">the DBMS_LOCK package. You can include statements in PL/SQL blocks that:</span></p><p class="c0"><span class="c1">&#9632; Request a lock of a specific type</span></p><p class="c0"><span class="c1">&#9632; Give the lock a unique name recognizable in another procedure in the same or in</span></p><p class="c0"><span class="c1">another instance</span></p><p class="c0"><span class="c1">&#9632; Change the lock type</span></p><p class="c0"><span class="c1">&#9632; Release the lock</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database SQL Language Reference for descriptions of LOCK</span></p><p class="c0"><span class="c1">TABLE and SELECT ... FOR UPDATE</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Advanced Application Developer&#39;s Guide to learn</span></p><p class="c0"><span class="c1">how to manually lock tables</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Advanced Application Developer&#39;s Guide for more</span></p><p class="c0"><span class="c1">information about Oracle Database Lock Management services</span></p><p class="c0"><span class="c1">&#9632; Oracle Database PL/SQL Packages and Types Reference for</span></p><p class="c0"><span class="c1">information about DBMS_LOCKOverview of User-Defined Locks</span></p><p class="c0"><span class="c1">9-28 Oracle Database Concepts10</span></p><p class="c0"><span class="c1">Transactions 10-1</span></p><p class="c0"><span class="c1">Transactions 0 1</span></p><p class="c0"><span class="c1">This chapter defines a transaction and describes how the database processes</span></p><p class="c0"><span class="c1">transactions.</span></p><p class="c0"><span class="c1">This chapter contains the following sections:</span></p><p class="c0"><span class="c1">&#9632; Introduction to Transactions</span></p><p class="c0"><span class="c1">&#9632; Overview of Transaction Control</span></p><p class="c0"><span class="c1">&#9632; Overview of Autonomous Transactions</span></p><p class="c0"><span class="c1">&#9632; Overview of Distributed Transactions</span></p><p class="c0"><span class="c1">Introduction to Transactions</span></p><p class="c0"><span class="c1">A transaction is a logical, atomic unit of work that contains one or more SQL</span></p><p class="c0"><span class="c1">statements. A transaction groups SQL statements so that they are either all committed,</span></p><p class="c0"><span class="c1">which means they are applied to the database, or all rolled back, which means they</span></p><p class="c0"><span class="c1">are undone from the database. Oracle Database assigns every transaction a unique</span></p><p class="c0"><span class="c1">identifier called a transaction ID.</span></p><p class="c0"><span class="c1">All Oracle transactions comply with the basic properties of a database transaction,</span></p><p class="c0"><span class="c1">known as ACID properties. ACID is an acronym for the following:</span></p><p class="c0"><span class="c1">&#9632; Atomicity</span></p><p class="c0"><span class="c1">All tasks of a transaction are performed or none of them are. There are no partial</span></p><p class="c0"><span class="c1">transactions. For example, if a transaction starts updating 100 rows, but the system</span></p><p class="c0"><span class="c1">fails after 20 updates, then the database rolls back the changes to these 20 rows.</span></p><p class="c0"><span class="c1">&#9632; Consistency</span></p><p class="c0"><span class="c1">The transaction takes the database from one consistent state to another consistent</span></p><p class="c0"><span class="c1">state. For example, in a banking transaction that debits a savings account and</span></p><p class="c0"><span class="c1">credits a checking account, a failure must not cause the database to credit only one</span></p><p class="c0"><span class="c1">account, which would lead to inconsistent data.</span></p><p class="c0"><span class="c1">&#9632; Isolation</span></p><p class="c0"><span class="c1">The effect of a transaction is not visible to other transactions until the transaction is</span></p><p class="c0"><span class="c1">committed. For example, one user updating the hr.employees table does not see</span></p><p class="c0"><span class="c1">the uncommitted changes to employees made concurrently by another user. Thus,</span></p><p class="c0"><span class="c1">it appears to users as if transactions are executing serially.</span></p><p class="c0"><span class="c1">&#9632; DurabilityIntroduction to Transactions</span></p><p class="c0"><span class="c1">10-2 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Changes made by committed transactions are permanent. After a transaction</span></p><p class="c0"><span class="c1">completes, the database ensures through its recovery mechanisms that changes</span></p><p class="c0"><span class="c1">from the transaction are not lost.</span></p><p class="c0"><span class="c1">The use of transactions is one of the most important ways that a database management</span></p><p class="c0"><span class="c1">system differs from a file system.</span></p><p class="c0"><span class="c1">Sample Transaction: Account Debit and Credit</span></p><p class="c0"><span class="c1">To illustrate the concept of a transaction, consider a banking database. When a</span></p><p class="c0"><span class="c1">customer transfers money from a savings account to a checking account, the</span></p><p class="c0"><span class="c1">transaction must consist of three separate operations:</span></p><p class="c0"><span class="c1">&#9632; Decrement the savings account</span></p><p class="c0"><span class="c1">&#9632; Increment the checking account</span></p><p class="c0"><span class="c1">&#9632; Record the transaction in the transaction journal</span></p><p class="c0"><span class="c1">Oracle Database must allow for two situations. If all three SQL statements maintain</span></p><p class="c0"><span class="c1">the accounts in proper balance, then the effects of the transaction can be applied to the</span></p><p class="c0"><span class="c1">database. However, if a problem such as insufficient funds, invalid account number, or</span></p><p class="c0"><span class="c1">a hardware failure prevents one or two of the statements in the transaction from</span></p><p class="c0"><span class="c1">completing, then the database must roll back the entire transaction so that the balance</span></p><p class="c0"><span class="c1">of all accounts is correct.</span></p><p class="c0"><span class="c1">Figure 10&ndash;1 illustrates a banking transaction. The first statement subtracts $500 from</span></p><p class="c0"><span class="c1">savings account 3209. The second statement adds $500 to checking account 3208. The</span></p><p class="c0"><span class="c1">third statement inserts a record of the transfer into the journal table. The final</span></p><p class="c0"><span class="c1">statement commits the transaction.</span></p><p class="c0"><span class="c1">Figure 10&ndash;1 A Banking Transaction</span></p><p class="c0"><span class="c1">Structure of a Transaction</span></p><p class="c0"><span class="c1">A database transaction consists of one or more statements. Specifically, a transaction</span></p><p class="c0"><span class="c1">consists of one of the following:</span></p><p class="c0"><span class="c1">Transaction</span></p><p class="c0"><span class="c1">Begins</span></p><p class="c0"><span class="c1">Transaction</span></p><p class="c0"><span class="c1">Ends</span></p><p class="c0"><span class="c1">UPDATE savings_accounts</span></p><p class="c0"><span class="c1">SET balance = balance - 500</span></p><p class="c0"><span class="c1">WHERE account = 3209;</span></p><p class="c0"><span class="c1">UPDATE checking_accounts</span></p><p class="c0"><span class="c1">SET balance = balance + 500</span></p><p class="c0"><span class="c1">WHERE account = 3208;</span></p><p class="c0"><span class="c1">INSERT INTO journal VALUES</span></p><p class="c0"><span class="c1">(journal_seq.NEXTVAL, &#39;1B&#39;</span></p><p class="c0"><span class="c1">3209, 3208, 500);</span></p><p class="c0"><span class="c1">COMMIT WORK;</span></p><p class="c0"><span class="c1">Decrement</span></p><p class="c0"><span class="c1">Savings</span></p><p class="c0"><span class="c1">Account</span></p><p class="c0"><span class="c1">Increment</span></p><p class="c0"><span class="c1">Checking</span></p><p class="c0"><span class="c1">Account</span></p><p class="c0"><span class="c1">Record in</span></p><p class="c0"><span class="c1">Transaction</span></p><p class="c0"><span class="c1">Journal</span></p><p class="c0"><span class="c1">End</span></p><p class="c0"><span class="c1">TransactionIntroduction to Transactions</span></p><p class="c0"><span class="c1">Transactions 10-3</span></p><p class="c0"><span class="c1">&#9632; One or more data manipulation language (DML) statements that together</span></p><p class="c0"><span class="c1">constitute an atomic change to the database</span></p><p class="c0"><span class="c1">&#9632; One data definition language (DDL) statement</span></p><p class="c0"><span class="c1">A transaction has a beginning and an end.</span></p><p class="c0"><span class="c1">Beginning of a Transaction</span></p><p class="c0"><span class="c1">A transaction begins when the first executable SQL statement is encountered. An</span></p><p class="c0"><span class="c1">executable SQL statement is a SQL statement that generates calls to a database</span></p><p class="c0"><span class="c1">instance, including DML and DDL statements and the SET TRANSACTION statement.</span></p><p class="c0"><span class="c1">When a transaction begins, Oracle Database assigns the transaction to an available</span></p><p class="c0"><span class="c1">undo data segment to record the undo entries for the new transaction. A transaction</span></p><p class="c0"><span class="c1">ID is not allocated until an undo segment and transaction table slot are allocated,</span></p><p class="c0"><span class="c1">which occurs during the first DML statement. A transaction ID is unique to a</span></p><p class="c0"><span class="c1">transaction and represents the undo segment number, slot, and sequence number.</span></p><p class="c0"><span class="c1">The following example execute an UPDATE statement to begin a transaction and queries</span></p><p class="c0"><span class="c1">V$TRANSACTION for details about the transaction:</span></p><p class="c0"><span class="c1">SQL&gt; UPDATE hr.employees SET salary=salary;</span></p><p class="c0"><span class="c1">107 rows updated.</span></p><p class="c0"><span class="c1">SQL&gt; SELECT XID AS &quot;txn id&quot;, XIDUSN AS &quot;undo seg&quot;, XIDSLOT AS &quot;slot&quot;,</span></p><p class="c0"><span class="c1">2 XIDSQN AS &quot;seq&quot;, STATUS AS &quot;txn status&quot;</span></p><p class="c0"><span class="c1">3 FROM V$TRANSACTION;</span></p><p class="c0"><span class="c1">txn id undo seg slot seq txn status</span></p><p class="c0"><span class="c1">---------------- ---------- ---------- ---------- ----------------</span></p><p class="c0"><span class="c1">0600060037000000 6 6 55 ACTIVE</span></p><p class="c0"><span class="c1">End of a Transaction</span></p><p class="c0"><span class="c1">A transaction ends when any of the following actions occurs:</span></p><p class="c0"><span class="c1">&#9632; A user issues a COMMIT or ROLLBACK statement without a SAVEPOINT clause.</span></p><p class="c0"><span class="c1">In a commit, a user explicitly or implicitly requested that the changes in the</span></p><p class="c0"><span class="c1">transaction be made permanent. Changes made by the transaction are permanent</span></p><p class="c0"><span class="c1">and visible to other users only after a transaction commits. The transaction shown</span></p><p class="c0"><span class="c1">in Figure 10&ndash;1 ends with a commit.</span></p><p class="c0"><span class="c1">&#9632; A user runs a DDL command such as CREATE, DROP, RENAME, or ALTER.</span></p><p class="c0"><span class="c1">The database issues an implicit COMMIT statement before and after every DDL</span></p><p class="c0"><span class="c1">statement. If the current transaction contains DML statements, then Oracle</span></p><p class="c0"><span class="c1">Database first commits the transaction and then runs and commits the DDL</span></p><p class="c0"><span class="c1">statement as a new, single-statement transaction.</span></p><p class="c0"><span class="c1">&#9632; A user exits normally from most Oracle Database utilities and tools, causing the</span></p><p class="c0"><span class="c1">current transaction to be implicitly committed. The commit behavior when a user</span></p><p class="c0"><span class="c1">disconnects is application-dependent and configurable.</span></p><p class="c0"><span class="c1">See Also: &quot;Overview of SQL Statements&quot; on page 7-3</span></p><p class="c0"><span class="c1">See Also: &quot;Undo Segments&quot; on page 12-24Introduction to Transactions</span></p><p class="c0"><span class="c1">10-4 Oracle Database Concepts</span></p><p class="c0"><span class="c1">&#9632; A client process terminates abnormally, causing the transaction to be implicitly</span></p><p class="c0"><span class="c1">rolled back using metadata stored in the transaction table and the undo segment.</span></p><p class="c0"><span class="c1">After one transaction ends, the next executable SQL statement automatically starts the</span></p><p class="c0"><span class="c1">following transaction. The following example executes an UPDATE to start a transaction,</span></p><p class="c0"><span class="c1">ends the transaction with a ROLLBACK statement, and then executes an UPDATE to start a</span></p><p class="c0"><span class="c1">new transaction (note that the transaction IDs are different):</span></p><p class="c0"><span class="c1">SQL&gt; UPDATE hr.employees SET salary=salary;</span></p><p class="c0"><span class="c1">107 rows updated.</span></p><p class="c0"><span class="c1">SQL&gt; SELECT XID, STATUS FROM V$TRANSACTION;</span></p><p class="c0"><span class="c1">XID STATUS</span></p><p class="c0"><span class="c1">---------------- ----------------</span></p><p class="c0"><span class="c1">0800090033000000 ACTIVE</span></p><p class="c0"><span class="c1">SQL&gt; ROLLBACK;</span></p><p class="c0"><span class="c1">Rollback complete.</span></p><p class="c0"><span class="c1">SQL&gt; SELECT XID FROM V$TRANSACTION;</span></p><p class="c0"><span class="c1">no rows selected</span></p><p class="c0"><span class="c1">SQL&gt; UPDATE hr.employees SET last_name=last_name;</span></p><p class="c0"><span class="c1">107 rows updated.</span></p><p class="c0"><span class="c1">SQL&gt; SELECT XID, STATUS FROM V$TRANSACTION;</span></p><p class="c0"><span class="c1">XID STATUS</span></p><p class="c0"><span class="c1">---------------- ----------------</span></p><p class="c0"><span class="c1">0900050033000000 ACTIVE</span></p><p class="c0"><span class="c1">Statement-Level Atomicity</span></p><p class="c0"><span class="c1">Oracle Database supports statement-level atomicity, which means that a SQL</span></p><p class="c0"><span class="c1">statement is an atomic unit of work and either completely succeeds or completely fails.</span></p><p class="c0"><span class="c1">A successful statement is different from a committed transaction. A single SQL</span></p><p class="c0"><span class="c1">statement executes successfully if the database parses and runs it without error as an</span></p><p class="c0"><span class="c1">atomic unit, as when all rows are changed in a multirow update.</span></p><p class="c0"><span class="c1">If a SQL statement causes an error during execution, then it is not successful and so all</span></p><p class="c0"><span class="c1">effects of the statement are rolled back. This operation is a statement-level rollback.</span></p><p class="c0"><span class="c1">This operation has the following characteristics:</span></p><p class="c0"><span class="c1">&#9632; A SQL statement that does not succeed causes the loss only of work it would have</span></p><p class="c0"><span class="c1">performed itself.</span></p><p class="c0"><span class="c1">Note: Applications should always explicitly commit or undo</span></p><p class="c0"><span class="c1">transactions before program termination.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Tools for Database Administrators&quot; on page 18-2 and &quot;Tools for</span></p><p class="c0"><span class="c1">Database Developers&quot; on page 19-1</span></p><p class="c0"><span class="c1">&#9632; Oracle Database SQL Language Reference to learn about COMMITIntroduction to Transactions</span></p><p class="c0"><span class="c1">Transactions 10-5</span></p><p class="c0"><span class="c1">The unsuccessful statement does not cause the loss of any work that preceded it in</span></p><p class="c0"><span class="c1">the current transaction. For example, if the execution of the second UPDATE</span></p><p class="c0"><span class="c1">statement in Figure 10&ndash;1 causes an error and is rolled back, then the work</span></p><p class="c0"><span class="c1">performed by the first UPDATE statement is not rolled back. The first UPDATE</span></p><p class="c0"><span class="c1">statement can be committed or rolled back explicitly by the user.</span></p><p class="c0"><span class="c1">&#9632; The effect of the rollback is as if the statement had never been run.</span></p><p class="c0"><span class="c1">Any side effects of an atomic statement, for example, triggers invoked upon</span></p><p class="c0"><span class="c1">execution of the statement, are considered part of the atomic statement. Either all</span></p><p class="c0"><span class="c1">work generated as part of the atomic statement succeeds or none does.</span></p><p class="c0"><span class="c1">An example of an error causing a statement-level rollback is an attempt to insert a</span></p><p class="c0"><span class="c1">duplicate primary key. Single SQL statements involved in a deadlock, which is</span></p><p class="c0"><span class="c1">competition for the same data, can also cause a statement-level rollback. However,</span></p><p class="c0"><span class="c1">errors discovered during SQL statement parsing, such as a syntax error, have not yet</span></p><p class="c0"><span class="c1">been run and so do not cause a statement-level rollback.</span></p><p class="c0"><span class="c1">System Change Numbers (SCNs)</span></p><p class="c0"><span class="c1">A system change number (SCN) is a logical, internal time stamp used by Oracle</span></p><p class="c0"><span class="c1">Database. SCNs order events that occur within the database, which is necessary to</span></p><p class="c0"><span class="c1">satisfy the ACID properties of a transaction. Oracle Database uses SCNs to mark the</span></p><p class="c0"><span class="c1">SCN before which all changes are known to be on disk so that recovery avoids</span></p><p class="c0"><span class="c1">applying unnecessary redo. The database also uses SCNs to mark the point at which</span></p><p class="c0"><span class="c1">no redo exists for a set of data so that recovery can stop.</span></p><p class="c0"><span class="c1">SCNs occur in a monotonically increasing sequence. Oracle Database can use an SCN</span></p><p class="c0"><span class="c1">like a clock because an observed SCN indicates a logical point in time and repeated</span></p><p class="c0"><span class="c1">observations return equal or greater values. If one event has a lower SCN than another</span></p><p class="c0"><span class="c1">event, then it occurred at an earlier time with respect to the database. Several events</span></p><p class="c0"><span class="c1">may share the same SCN, which means that they occurred at the same time with</span></p><p class="c0"><span class="c1">respect to the database.</span></p><p class="c0"><span class="c1">Every transaction has an SCN. For example, if a transaction updates a row, then the</span></p><p class="c0"><span class="c1">database records the SCN at which this update occurred. Other modifications in this</span></p><p class="c0"><span class="c1">transaction have the same SCN. When a transaction commits, the database records an</span></p><p class="c0"><span class="c1">SCN for this commit.</span></p><p class="c0"><span class="c1">Oracle Database increments SCNs in the system global area (SGA). When a</span></p><p class="c0"><span class="c1">transaction modifies data, the database writes a new SCN to the undo data segment</span></p><p class="c0"><span class="c1">assigned to the transaction. The log writer process then writes the commit record of</span></p><p class="c0"><span class="c1">the transaction immediately to the online redo log. The commit record has the unique</span></p><p class="c0"><span class="c1">SCN of the transaction. Oracle Database also uses SCNs as part of its instance</span></p><p class="c0"><span class="c1">recovery and media recovery mechanisms.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;SQL Parsing&quot; on page 7-16</span></p><p class="c0"><span class="c1">&#9632; &quot;Locks and Deadlocks&quot; on page 9-16</span></p><p class="c0"><span class="c1">&#9632; &quot;Overview of Triggers&quot; on page 8-16</span></p><p class="c0"><span class="c1">See Also: &quot;Overview of Instance Recovery&quot; on page 13-12 and</span></p><p class="c0"><span class="c1">&quot;Backup and Recovery&quot; on page 18-9Overview of Transaction Control</span></p><p class="c0"><span class="c1">10-6 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Overview of Transaction Control</span></p><p class="c0"><span class="c1">Transaction control is the management of changes made by DML statements and the</span></p><p class="c0"><span class="c1">grouping of DML statements into transactions. In general, application designers are</span></p><p class="c0"><span class="c1">concerned with transaction control so that work is accomplished in logical units and</span></p><p class="c0"><span class="c1">data is kept consistent.</span></p><p class="c0"><span class="c1">Transaction control involves using the following statements, as described in</span></p><p class="c0"><span class="c1">&quot;Transaction Control Statements&quot; on page 7-8:</span></p><p class="c0"><span class="c1">&#9632; The COMMIT statement ends the current transaction and makes all changes</span></p><p class="c0"><span class="c1">performed in the transaction permanent. COMMIT also erases all savepoints in the</span></p><p class="c0"><span class="c1">transaction and releases transaction locks.</span></p><p class="c0"><span class="c1">&#9632; The ROLLBACK statement reverses the work done in the current transaction; it</span></p><p class="c0"><span class="c1">causes all data changes since the last COMMIT or ROLLBACK to be discarded. The</span></p><p class="c0"><span class="c1">ROLLBACK TO SAVEPOINT statement undoes the changes since the last savepoint but</span></p><p class="c0"><span class="c1">does not end the entire transaction.</span></p><p class="c0"><span class="c1">&#9632; The SAVEPOINT statement identifies a point in a transaction to which you can later</span></p><p class="c0"><span class="c1">roll back.</span></p><p class="c0"><span class="c1">The session in Table 10&ndash;1 illustrates the basic concepts of transaction control.</span></p><p class="c0"><span class="c1">Table 10&ndash;1 Transaction Control</span></p><p class="c0"><span class="c1">Time Session Explanation</span></p><p class="c0"><span class="c1">t0 COMMIT; This statement ends any existing transaction</span></p><p class="c0"><span class="c1">in the session.</span></p><p class="c0"><span class="c1">t1 SET TRANSACTION NAME &#39;sal_update&#39;; This statement begins a transaction and</span></p><p class="c0"><span class="c1">names it sal_update.</span></p><p class="c0"><span class="c1">t2 UPDATE employees</span></p><p class="c0"><span class="c1">SET salary = 7000</span></p><p class="c0"><span class="c1">WHERE last_name = &#39;Banda&#39;;</span></p><p class="c0"><span class="c1">This statement updates the salary for Banda</span></p><p class="c0"><span class="c1">to 7000.</span></p><p class="c0"><span class="c1">t3 SAVEPOINT after_banda_sal; This statement creates a savepoint named</span></p><p class="c0"><span class="c1">after_banda_sal, enabling changes in this</span></p><p class="c0"><span class="c1">transaction to be rolled back to this point.</span></p><p class="c0"><span class="c1">t4 UPDATE employees</span></p><p class="c0"><span class="c1">SET salary = 12000</span></p><p class="c0"><span class="c1">WHERE last_name = &#39;Greene&#39;;</span></p><p class="c0"><span class="c1">This statement updates the salary for</span></p><p class="c0"><span class="c1">Greene to 12000.</span></p><p class="c0"><span class="c1">t5 SAVEPOINT after_greene_sal; This statement creates a savepoint named</span></p><p class="c0"><span class="c1">after_greene_sal, enabling changes in this</span></p><p class="c0"><span class="c1">transaction to be rolled back to this point.</span></p><p class="c0"><span class="c1">t6 ROLLBACK TO SAVEPOINT</span></p><p class="c0"><span class="c1">after_banda_sal;</span></p><p class="c0"><span class="c1">This statement rolls back the transaction to</span></p><p class="c0"><span class="c1">t3, undoing the update to Greene&#39;s salary at</span></p><p class="c0"><span class="c1">t4. The sal_update transaction has not</span></p><p class="c0"><span class="c1">ended.</span></p><p class="c0"><span class="c1">t7 UPDATE employees</span></p><p class="c0"><span class="c1">SET salary = 11000</span></p><p class="c0"><span class="c1">WHERE last_name = &#39;Greene&#39;;</span></p><p class="c0"><span class="c1">This statement updates the salary for</span></p><p class="c0"><span class="c1">Greene to 11000 in transaction sal_update.</span></p><p class="c0"><span class="c1">t8 ROLLBACK; This statement rolls back all changes in</span></p><p class="c0"><span class="c1">transaction sal_update, ending the</span></p><p class="c0"><span class="c1">transaction.</span></p><p class="c0"><span class="c1">t9 SET TRANSACTION NAME &#39;sal_update2&#39;; This statement begins a new transaction in</span></p><p class="c0"><span class="c1">the session and names it sal_update2.Overview of Transaction Control</span></p><p class="c0"><span class="c1">Transactions 10-7</span></p><p class="c0"><span class="c1">Transaction Names</span></p><p class="c0"><span class="c1">A transaction name is an optional, user-specified tag that serves as a reminder of the</span></p><p class="c0"><span class="c1">work that the transaction is performing. You name a transaction with the SET</span></p><p class="c0"><span class="c1">TRANSACTION ... NAME statement, which if used must be first statement of the</span></p><p class="c0"><span class="c1">transaction. In Table 10&ndash;1 on page 10-6, the first transaction was named sal_update</span></p><p class="c0"><span class="c1">and the second was named sal_update2.</span></p><p class="c0"><span class="c1">Transaction names provide the following advantages:</span></p><p class="c0"><span class="c1">&#9632; It is easier to monitor long-running transactions and to resolve in-doubt</span></p><p class="c0"><span class="c1">distributed transactions.</span></p><p class="c0"><span class="c1">&#9632; You can view transaction names along with transaction IDs in applications. For</span></p><p class="c0"><span class="c1">example, a database administrator can view transaction names in Oracle</span></p><p class="c0"><span class="c1">Enterprise Manager (Enterprise Manager) when monitoring system activity.</span></p><p class="c0"><span class="c1">&#9632; The database writes transaction names to the transaction auditing redo record, so</span></p><p class="c0"><span class="c1">you can use LogMiner to search for a specific transaction in the redo log.</span></p><p class="c0"><span class="c1">&#9632; You can use transaction names to find a specific transaction in data dictionary</span></p><p class="c0"><span class="c1">views such as V$TRANSACTION.</span></p><p class="c0"><span class="c1">Active Transactions</span></p><p class="c0"><span class="c1">An active transaction has started but not yet committed or rolled back. In Table 10&ndash;1</span></p><p class="c0"><span class="c1">on page 10-6, the first statement to modify data in the sal_update transaction is the</span></p><p class="c0"><span class="c1">update to Banda&#39;s salary. From the successful execution of this update until the</span></p><p class="c0"><span class="c1">ROLLBACK statement ends the transaction, the sal_update transaction is active.</span></p><p class="c0"><span class="c1">Data changes made by a transaction are temporary until the transaction is committed</span></p><p class="c0"><span class="c1">or rolled back. Before the transaction ends, the state of the data is as follows:</span></p><p class="c0"><span class="c1">t10 UPDATE employees</span></p><p class="c0"><span class="c1">SET salary = 7050</span></p><p class="c0"><span class="c1">WHERE last_name = &#39;Banda&#39;;</span></p><p class="c0"><span class="c1">This statement updates the salary for Banda</span></p><p class="c0"><span class="c1">to 7050.</span></p><p class="c0"><span class="c1">t11 UPDATE employees</span></p><p class="c0"><span class="c1">SET salary = 10950</span></p><p class="c0"><span class="c1">WHERE last_name = &#39;Greene&#39;;</span></p><p class="c0"><span class="c1">This statement updates the salary for</span></p><p class="c0"><span class="c1">Greene to 10950.</span></p><p class="c0"><span class="c1">t12 COMMIT; This statement commits all changes made in</span></p><p class="c0"><span class="c1">transaction sal_update2, ending the</span></p><p class="c0"><span class="c1">transaction. The commit guarantees that the</span></p><p class="c0"><span class="c1">changes are saved in the online redo log</span></p><p class="c0"><span class="c1">files.</span></p><p class="c0"><span class="c1">See Also: Oracle Database SQL Language Reference to learn about</span></p><p class="c0"><span class="c1">transaction control statements</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Oracle Enterprise Manager&quot; on page 18-2</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Reference to learn about V$TRANSACTION</span></p><p class="c0"><span class="c1">&#9632; Oracle Database SQL Language Reference to learn about SET</span></p><p class="c0"><span class="c1">TRANSACTION</span></p><p class="c0"><span class="c1">Table 10&ndash;1 (Cont.) Transaction Control</span></p><p class="c0"><span class="c1">Time Session ExplanationOverview of Transaction Control</span></p><p class="c0"><span class="c1">10-8 Oracle Database Concepts</span></p><p class="c0"><span class="c1">&#9632; Oracle Database has generated undo data information in the system global area</span></p><p class="c0"><span class="c1">(SGA).</span></p><p class="c0"><span class="c1">The undo data contains the old data values changed by the SQL statements of the</span></p><p class="c0"><span class="c1">transaction. See &quot;Read Consistency in the Read Committed Isolation Level&quot; on</span></p><p class="c0"><span class="c1">page 9-7.</span></p><p class="c0"><span class="c1">&#9632; Oracle Database has generated redo in the online redo log buffer of the SGA.</span></p><p class="c0"><span class="c1">The redo log record contains the change to the data block and the change to the</span></p><p class="c0"><span class="c1">undo block. See &quot;Redo Log Buffer&quot; on page 14-14.</span></p><p class="c0"><span class="c1">&#9632; Changes have been made to the database buffers of the SGA.</span></p><p class="c0"><span class="c1">The data changes for a committed transaction, stored in the database buffers of the</span></p><p class="c0"><span class="c1">SGA, are not necessarily written immediately to the data files by the database</span></p><p class="c0"><span class="c1">writer (DBW). The disk write can happen before or after the commit. See</span></p><p class="c0"><span class="c1">&quot;Database Buffer Cache&quot; on page 14-9.</span></p><p class="c0"><span class="c1">&#9632; The rows affected by the data change are locked.</span></p><p class="c0"><span class="c1">Other users cannot change the data in the affected rows, nor can they see the</span></p><p class="c0"><span class="c1">uncommitted changes. See &quot;Summary of Locking Behavior&quot; on page 9-12.</span></p><p class="c0"><span class="c1">Savepoints</span></p><p class="c0"><span class="c1">A savepoint is a user-declared intermediate marker within the context of a transaction.</span></p><p class="c0"><span class="c1">Internally, this marker resolves to an SCN. Savepoints divide a long transaction into</span></p><p class="c0"><span class="c1">smaller parts.</span></p><p class="c0"><span class="c1">If you use savepoints in a long transaction, then you have the option later of rolling</span></p><p class="c0"><span class="c1">back work performed before the current point in the transaction but after a declared</span></p><p class="c0"><span class="c1">savepoint within the transaction. Thus, if you make an error, you do not need to</span></p><p class="c0"><span class="c1">resubmit every statement. Table 10&ndash;1 on page 10-6 creates savepoint after_banda_sal</span></p><p class="c0"><span class="c1">so that the update to the Greene salary can be rolled back to this savepoint.</span></p><p class="c0"><span class="c1">Rollback to Savepoint</span></p><p class="c0"><span class="c1">A rollback to a savepoint in an uncommitted transaction means undoing any changes</span></p><p class="c0"><span class="c1">made after the specified savepoint, but it does not mean a rollback of the transaction</span></p><p class="c0"><span class="c1">itself. When a transaction is rolled back to a savepoint, as when the ROLLBACK TO</span></p><p class="c0"><span class="c1">SAVEPOINT after_banda_sal is run in Table 10&ndash;1 on page 10-6, the following occurs:</span></p><p class="c0"><span class="c1">1. Oracle Database rolls back only the statements run after the savepoint.</span></p><p class="c0"><span class="c1">In Table 10&ndash;1 on page 10-6, the ROLLBACK TO SAVEPOINT causes the UPDATE for</span></p><p class="c0"><span class="c1">Greene to be rolled back, but not the UPDATE for Banda.</span></p><p class="c0"><span class="c1">2. Oracle Database preserves the savepoint specified in the ROLLBACK TO SAVEPOINT</span></p><p class="c0"><span class="c1">statement, but all subsequent savepoints are lost.</span></p><p class="c0"><span class="c1">In Table 10&ndash;1 on page 10-6, the ROLLBACK TO SAVEPOINT causes the</span></p><p class="c0"><span class="c1">after_greene_sal savepoint to be lost.</span></p><p class="c0"><span class="c1">3. Oracle Database releases all table and row locks acquired after the specified</span></p><p class="c0"><span class="c1">savepoint but retains all data locks acquired previous to the savepoint.</span></p><p class="c0"><span class="c1">The transaction remains active and can be continued.Overview of Transaction Control</span></p><p class="c0"><span class="c1">Transactions 10-9</span></p><p class="c0"><span class="c1">Enqueued Transactions</span></p><p class="c0"><span class="c1">Depending on the scenario, transactions waiting for previously locked resources may</span></p><p class="c0"><span class="c1">still be blocked after a rollback to savepoint. When a transaction is blocked by another</span></p><p class="c0"><span class="c1">transaction it enqueues on the blocking transaction itself, so that the entire blocking</span></p><p class="c0"><span class="c1">transaction must commit or roll back for the blocked transaction to continue.</span></p><p class="c0"><span class="c1">In the scenario shown in Table 10&ndash;2, session 1 rolls back to a savepoint created before it</span></p><p class="c0"><span class="c1">executed a DML statement. However, session 2 is still blocked because it is waiting for</span></p><p class="c0"><span class="c1">the session 1 transaction to complete.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database SQL Language Reference to learn about the</span></p><p class="c0"><span class="c1">ROLLBACK and SAVEPOINT statements</span></p><p class="c0"><span class="c1">&#9632; Oracle Database PL/SQL Language Reference to learn about</span></p><p class="c0"><span class="c1">transaction processing and control</span></p><p class="c0"><span class="c1">Table 10&ndash;2 Rollback to Savepoint Example</span></p><p class="c0"><span class="c1">Time Session 1 Session 2 Session 3 Explanation</span></p><p class="c0"><span class="c1">t0 UPDATE employees</span></p><p class="c0"><span class="c1">SET salary = 7000</span></p><p class="c0"><span class="c1">WHERE last_name =</span></p><p class="c0"><span class="c1">&#39;Banda&#39;;</span></p><p class="c0"><span class="c1">Session 1 begins a transaction. The</span></p><p class="c0"><span class="c1">session places an exclusive lock on the</span></p><p class="c0"><span class="c1">Banda row (TX) and a subexclusive table</span></p><p class="c0"><span class="c1">lock (SX) on the table.</span></p><p class="c0"><span class="c1">t1 SAVEPOINT</span></p><p class="c0"><span class="c1">after_banda_sal;</span></p><p class="c0"><span class="c1">Session 1 creates a savepoint named</span></p><p class="c0"><span class="c1">after_banda_sal.</span></p><p class="c0"><span class="c1">t2 UPDATE employees</span></p><p class="c0"><span class="c1">SET salary = 12000</span></p><p class="c0"><span class="c1">WHERE last_name =</span></p><p class="c0"><span class="c1">&#39;Greene&#39;;</span></p><p class="c0"><span class="c1">Session 1 locks the Greene row.</span></p><p class="c0"><span class="c1">t3 UPDATE employees</span></p><p class="c0"><span class="c1">SET salary = 14000</span></p><p class="c0"><span class="c1">WHERE last_name =</span></p><p class="c0"><span class="c1">&#39;Greene&#39;;</span></p><p class="c0"><span class="c1">Session 2 attempts to update the Greene</span></p><p class="c0"><span class="c1">row, but fails to acquire a lock because</span></p><p class="c0"><span class="c1">session 1 has a lock on this row. No</span></p><p class="c0"><span class="c1">transaction has begun in session 2.</span></p><p class="c0"><span class="c1">t4 ROLLBACK</span></p><p class="c0"><span class="c1">TO SAVEPOINT</span></p><p class="c0"><span class="c1">after_banda_sal;</span></p><p class="c0"><span class="c1">Session 1 rolls back the update to the</span></p><p class="c0"><span class="c1">salary for Greene, which releases the</span></p><p class="c0"><span class="c1">row lock for Greene. The table lock</span></p><p class="c0"><span class="c1">acquired at t0 is not released.</span></p><p class="c0"><span class="c1">At this point, session 2 is still blocked</span></p><p class="c0"><span class="c1">by session 1 because session 2 enqueues</span></p><p class="c0"><span class="c1">on the session 1 transaction, which has</span></p><p class="c0"><span class="c1">not yet completed.</span></p><p class="c0"><span class="c1">t5 UPDATE employees</span></p><p class="c0"><span class="c1">SET salary = 11000</span></p><p class="c0"><span class="c1">WHERE last_name =</span></p><p class="c0"><span class="c1">&#39;Greene&#39;;</span></p><p class="c0"><span class="c1">The Greene row is currently unlocked,</span></p><p class="c0"><span class="c1">so session 3 acquires a lock for an</span></p><p class="c0"><span class="c1">update to the Greene row. This</span></p><p class="c0"><span class="c1">statement begins a transaction in</span></p><p class="c0"><span class="c1">session 3.</span></p><p class="c0"><span class="c1">t6 COMMIT; Session 1 commits, ending its</span></p><p class="c0"><span class="c1">transaction. Session 2 is now enqueued</span></p><p class="c0"><span class="c1">for its update to the Greene row behind</span></p><p class="c0"><span class="c1">the transaction in session 3.</span></p><p class="c0"><span class="c1">See Also: &quot;Lock Duration&quot; on page 9-16 to learn more about when</span></p><p class="c0"><span class="c1">Oracle Database releases locksOverview of Transaction Control</span></p><p class="c0"><span class="c1">10-10 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Rollback of Transactions</span></p><p class="c0"><span class="c1">A rollback of an uncommitted transaction undoes any changes to data that have been</span></p><p class="c0"><span class="c1">performed by SQL statements within the transaction. After a transaction has been</span></p><p class="c0"><span class="c1">rolled back, the effects of the work done in the transaction no longer exist.</span></p><p class="c0"><span class="c1">In rolling back an entire transaction, without referencing any savepoints, Oracle</span></p><p class="c0"><span class="c1">Database performs the following actions:</span></p><p class="c0"><span class="c1">&#9632; Undoes all changes made by all the SQL statements in the transaction by using the</span></p><p class="c0"><span class="c1">corresponding undo segments</span></p><p class="c0"><span class="c1">The transaction table entry for every active transaction contains a pointer to all the</span></p><p class="c0"><span class="c1">undo data (in reverse order of application) for the transaction. The database reads</span></p><p class="c0"><span class="c1">the data from the undo segment, reverses the operation, and then marks the undo</span></p><p class="c0"><span class="c1">entry as applied. Thus, if a transaction inserts a row, then a rollback deletes it. If a</span></p><p class="c0"><span class="c1">transaction updates a row, then a rollback reverses the update. If a transaction</span></p><p class="c0"><span class="c1">deletes a row, then a rollback reinserts it. In Table 10&ndash;1 on page 10-6, the ROLLBACK</span></p><p class="c0"><span class="c1">reverses the updates to the salaries of Greene and Banda.</span></p><p class="c0"><span class="c1">&#9632; Releases all the locks of data held by the transaction</span></p><p class="c0"><span class="c1">&#9632; Erases all savepoints in the transaction</span></p><p class="c0"><span class="c1">In Table 10&ndash;1 on page 10-6, the ROLLBACK deletes the savepoint after_banda_sal.</span></p><p class="c0"><span class="c1">The after_greene_sal savepoint was removed by the ROLLBACK TO SAVEPOINT</span></p><p class="c0"><span class="c1">statement.</span></p><p class="c0"><span class="c1">&#9632; Ends the transaction</span></p><p class="c0"><span class="c1">In Table 10&ndash;1 on page 10-6, the ROLLBACK leaves the database in the same state as it</span></p><p class="c0"><span class="c1">was after the initial COMMIT was executed.</span></p><p class="c0"><span class="c1">The duration of a rollback is a function of the amount of data modified.</span></p><p class="c0"><span class="c1">Committing Transactions</span></p><p class="c0"><span class="c1">A commit ends the current transaction and makes permanent all changes performed</span></p><p class="c0"><span class="c1">in the transaction. In Table 10&ndash;1 on page 10-6, a second transaction begins with</span></p><p class="c0"><span class="c1">sal_update2 and ends with an explicit COMMIT statement. The changes that resulted</span></p><p class="c0"><span class="c1">from the two UPDATE statements are now made permanent.</span></p><p class="c0"><span class="c1">When a transaction commits, the following actions occur:</span></p><p class="c0"><span class="c1">&#9632; A system change number (SCN) is generated for the COMMIT.</span></p><p class="c0"><span class="c1">The internal transaction table for the associated undo tablespace records that the</span></p><p class="c0"><span class="c1">transaction has committed. The corresponding unique SCN of the transaction is</span></p><p class="c0"><span class="c1">assigned and recorded in the transaction table. See &quot;Serializable Isolation Level&quot; on</span></p><p class="c0"><span class="c1">page 9-8.</span></p><p class="c0"><span class="c1">&#9632; The log writer (LGWR) process writes remaining redo log entries in the redo log</span></p><p class="c0"><span class="c1">buffers to the online redo log and writes the transaction SCN to the online redo</span></p><p class="c0"><span class="c1">log. This atomic event constitutes the commit of the transaction.</span></p><p class="c0"><span class="c1">&#9632; Oracle Database releases locks held on rows and tables.</span></p><p class="c0"><span class="c1">Users who were enqueued waiting on locks held by the uncommitted transaction</span></p><p class="c0"><span class="c1">are allowed to proceed with their work.</span></p><p class="c0"><span class="c1">&#9632; Oracle Database deletes savepoints.</span></p><p class="c0"><span class="c1">See Also: &quot;Undo Segments&quot; on page 12-24Overview of Autonomous Transactions</span></p><p class="c0"><span class="c1">Transactions 10-11</span></p><p class="c0"><span class="c1">In Table 10&ndash;1 on page 10-6, no savepoints existed in the sal_update transaction so</span></p><p class="c0"><span class="c1">no savepoints were erased.</span></p><p class="c0"><span class="c1">&#9632; Oracle Database performs a commit cleanout.</span></p><p class="c0"><span class="c1">If modified blocks containing data from the committed transaction are still in the</span></p><p class="c0"><span class="c1">SGA, and if no other session is modifying them, then the database removes</span></p><p class="c0"><span class="c1">lock-related transaction information from the blocks. Ideally, the COMMIT cleans out</span></p><p class="c0"><span class="c1">the blocks so that a subsequent SELECT does not have to perform this task.</span></p><p class="c0"><span class="c1">&#9632; Oracle Database marks the transaction complete.</span></p><p class="c0"><span class="c1">After a transaction commits, users can view the changes.</span></p><p class="c0"><span class="c1">Typically, a commit is a fast operation, regardless of the transaction size. The speed of a</span></p><p class="c0"><span class="c1">commit does not increase with the size of the data modified in the transaction. The</span></p><p class="c0"><span class="c1">lengthiest part of the commit is the physical disk I/O performed by LGWR. However,</span></p><p class="c0"><span class="c1">the amount of time spent by LGWR is reduced because it has been incrementally</span></p><p class="c0"><span class="c1">writing the contents of the redo log buffer in the background.</span></p><p class="c0"><span class="c1">The default behavior is for LGWR to write redo to the online redo log synchronously</span></p><p class="c0"><span class="c1">and for transactions to wait for the buffered redo to be on disk before returning a</span></p><p class="c0"><span class="c1">commit to the user. However, for lower transaction commit latency, application</span></p><p class="c0"><span class="c1">developers can specify that redo be written asynchronously so that transactions need</span></p><p class="c0"><span class="c1">not wait for the redo to be on disk and can return from the COMMIT call immediately.</span></p><p class="c0"><span class="c1">Overview of Autonomous Transactions</span></p><p class="c0"><span class="c1">An autonomous transaction is an independent transaction that can be called from</span></p><p class="c0"><span class="c1">another transaction, called the main transaction. You can suspend the calling</span></p><p class="c0"><span class="c1">transaction, perform SQL operations and commit or undo them in the autonomous</span></p><p class="c0"><span class="c1">transaction, and then resume the calling transaction.</span></p><p class="c0"><span class="c1">Autonomous transactions are useful for actions that must be performed</span></p><p class="c0"><span class="c1">independently, regardless of whether the calling transaction commits or rolls back. For</span></p><p class="c0"><span class="c1">example, in a stock purchase transaction, you want to commit customer data</span></p><p class="c0"><span class="c1">regardless of whether the overall stock purchase goes through. Additionally, you want</span></p><p class="c0"><span class="c1">to log error messages to a debug table even if the overall transaction rolls back.</span></p><p class="c0"><span class="c1">Autonomous transactions have the following characteristics:</span></p><p class="c0"><span class="c1">&#9632; The autonomous transaction does not see uncommitted changes made by the main</span></p><p class="c0"><span class="c1">transaction and does not share locks or resources with the main transaction.</span></p><p class="c0"><span class="c1">&#9632; Changes in an autonomous transaction are visible to other transactions upon</span></p><p class="c0"><span class="c1">commit of the autonomous transactions. Thus, users can access the updated</span></p><p class="c0"><span class="c1">information without having to wait for the main transaction to commit.</span></p><p class="c0"><span class="c1">Note: Because a block cleanout generates redo, a query may generate</span></p><p class="c0"><span class="c1">redo and thus cause blocks to be written during the next checkpoint.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database PL/SQL Language Reference for more information</span></p><p class="c0"><span class="c1">on asynchronous commit</span></p><p class="c0"><span class="c1">&#9632; &quot;Locking Mechanisms&quot; on page 9-5</span></p><p class="c0"><span class="c1">&#9632; &quot;Overview of Background Processes&quot; on page 15-7 for more</span></p><p class="c0"><span class="c1">information about LGWROverview of Distributed Transactions</span></p><p class="c0"><span class="c1">10-12 Oracle Database Concepts</span></p><p class="c0"><span class="c1">&#9632; Autonomous transactions can start other autonomous transactions. There are no</span></p><p class="c0"><span class="c1">limits, other than resource limits, on how many levels of autonomous transactions</span></p><p class="c0"><span class="c1">can be called.</span></p><p class="c0"><span class="c1">In PL/SQL, an autonomous transaction executes within an autonomous scope, which</span></p><p class="c0"><span class="c1">is a routine marked with the pragma AUTONOMOUS_TRANSACTION. In this context,</span></p><p class="c0"><span class="c1">routines include top-level anonymous PL/SQL blocks and PL/SQL subprograms and</span></p><p class="c0"><span class="c1">triggers. A pragma is a directive that instructs the compiler to perform a compilation</span></p><p class="c0"><span class="c1">option. The pragma AUTONOMOUS_TRANSACTION instructs the database that this</span></p><p class="c0"><span class="c1">procedure, when executed, is to be executed as a new autonomous transaction that is</span></p><p class="c0"><span class="c1">independent of its parent transaction.</span></p><p class="c0"><span class="c1">Figure 10&ndash;2 shows how control flows from the main routine (MT) to an autonomous</span></p><p class="c0"><span class="c1">routine and back again. The main routine is proc1 and the autonomous routine is</span></p><p class="c0"><span class="c1">proc2. The autonomous routine can commit multiple transactions (AT1 and AT2)</span></p><p class="c0"><span class="c1">before control returns to the main routine.</span></p><p class="c0"><span class="c1">Figure 10&ndash;2 Transaction Control Flow</span></p><p class="c0"><span class="c1">When you enter the executable section of an autonomous routine, the main routine</span></p><p class="c0"><span class="c1">suspends. When you exit the autonomous routine, the main routine resumes.</span></p><p class="c0"><span class="c1">In Figure 10&ndash;2, the COMMIT inside proc1 makes permanent not only its own work but</span></p><p class="c0"><span class="c1">any outstanding work performed in its session. However, a COMMIT in proc2 makes</span></p><p class="c0"><span class="c1">permanent only the work performed in the proc2 transaction. Thus, the COMMIT</span></p><p class="c0"><span class="c1">statements in transactions AT1 and AT2 have no effect on the MT transaction.</span></p><p class="c0"><span class="c1">Overview of Distributed Transactions</span></p><p class="c0"><span class="c1">A distributed database is a set of databases in a distributed system that can appear to</span></p><p class="c0"><span class="c1">applications as a single data source. A distributed transaction is a transaction that</span></p><p class="c0"><span class="c1">includes one or more statements that update data on two or more distinct nodes of a</span></p><p class="c0"><span class="c1">distributed database, using a schema object called a database link. A database link</span></p><p class="c0"><span class="c1">describes how one database instance can log in to another database instance.</span></p><p class="c0"><span class="c1">Unlike a transaction on a local database, a distributed transaction alters data on</span></p><p class="c0"><span class="c1">multiple databases. Consequently, distributed transaction processing is more</span></p><p class="c0"><span class="c1">complicated because the database must coordinate the committing or rolling back of</span></p><p class="c0"><span class="c1">the changes in a transaction as an atomic unit. The entire transaction must commit or</span></p><p class="c0"><span class="c1">See Also: Oracle Database Advanced Application Developer&#39;s Guide</span></p><p class="c0"><span class="c1">and Oracle Database PL/SQL Language Reference to learn how to use</span></p><p class="c0"><span class="c1">autonomous transactions</span></p><p class="c0"><span class="c1">PROCEDURE proc1 IS</span></p><p class="c0"><span class="c1">emp_id NUMBER;</span></p><p class="c0"><span class="c1">BEGIN</span></p><p class="c0"><span class="c1">emp_id := 7788;</span></p><p class="c0"><span class="c1">INSERT ...</span></p><p class="c0"><span class="c1">SELECT ...</span></p><p class="c0"><span class="c1">proc2;</span></p><p class="c0"><span class="c1">DELETE ...</span></p><p class="c0"><span class="c1">COMMIT;</span></p><p class="c0"><span class="c1">END;</span></p><p class="c0"><span class="c1">PROCEDURE proc2 IS</span></p><p class="c0"><span class="c1">PRAGMA AUTON...</span></p><p class="c0"><span class="c1">dept_id NUMBER;</span></p><p class="c0"><span class="c1">BEGIN</span></p><p class="c0"><span class="c1">dept_id := 20;</span></p><p class="c0"><span class="c1">UPDATE ...</span></p><p class="c0"><span class="c1">INSERT ...</span></p><p class="c0"><span class="c1">UPDATE ...</span></p><p class="c0"><span class="c1">COMMIT;</span></p><p class="c0"><span class="c1">INSERT ...</span></p><p class="c0"><span class="c1">INSERT ...</span></p><p class="c0"><span class="c1">COMMIT;</span></p><p class="c0"><span class="c1">END;</span></p><p class="c0"><span class="c1">Main Transaction Autonomous Transaction</span></p><p class="c0"><span class="c1">MT ends</span></p><p class="c0"><span class="c1">MT begins</span></p><p class="c0"><span class="c1">MT suspends</span></p><p class="c0"><span class="c1">AT1 begins</span></p><p class="c0"><span class="c1">AT1 ends</span></p><p class="c0"><span class="c1">AT2 begins</span></p><p class="c0"><span class="c1">AT2 ends</span></p><p class="c0"><span class="c1">MT resumesOverview of Distributed Transactions</span></p><p class="c0"><span class="c1">Transactions 10-13</span></p><p class="c0"><span class="c1">roll back. Oracle Database must coordinate transaction control over a network and</span></p><p class="c0"><span class="c1">maintain data consistency, even if a network or system failure occurs.</span></p><p class="c0"><span class="c1">Two-Phase Commit</span></p><p class="c0"><span class="c1">The two-phase commit mechanism guarantees that all databases participating in a</span></p><p class="c0"><span class="c1">distributed transaction either all commit or all undo the statements in the transaction.</span></p><p class="c0"><span class="c1">The mechanism also protects implicit DML performed by integrity constraints, remote</span></p><p class="c0"><span class="c1">procedure calls, and triggers.</span></p><p class="c0"><span class="c1">In a two-phase commit among multiple databases, one database coordinates the</span></p><p class="c0"><span class="c1">distributed transaction. The initiating node is called the global coordinator. The</span></p><p class="c0"><span class="c1">coordinator asks the other databases if they are prepared to commit. If any database</span></p><p class="c0"><span class="c1">responds with a no, then the entire transaction is rolled back. If all databases vote yes,</span></p><p class="c0"><span class="c1">then the coordinator broadcasts a message to make the commit permanent on each of</span></p><p class="c0"><span class="c1">the databases.</span></p><p class="c0"><span class="c1">The two-phase commit mechanism is transparent to users who issue distributed</span></p><p class="c0"><span class="c1">transactions. In fact, users need not even know the transaction is distributed. A COMMIT</span></p><p class="c0"><span class="c1">statement denoting the end of a transaction automatically triggers the two-phase</span></p><p class="c0"><span class="c1">commit mechanism. No coding or complex statement syntax is required to include</span></p><p class="c0"><span class="c1">distributed transactions within the body of a database application.</span></p><p class="c0"><span class="c1">In-Doubt Transactions</span></p><p class="c0"><span class="c1">An in-doubt distributed transaction occurs when a two-phase commit was</span></p><p class="c0"><span class="c1">interrupted by any type of system or network failure. For example, two databases</span></p><p class="c0"><span class="c1">report to the coordinating database that they were prepared to commit, but the</span></p><p class="c0"><span class="c1">coordinating database instance fails immediately after receiving the messages. The two</span></p><p class="c0"><span class="c1">databases who are prepared to commit are now left hanging while they await</span></p><p class="c0"><span class="c1">notification of the outcome.</span></p><p class="c0"><span class="c1">The recoverer (RECO) background process automatically resolves the outcome of</span></p><p class="c0"><span class="c1">in-doubt distributed transactions. After the failure is repaired and communication is</span></p><p class="c0"><span class="c1">reestablished, the RECO process of each local Oracle database automatically commits or</span></p><p class="c0"><span class="c1">rolls back any in-doubt distributed transactions consistently on all involved nodes.</span></p><p class="c0"><span class="c1">In the event of a long-term failure, Oracle Database enables each local administrator to</span></p><p class="c0"><span class="c1">manually commit or undo any distributed transactions that are in doubt because of the</span></p><p class="c0"><span class="c1">failure. This option enables the local database administrator to free any locked</span></p><p class="c0"><span class="c1">resources that are held indefinitely because of the long-term failure.</span></p><p class="c0"><span class="c1">If a database must be recovered to a past time, then database recovery facilities enable</span></p><p class="c0"><span class="c1">database administrators at other sites to return their databases to the earlier point in</span></p><p class="c0"><span class="c1">time. This operation ensures that the global database remains consistent.</span></p><p class="c0"><span class="c1">See Also: Oracle Database Administrator&#39;s Guide</span></p><p class="c0"><span class="c1">See Also: Oracle Database Administrator&#39;s Guide to learn about the</span></p><p class="c0"><span class="c1">two-phase commit mechanism</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Recoverer Process (RECO)&quot; on page 15-11</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn how to manage</span></p><p class="c0"><span class="c1">in-doubt transactionsOverview of Distributed Transactions</span></p><p class="c0"><span class="c1">10-14 Oracle Database ConceptsPart IV</span></p><p class="c0"><span class="c1">Part IV Oracle Database Storage Structures</span></p><p class="c0"><span class="c1">This part describes the basic structural architecture of the Oracle database, including</span></p><p class="c0"><span class="c1">logical and physical storage structures.</span></p><p class="c0"><span class="c1">This part contains the following chapters:</span></p><p class="c0"><span class="c1">&#9632; Chapter 11, &quot;Physical Storage Structures&quot;</span></p><p class="c0"><span class="c1">&#9632; Chapter 12, &quot;Logical Storage Structures&quot;11</span></p><p class="c0"><span class="c1">Physical Storage Structures 11-1</span></p><p class="c0"><span class="c1">Physical Storage Structures 1 1</span></p><p class="c0"><span class="c1">This chapter describes the primary physical database structures of an Oracle database.</span></p><p class="c0"><span class="c1">Physical structures are viewable at the operating system level.</span></p><p class="c0"><span class="c1">This chapter contains the following sections:</span></p><p class="c0"><span class="c1">&#9632; Introduction to Physical Storage Structures</span></p><p class="c0"><span class="c1">&#9632; Overview of Data Files</span></p><p class="c0"><span class="c1">&#9632; Overview of Control Files</span></p><p class="c0"><span class="c1">&#9632; Overview of the Online Redo Log</span></p><p class="c0"><span class="c1">Introduction to Physical Storage Structures</span></p><p class="c0"><span class="c1">One characteristic of an RDBMS is the independence of logical data structures such as</span></p><p class="c0"><span class="c1">tables, views, and indexes from physical storage structures. Because physical and</span></p><p class="c0"><span class="c1">logical structures are separate, you can manage physical storage of data without</span></p><p class="c0"><span class="c1">affecting access to logical structures. For example, renaming a database file does not</span></p><p class="c0"><span class="c1">rename the tables stored in it.</span></p><p class="c0"><span class="c1">An Oracle database is a set of files that store Oracle data in persistent disk storage.</span></p><p class="c0"><span class="c1">This section discusses the database files generated when you issue a CREATE DATABASE</span></p><p class="c0"><span class="c1">statement:</span></p><p class="c0"><span class="c1">&#9632; Data files and temp files</span></p><p class="c0"><span class="c1">A data file is a physical file on disk that was created by Oracle Database and</span></p><p class="c0"><span class="c1">contains data structures such as tables and indexes. A temp file is a data file that</span></p><p class="c0"><span class="c1">belongs to a temporary tablespace. The data is written to these files in an Oracle</span></p><p class="c0"><span class="c1">proprietary format that cannot be read by other programs.</span></p><p class="c0"><span class="c1">&#9632; Control files</span></p><p class="c0"><span class="c1">A control file is a root file that tracks the physical components of the database.</span></p><p class="c0"><span class="c1">&#9632; Online redo log files</span></p><p class="c0"><span class="c1">The online redo log is a set of files containing records of changes made to data.</span></p><p class="c0"><span class="c1">A database instance is a set of memory structures that manage database files.</span></p><p class="c0"><span class="c1">Figure 11&ndash;1 shows the relationship between the instance and the files that it manages.Introduction to Physical Storage Structures</span></p><p class="c0"><span class="c1">11-2 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Figure 11&ndash;1 Database Instance and Database Files</span></p><p class="c0"><span class="c1">Mechanisms for Storing Database Files</span></p><p class="c0"><span class="c1">Several mechanisms are available for allocating and managing the storage of these</span></p><p class="c0"><span class="c1">files. The most common mechanisms include:</span></p><p class="c0"><span class="c1">&#9632; Oracle Automatic Storage Management (Oracle ASM)</span></p><p class="c0"><span class="c1">Oracle ASM includes a file system designed exclusively for use by Oracle</span></p><p class="c0"><span class="c1">Database. &quot;Oracle Automatic Storage Management (Oracle ASM)&quot; on page 11-3</span></p><p class="c0"><span class="c1">describes Oracle ASM.</span></p><p class="c0"><span class="c1">&#9632; Operating system file system</span></p><p class="c0"><span class="c1">Most Oracle databases store files in a file system, which is a data structure built</span></p><p class="c0"><span class="c1">inside a contiguous disk address space. All operating systems have file managers</span></p><p class="c0"><span class="c1">that allocate and deallocate disk space into files within a file system.</span></p><p class="c0"><span class="c1">A file system enables disk space to be allocated to many files. Each file has a name</span></p><p class="c0"><span class="c1">and is made to appear as a contiguous address space to applications such as</span></p><p class="c0"><span class="c1">Oracle Database. The database can create, read, write, resize, and delete files.</span></p><p class="c0"><span class="c1">A file system is commonly built on top of a logical volume constructed by a</span></p><p class="c0"><span class="c1">software package called a logical volume manager (LVM). The LVM enables</span></p><p class="c0"><span class="c1">pieces of multiple physical disks to be combined into a single contiguous address</span></p><p class="c0"><span class="c1">space that appears as one disk to higher layers of software.</span></p><p class="c0"><span class="c1">&#9632; Raw device</span></p><p class="c0"><span class="c1">Raw devices are disk partitions or logical volumes not formatted with a file</span></p><p class="c0"><span class="c1">system. The primary benefit of raw devices is the ability to perform direct I/O and</span></p><p class="c0"><span class="c1">to write larger buffers. In direct I/O, applications write to and read from the</span></p><p class="c0"><span class="c1">storage device directly, bypassing the operating system buffer cache.</span></p><p class="c0"><span class="c1">&#9632; Cluster file system</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn how to create a</span></p><p class="c0"><span class="c1">database</span></p><p class="c0"><span class="c1">&#9632; Oracle Database SQL Language Reference for CREATE DATABASE</span></p><p class="c0"><span class="c1">semantics and syntax</span></p><p class="c0"><span class="c1">Note: Many file systems now support direct I/O for databases and</span></p><p class="c0"><span class="c1">other applications that manage their own caches. Historically, raw</span></p><p class="c0"><span class="c1">devices were the only means of implementing direct I/O.</span></p><p class="c0"><span class="c1">Database Instance</span></p><p class="c0"><span class="c1">Memory</span></p><p class="c0"><span class="c1">Disk</span></p><p class="c0"><span class="c1">10101</span></p><p class="c0"><span class="c1">10101</span></p><p class="c0"><span class="c1">10101 10101</span></p><p class="c0"><span class="c1">Control</span></p><p class="c0"><span class="c1">Files</span></p><p class="c0"><span class="c1">10101</span></p><p class="c0"><span class="c1">10101</span></p><p class="c0"><span class="c1">10101 10101</span></p><p class="c0"><span class="c1">Data</span></p><p class="c0"><span class="c1">Files</span></p><p class="c0"><span class="c1">Online</span></p><p class="c0"><span class="c1">Redo LogIntroduction to Physical Storage Structures</span></p><p class="c0"><span class="c1">Physical Storage Structures 11-3</span></p><p class="c0"><span class="c1">A cluster file system is software that enables multiple computers to share file</span></p><p class="c0"><span class="c1">storage while maintaining consistent space allocation and file content. In an Oracle</span></p><p class="c0"><span class="c1">RAC environment, a cluster file system makes shared storage appears as a file</span></p><p class="c0"><span class="c1">system shared by many computers in a clustered environment. With a cluster file</span></p><p class="c0"><span class="c1">system, the failure of a computer in the cluster does not make the file system</span></p><p class="c0"><span class="c1">unavailable. In an operating system file system, however, if a computer sharing</span></p><p class="c0"><span class="c1">files through NFS or other means fails, then the file system is unavailable.</span></p><p class="c0"><span class="c1">A database employs a combination of the preceding storage mechanisms. For example,</span></p><p class="c0"><span class="c1">a database could store the control files and online redo log files in a traditional file</span></p><p class="c0"><span class="c1">system, some user data files on raw partitions, the remaining data files in Oracle ASM,</span></p><p class="c0"><span class="c1">and archived the redo log files to a cluster file system.</span></p><p class="c0"><span class="c1">Oracle Automatic Storage Management (Oracle ASM)</span></p><p class="c0"><span class="c1">Oracle ASM is a high-performance, ease-of-management storage solution for Oracle</span></p><p class="c0"><span class="c1">Database files. Oracle ASM is a volume manager and provides a file system designed</span></p><p class="c0"><span class="c1">exclusively for use by the database.</span></p><p class="c0"><span class="c1">Oracle ASM provides several advantages over conventional file systems and storage</span></p><p class="c0"><span class="c1">managers, including the following:</span></p><p class="c0"><span class="c1">&#9632; Simplifies storage-related tasks such as creating and laying out databases and</span></p><p class="c0"><span class="c1">managing disk space</span></p><p class="c0"><span class="c1">&#9632; Distributes data across physical disks to eliminate hot spots and to provide</span></p><p class="c0"><span class="c1">uniform performance across the disks</span></p><p class="c0"><span class="c1">&#9632; Rebalances data automatically after storage configuration changes</span></p><p class="c0"><span class="c1">To use Oracle ASM, you allocate partitioned disks for Oracle Database with</span></p><p class="c0"><span class="c1">preferences for striping and mirroring. Oracle ASM manages the disk space,</span></p><p class="c0"><span class="c1">distributing the I/O load across all available resources to optimize performance while</span></p><p class="c0"><span class="c1">removing the need for manual I/O tuning. For example, you can increase the size of</span></p><p class="c0"><span class="c1">the disk for the database or move parts of the database to new devices without having</span></p><p class="c0"><span class="c1">to shut down the database.</span></p><p class="c0"><span class="c1">Oracle ASM Storage Components</span></p><p class="c0"><span class="c1">Oracle Database can store a data file as an Oracle ASM file in an Oracle ASM disk</span></p><p class="c0"><span class="c1">group, which is a collection of disks that Oracle ASM manages as a unit. Within a disk</span></p><p class="c0"><span class="c1">group, Oracle ASM exposes a file system interface for database files.</span></p><p class="c0"><span class="c1">Figure 11&ndash;2 shows the relationships between storage components in a database that</span></p><p class="c0"><span class="c1">uses Oracle ASM. The diagram depicts the relationship between an Oracle ASM file</span></p><p class="c0"><span class="c1">and a data file, although Oracle ASM can store other types of files. The crow&#39;s foot</span></p><p class="c0"><span class="c1">notation represents a one-to-many relationship.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database 2 Day DBA to learn how to view database storage</span></p><p class="c0"><span class="c1">structures with Oracle Enterprise Manager (Enterprise Manager)</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to view database storage</span></p><p class="c0"><span class="c1">structures by querying database viewsIntroduction to Physical Storage Structures</span></p><p class="c0"><span class="c1">11-4 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Figure 11&ndash;2 Oracle ASM Components</span></p><p class="c0"><span class="c1">Figure 11&ndash;2 illustrates the following Oracle ASM concepts:</span></p><p class="c0"><span class="c1">&#9632; Oracle ASM Disks</span></p><p class="c0"><span class="c1">An Oracle ASM disk is a storage device that is provisioned to an Oracle ASM disk</span></p><p class="c0"><span class="c1">group. An Oracle ASM disk can be a physical disk or partition, a Logical Unit</span></p><p class="c0"><span class="c1">Number (LUN) from a storage array, a logical volume, or a network-attached file.</span></p><p class="c0"><span class="c1">Oracle ASM disks can be added or dropped from a disk group while the database</span></p><p class="c0"><span class="c1">is running. When you add a disk to a disk group, you either assign a disk name or</span></p><p class="c0"><span class="c1">the disk is given an Oracle ASM disk name automatically.</span></p><p class="c0"><span class="c1">&#9632; Oracle ASM Disk Groups</span></p><p class="c0"><span class="c1">An Oracle ASM disk group is a collection of Oracle ASM disks managed as a</span></p><p class="c0"><span class="c1">logical unit. The data structures in a disk group are self-contained and consume</span></p><p class="c0"><span class="c1">some disk space in a disk group.</span></p><p class="c0"><span class="c1">Within a disk group, Oracle ASM exposes a file system interface for Oracle</span></p><p class="c0"><span class="c1">database files. The content of files that are stored in a disk group are evenly</span></p><p class="c0"><span class="c1">distributed, or striped, to eliminate hot spots and to provide uniform performance</span></p><p class="c0"><span class="c1">across the disks. The performance is comparable to the performance of raw</span></p><p class="c0"><span class="c1">devices.</span></p><p class="c0"><span class="c1">&#9632; Oracle ASM Files</span></p><p class="c0"><span class="c1">An Oracle ASM file is a file stored in an Oracle ASM disk group. Oracle Database</span></p><p class="c0"><span class="c1">communicates with Oracle ASM in terms of files. The database can store data files,</span></p><p class="c0"><span class="c1">control files, online redo log files, and other types of files as Oracle ASM files.</span></p><p class="c0"><span class="c1">When requested by the database, Oracle ASM creates an Oracle ASM file and</span></p><p class="c0"><span class="c1">assigns it a fully qualified name beginning with a plus sign (+) followed by a disk</span></p><p class="c0"><span class="c1">group name, as in +DISK1.</span></p><p class="c0"><span class="c1">&#9632; Oracle ASM Extents</span></p><p class="c0"><span class="c1">An Oracle ASM extent is the raw storage used to hold the contents of an Oracle</span></p><p class="c0"><span class="c1">ASM file. An Oracle ASM file consists of one or more file extents. Each Oracle</span></p><p class="c0"><span class="c1">ASM extent consists of one or more allocation units on a specific disk.</span></p><p class="c0"><span class="c1">Note: Oracle ASM files can coexist with other storage management</span></p><p class="c0"><span class="c1">options such as raw disks and third-party file systems. This capability</span></p><p class="c0"><span class="c1">simplifies the integration of Oracle ASM into pre-existing</span></p><p class="c0"><span class="c1">environments.</span></p><p class="c0"><span class="c1">Data File</span></p><p class="c0"><span class="c1">File System</span></p><p class="c0"><span class="c1">ASM File</span></p><p class="c0"><span class="c1">ASM Allocation</span></p><p class="c0"><span class="c1">Unit</span></p><p class="c0"><span class="c1">ASM Extent</span></p><p class="c0"><span class="c1">ASM Disk</span></p><p class="c0"><span class="c1">Group</span></p><p class="c0"><span class="c1">ASM Disk</span></p><p class="c0"><span class="c1">Oracle ASMIntroduction to Physical Storage Structures</span></p><p class="c0"><span class="c1">Physical Storage Structures 11-5</span></p><p class="c0"><span class="c1">&#9632; Oracle ASM Allocation Units</span></p><p class="c0"><span class="c1">An allocation unit is the fundamental unit of allocation within a disk group. An</span></p><p class="c0"><span class="c1">allocation unit is the smallest contiguous disk space that Oracle ASM allocates.</span></p><p class="c0"><span class="c1">One or more allocation units form an Oracle ASM extent.</span></p><p class="c0"><span class="c1">Oracle ASM Instances</span></p><p class="c0"><span class="c1">An Oracle ASM instance is a special Oracle instance that manages Oracle ASM disks.</span></p><p class="c0"><span class="c1">Both the ASM and the database instances require shared access to the disks in an ASM</span></p><p class="c0"><span class="c1">disk group. ASM instances manage the metadata of the disk group and provide file</span></p><p class="c0"><span class="c1">layout information to the database instances. Database instances direct I/O to ASM</span></p><p class="c0"><span class="c1">disks without going through an ASM instance.</span></p><p class="c0"><span class="c1">An ASM instance is built on the same technology as a database instance. For example,</span></p><p class="c0"><span class="c1">an ASM instance has a system global area (SGA) and background processes that are</span></p><p class="c0"><span class="c1">similar to those of a database instance. However, an ASM instance cannot mount a</span></p><p class="c0"><span class="c1">database and performs fewer tasks than a database instance.</span></p><p class="c0"><span class="c1">Figure 11&ndash;3 shows a single-node configuration with one Oracle ASM instance and two</span></p><p class="c0"><span class="c1">database instances, each associated with a different single-instance database. The ASM</span></p><p class="c0"><span class="c1">instance manages the metadata and provides space allocation for the ASM files storing</span></p><p class="c0"><span class="c1">the data for the two databases. One ASM disk group has four ASM disks and the other</span></p><p class="c0"><span class="c1">has two disks. Both database instances can access the disk groups.</span></p><p class="c0"><span class="c1">Note: An Oracle ASM extent is different from the extent used to</span></p><p class="c0"><span class="c1">store data in a segment.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database 2 Day DBA to learn how to administer Oracle</span></p><p class="c0"><span class="c1">ASM disks with Oracle Enterprise Manager (Enterprise</span></p><p class="c0"><span class="c1">Manager)</span></p><p class="c0"><span class="c1">&#9632; Oracle Automatic Storage Management Administrator&#39;s Guide to</span></p><p class="c0"><span class="c1">learn more about Oracle ASMIntroduction to Physical Storage Structures</span></p><p class="c0"><span class="c1">11-6 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Figure 11&ndash;3 Oracle ASM Instance and Database Instances</span></p><p class="c0"><span class="c1">Oracle Managed Files and User-Managed Files</span></p><p class="c0"><span class="c1">Oracle Managed Files is a file naming strategy that enables you to specify operations</span></p><p class="c0"><span class="c1">in terms of database objects rather than file names. For example, you can create a</span></p><p class="c0"><span class="c1">tablespace without specifying the names of its data files. In this way, Oracle Managed</span></p><p class="c0"><span class="c1">Files eliminates the need for administrators to directly manage the operating system</span></p><p class="c0"><span class="c1">files in a database. Oracle ASM requires Oracle Managed Files.</span></p><p class="c0"><span class="c1">With user-managed files, you directly manage the operating system files in the</span></p><p class="c0"><span class="c1">database. You make the decisions regarding file structure and naming. For example,</span></p><p class="c0"><span class="c1">when you create a tablespace you set the name and path of the tablespace data files.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database 2 Day DBA to learn how to administer Oracle</span></p><p class="c0"><span class="c1">ASM disks with Oracle Enterprise Manager (Enterprise</span></p><p class="c0"><span class="c1">Manager)</span></p><p class="c0"><span class="c1">&#9632; Oracle Automatic Storage Management Administrator&#39;s Guide to</span></p><p class="c0"><span class="c1">learn more about Oracle ASM</span></p><p class="c0"><span class="c1">Note: This feature does not affect the creation or naming of</span></p><p class="c0"><span class="c1">administrative files such as trace files, audit files, and alert logs (see</span></p><p class="c0"><span class="c1">&quot;Overview of Diagnostic Files&quot; on page 13-18).</span></p><p class="c0"><span class="c1">Disk Group B</span></p><p class="c0"><span class="c1">Oracle</span></p><p class="c0"><span class="c1">Recovery</span></p><p class="c0"><span class="c1">Catalog</span></p><p class="c0"><span class="c1">Oracle</span></p><p class="c0"><span class="c1">Recovery</span></p><p class="c0"><span class="c1">Catalog</span></p><p class="c0"><span class="c1">Oracle</span></p><p class="c0"><span class="c1">Recovery</span></p><p class="c0"><span class="c1">Catalog</span></p><p class="c0"><span class="c1">Oracle</span></p><p class="c0"><span class="c1">Recovery</span></p><p class="c0"><span class="c1">Catalog</span></p><p class="c0"><span class="c1">Oracle</span></p><p class="c0"><span class="c1">Recovery</span></p><p class="c0"><span class="c1">Catalog</span></p><p class="c0"><span class="c1">Oracle</span></p><p class="c0"><span class="c1">Recovery</span></p><p class="c0"><span class="c1">Catalog</span></p><p class="c0"><span class="c1">Disk Group A</span></p><p class="c0"><span class="c1">Metadata</span></p><p class="c0"><span class="c1">Requests</span></p><p class="c0"><span class="c1">ASM</span></p><p class="c0"><span class="c1">Instance</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">Instance</span></p><p class="c0"><span class="c1">DB1</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">Instance</span></p><p class="c0"><span class="c1">DB2</span></p><p class="c0"><span class="c1">ASM Disk Groups</span></p><p class="c0"><span class="c1">I/O I/OOverview of Data Files</span></p><p class="c0"><span class="c1">Physical Storage Structures 11-7</span></p><p class="c0"><span class="c1">Through initialization parameters, you specify the file system directory for a specific</span></p><p class="c0"><span class="c1">type of file. The Oracle Managed Files feature ensures that the database creates a</span></p><p class="c0"><span class="c1">unique file and deletes it when no longer needed. The database internally uses</span></p><p class="c0"><span class="c1">standard file system interfaces to create and delete files for data files and temp files,</span></p><p class="c0"><span class="c1">control files, and recovery-related files stored in the fast recovery area.</span></p><p class="c0"><span class="c1">Oracle Managed Files does not eliminate existing functionality. You can create new</span></p><p class="c0"><span class="c1">files while manually administering old files. Thus, a database can have a mixture of</span></p><p class="c0"><span class="c1">Oracle Managed Files and user-managed files.</span></p><p class="c0"><span class="c1">Overview of Data Files</span></p><p class="c0"><span class="c1">At the operating system level, Oracle Database stores database data in data files.</span></p><p class="c0"><span class="c1">Every database must have at least one data file.</span></p><p class="c0"><span class="c1">Use of Data Files</span></p><p class="c0"><span class="c1">Part I, &quot;Oracle Relational Data Structures&quot; explains the logical structures in which</span></p><p class="c0"><span class="c1">users store data, the most important of which are tables. Each nonpartitioned schema</span></p><p class="c0"><span class="c1">object and each partition of an object is stored in its own segment.</span></p><p class="c0"><span class="c1">For ease of administration, Oracle Database allocates space for user data in</span></p><p class="c0"><span class="c1">tablespaces, which like segments are logical storage structures. Each segment belongs</span></p><p class="c0"><span class="c1">to only one tablespace. For example, the data for a nonpartitioned table is stored in a</span></p><p class="c0"><span class="c1">single segment, which is turn is stored in one tablespace.</span></p><p class="c0"><span class="c1">Oracle Database physically stores tablespace data in data files. Tablespaces and data</span></p><p class="c0"><span class="c1">files are closely related, but have important differences:</span></p><p class="c0"><span class="c1">&#9632; Each tablespace consists of one or more data files, which conform to the operating</span></p><p class="c0"><span class="c1">system in which Oracle Database is running.</span></p><p class="c0"><span class="c1">&#9632; The data for a database is collectively stored in the data files located in each</span></p><p class="c0"><span class="c1">tablespace of the database.</span></p><p class="c0"><span class="c1">&#9632; A segment can span one or more data files, but it cannot span multiple</span></p><p class="c0"><span class="c1">tablespaces.</span></p><p class="c0"><span class="c1">&#9632; A database must have the SYSTEM and SYSAUX tablespaces. Oracle Database</span></p><p class="c0"><span class="c1">automatically allocates the first data files of any database for the SYSTEM tablespace</span></p><p class="c0"><span class="c1">during database creation.</span></p><p class="c0"><span class="c1">The SYSTEM tablespace contains the data dictionary, a set of tables that contains</span></p><p class="c0"><span class="c1">database metadata. Typically, a database also has an undo tablespace and a</span></p><p class="c0"><span class="c1">temporary tablespace (usually named TEMP).</span></p><p class="c0"><span class="c1">Figure 11&ndash;4 shows the relationship between tablespaces, data files, and segments.</span></p><p class="c0"><span class="c1">See Also: Oracle Database Administrator&#39;s Guide to learn how to</span></p><p class="c0"><span class="c1">use Oracle Managed FilesOverview of Data Files</span></p><p class="c0"><span class="c1">11-8 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Figure 11&ndash;4 Data Files and Tablespaces</span></p><p class="c0"><span class="c1">Permanent and Temporary Data Files</span></p><p class="c0"><span class="c1">A permanent tablespace contains persistent schema objects. Objects in permanent</span></p><p class="c0"><span class="c1">tablespaces are stored in data files.</span></p><p class="c0"><span class="c1">A temporary tablespace contains schema objects only for the duration of a session.</span></p><p class="c0"><span class="c1">Locally managed temporary tablespaces have temporary files (temp files), which are</span></p><p class="c0"><span class="c1">special files designed to store data in hash, sort, and other operations. Temp files also</span></p><p class="c0"><span class="c1">store result set data when insufficient space exists in memory.</span></p><p class="c0"><span class="c1">Temp files are similar to permanent data files, with the following exceptions:</span></p><p class="c0"><span class="c1">&#9632; Permanent database objects such as tables are never stored in temp files.</span></p><p class="c0"><span class="c1">&#9632; Temp files are always set to NOLOGGING mode, which means that they never have</span></p><p class="c0"><span class="c1">redo generated for them. Media recovery does not recognize temp files.</span></p><p class="c0"><span class="c1">&#9632; You cannot make a temp file read-only.</span></p><p class="c0"><span class="c1">&#9632; You cannot create a temp file with the ALTER DATABASE statement.</span></p><p class="c0"><span class="c1">&#9632; When you create or resize temp files, they are not always guaranteed allocation of</span></p><p class="c0"><span class="c1">disk space for the file size specified. On file systems such as Linux and UNIX,</span></p><p class="c0"><span class="c1">temp files are created as sparse files. In this case, disk blocks are allocated not at</span></p><p class="c0"><span class="c1">file creation or resizing, but as the blocks are accessed for the first time.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Overview of Tablespaces&quot; on page 12-30</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide and Oracle Database 2 Day</span></p><p class="c0"><span class="c1">DBA to learn how to manage data files</span></p><p class="c0"><span class="c1">Tablespace</span></p><p class="c0"><span class="c1">(one or more data files)</span></p><p class="c0"><span class="c1">Table</span></p><p class="c0"><span class="c1">Index</span></p><p class="c0"><span class="c1">Index</span></p><p class="c0"><span class="c1">Index</span></p><p class="c0"><span class="c1">Index</span></p><p class="c0"><span class="c1">Index</span></p><p class="c0"><span class="c1">Index</span></p><p class="c0"><span class="c1">Index</span></p><p class="c0"><span class="c1">Table</span></p><p class="c0"><span class="c1">Table</span></p><p class="c0"><span class="c1">Index</span></p><p class="c0"><span class="c1">Index</span></p><p class="c0"><span class="c1">Index</span></p><p class="c0"><span class="c1">Data Files</span></p><p class="c0"><span class="c1">(physical structures associated</span></p><p class="c0"><span class="c1">with only one tablespace)</span></p><p class="c0"><span class="c1">Segments</span></p><p class="c0"><span class="c1">(stored in tablespacesmay span several data files)Overview of Data Files</span></p><p class="c0"><span class="c1">Physical Storage Structures 11-9</span></p><p class="c0"><span class="c1">&#9632; Temp file information is shown in the data dictionary view DBA_TEMP_FILES and</span></p><p class="c0"><span class="c1">the dynamic performance view V$TEMPFILE, but not in DBA_DATA_FILES or the</span></p><p class="c0"><span class="c1">V$DATAFILE view.</span></p><p class="c0"><span class="c1">Online and Offline Data Files</span></p><p class="c0"><span class="c1">Every data file is either online (available) or offline (unavailable). You can alter the</span></p><p class="c0"><span class="c1">availability of individual data files or temp files by taking them offline or bringing</span></p><p class="c0"><span class="c1">them online. Offline data files cannot be accessed until they are brought back online.</span></p><p class="c0"><span class="c1">Administrators may take data files offline for many reasons, including performing</span></p><p class="c0"><span class="c1">offline backups, renaming a data file, or block corruption. The database takes a data</span></p><p class="c0"><span class="c1">file offline automatically if the database cannot write to it.</span></p><p class="c0"><span class="c1">Like a data file, a tablespace itself is offline or online. When you take a data file offline</span></p><p class="c0"><span class="c1">in an online tablespace, the tablespace itself remains online. You can make all data files</span></p><p class="c0"><span class="c1">of a tablespace temporarily unavailable by taking the tablespace itself offline</span></p><p class="c0"><span class="c1">Data File Structure</span></p><p class="c0"><span class="c1">Oracle Database creates a data file for a tablespace by allocating the specified amount</span></p><p class="c0"><span class="c1">of disk space plus the overhead for the data file header. The operating system under</span></p><p class="c0"><span class="c1">which Oracle Database runs is responsible for clearing old information and</span></p><p class="c0"><span class="c1">authorizations from a file before allocating it to the database.</span></p><p class="c0"><span class="c1">The data file header contains metadata about the data file such as its size and</span></p><p class="c0"><span class="c1">checkpoint SCN. Each header contains an absolute file number and a relative file</span></p><p class="c0"><span class="c1">number. The absolute file number uniquely identifies the data file within the database.</span></p><p class="c0"><span class="c1">The relative file number uniquely identifies a data file within a tablespace.</span></p><p class="c0"><span class="c1">When Oracle Database first creates a data file, the allocated disk space is formatted but</span></p><p class="c0"><span class="c1">contains no user data. However, the database reserves the space to hold the data for</span></p><p class="c0"><span class="c1">future segments of the associated tablespace. As the data grows in a tablespace, Oracle</span></p><p class="c0"><span class="c1">Database uses the free space in the data files to allocate extents for the segment.</span></p><p class="c0"><span class="c1">Figure 11&ndash;5 illustrates the different types of space in a data file. Extents are either used,</span></p><p class="c0"><span class="c1">which means they contain segment data, or free, which means they are available for</span></p><p class="c0"><span class="c1">reuse. Over time, updates and deletions of objects within a tablespace can create</span></p><p class="c0"><span class="c1">pockets of empty space that individually are not large enough to be reused for new</span></p><p class="c0"><span class="c1">data. This type of empty space is referred to as fragmented free space.</span></p><p class="c0"><span class="c1">Caution: Sparse files enable fast temp file creation and resizing;</span></p><p class="c0"><span class="c1">however, the disk could run out of space later when the temp files are</span></p><p class="c0"><span class="c1">accessed.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Temporary Tablespaces&quot; on page 12-34</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn how to manage temp</span></p><p class="c0"><span class="c1">files</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Online and Offline Tablespaces&quot; on page 12-35</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn how to alter data file</span></p><p class="c0"><span class="c1">availabilityOverview of Control Files</span></p><p class="c0"><span class="c1">11-10 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Figure 11&ndash;5 Space in a Data File</span></p><p class="c0"><span class="c1">Overview of Control Files</span></p><p class="c0"><span class="c1">The database control file is a small binary file associated with only one database. Each</span></p><p class="c0"><span class="c1">database has one unique control file, although it may maintain identical copies of it.</span></p><p class="c0"><span class="c1">Use of Control Files</span></p><p class="c0"><span class="c1">The control file is the root file that Oracle Database uses to find database files and to</span></p><p class="c0"><span class="c1">manage the state of the database generally. A control file contains information such as</span></p><p class="c0"><span class="c1">the following:</span></p><p class="c0"><span class="c1">&#9632; The database name and database unique identifier (DBID)</span></p><p class="c0"><span class="c1">&#9632; The time stamp of database creation</span></p><p class="c0"><span class="c1">&#9632; Information about data files, online redo log files, and archived redo log files</span></p><p class="c0"><span class="c1">&#9632; Tablespace information</span></p><p class="c0"><span class="c1">&#9632; RMAN backups</span></p><p class="c0"><span class="c1">The control file serves the following purposes:</span></p><p class="c0"><span class="c1">&#9632; It contains information about data files, online redo log files, and so on that are</span></p><p class="c0"><span class="c1">required to open the database.</span></p><p class="c0"><span class="c1">The control file tracks structural changes to the database. For example, when an</span></p><p class="c0"><span class="c1">administrator adds, renames, or drops a data file or online redo log file, the</span></p><p class="c0"><span class="c1">database updates the control file to reflect this change.</span></p><p class="c0"><span class="c1">&#9632; It contains metadata that must be accessible when the database is not open.</span></p><p class="c0"><span class="c1">For example, the control file contains information required to recover the database,</span></p><p class="c0"><span class="c1">including checkpoints. A checkpoint indicates the SCN in the redo stream where</span></p><p class="c0"><span class="c1">instance recovery would be required to begin (see &quot;Overview of Instance</span></p><p class="c0"><span class="c1">Recovery&quot; on page 13-12). Every committed change before a checkpoint SCN is</span></p><p class="c0"><span class="c1">guaranteed to be saved on disk in the data files. At least every three seconds the</span></p><p class="c0"><span class="c1">checkpoint process records information in the control file about the checkpoint</span></p><p class="c0"><span class="c1">position in the online redo log.</span></p><p class="c0"><span class="c1">Oracle Database reads and writes to the control file continuously during database use</span></p><p class="c0"><span class="c1">and must be available for writing whenever the database is open. For example,</span></p><p class="c0"><span class="c1">recovering a database involves reading from the control file the names of all the data</span></p><p class="c0"><span class="c1">See Also: Oracle Database 2 Day DBA and Oracle Database</span></p><p class="c0"><span class="c1">Administrator&#39;s Guide to learn how to view data file information</span></p><p class="c0"><span class="c1">Data File Header</span></p><p class="c0"><span class="c1">Used</span></p><p class="c0"><span class="c1">Free (Formatted, Never Used)</span></p><p class="c0"><span class="c1">Free (Previously Used, Currently Unused)Overview of Control Files</span></p><p class="c0"><span class="c1">Physical Storage Structures 11-11</span></p><p class="c0"><span class="c1">files contained in the database. Other operations, such as adding a data file, update the</span></p><p class="c0"><span class="c1">information stored in the control file.</span></p><p class="c0"><span class="c1">Multiple Control Files</span></p><p class="c0"><span class="c1">Oracle Database enables multiple, identical control files to be open concurrently and</span></p><p class="c0"><span class="c1">written for the same database. By multiplexing a control file on different disks, the</span></p><p class="c0"><span class="c1">database can achieve redundancy and thereby avoid a single point of failure.</span></p><p class="c0"><span class="c1">If a control file becomes unusable, then the database instance fails when it attempts to</span></p><p class="c0"><span class="c1">access the damaged control file. When other current control file copies exist, the</span></p><p class="c0"><span class="c1">database can be remounted and opened without media recovery. If all control files of a</span></p><p class="c0"><span class="c1">database are lost, however, then the instance fails and media recovery is required.</span></p><p class="c0"><span class="c1">Media recovery is not straightforward if an older backup of a control file must be used</span></p><p class="c0"><span class="c1">because a current copy is not available.</span></p><p class="c0"><span class="c1">Control File Structure</span></p><p class="c0"><span class="c1">Information about the database is stored in different sections of the control file. Each</span></p><p class="c0"><span class="c1">section is a set of records about an aspect of the database. For example, one section in</span></p><p class="c0"><span class="c1">the control file tracks data files and contains a set of records, one for each data file.</span></p><p class="c0"><span class="c1">Each section is stored in multiple logical control file blocks. Records can span blocks</span></p><p class="c0"><span class="c1">within a section.</span></p><p class="c0"><span class="c1">The control file contains the following types of records:</span></p><p class="c0"><span class="c1">&#9632; Circular reuse records</span></p><p class="c0"><span class="c1">These records contain noncritical information that is eligible to be overwritten if</span></p><p class="c0"><span class="c1">needed. When all available record slots are full, the database either expands the</span></p><p class="c0"><span class="c1">control file to make room for a new record or overwrites the oldest record.</span></p><p class="c0"><span class="c1">Examples include records about archived redo log files and RMAN backups.</span></p><p class="c0"><span class="c1">&#9632; Noncircular reuse records</span></p><p class="c0"><span class="c1">These records contain critical information that does not change often and cannot</span></p><p class="c0"><span class="c1">be overwritten. Examples of information include tablespaces, data files, online</span></p><p class="c0"><span class="c1">redo log files, and redo threads. Oracle Database never reuses these records unless</span></p><p class="c0"><span class="c1">the corresponding object is dropped from the tablespace.</span></p><p class="c0"><span class="c1">As explained in &quot;Overview of the Dynamic Performance Views&quot; on page 6-5, you can</span></p><p class="c0"><span class="c1">query the dynamic performance views, also known as V$ views, to view the</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Checkpoint Process (CKPT)&quot; on page 15-10</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn how to manage the</span></p><p class="c0"><span class="c1">control file</span></p><p class="c0"><span class="c1">Note: Oracle recommends that you maintain multiple control file</span></p><p class="c0"><span class="c1">copies, each on a different disk.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn how to maintain</span></p><p class="c0"><span class="c1">multiple control files</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Backup and Recovery User&#39;s Guide to learn how to</span></p><p class="c0"><span class="c1">back up and restore control filesOverview of the Online Redo Log</span></p><p class="c0"><span class="c1">11-12 Oracle Database Concepts</span></p><p class="c0"><span class="c1">information stored in the control file. For example, you can query V$DATABASE to</span></p><p class="c0"><span class="c1">obtain the database name and DBID. However, only the database can modify the</span></p><p class="c0"><span class="c1">information in the control file.</span></p><p class="c0"><span class="c1">Reading and writing the control file blocks is different from reading and writing data</span></p><p class="c0"><span class="c1">blocks. For the control file, Oracle Database reads and writes directly from the disk to</span></p><p class="c0"><span class="c1">the program global area (PGA). Each process allocates a certain amount of its PGA</span></p><p class="c0"><span class="c1">memory for control file blocks.</span></p><p class="c0"><span class="c1">Overview of the Online Redo Log</span></p><p class="c0"><span class="c1">The most crucial structure for recovery is the online redo log, which consists of two or</span></p><p class="c0"><span class="c1">more preallocated files that store changes to the database as they occur. The online</span></p><p class="c0"><span class="c1">redo log records changes to the data files.</span></p><p class="c0"><span class="c1">Use of the Online Redo Log</span></p><p class="c0"><span class="c1">The database maintains online redo log files to protect against data loss. Specifically,</span></p><p class="c0"><span class="c1">after an instance failure the online redo log files enable Oracle Database to recover</span></p><p class="c0"><span class="c1">committed data not yet written to the data files.</span></p><p class="c0"><span class="c1">Oracle Database writes every transaction synchronously to the redo log buffer, which</span></p><p class="c0"><span class="c1">is then written to the online redo logs. The contents of the log include uncommitted</span></p><p class="c0"><span class="c1">transactions, undo data, and schema and object management statements.</span></p><p class="c0"><span class="c1">Oracle Database uses the online redo log only for recovery. However, administrators</span></p><p class="c0"><span class="c1">can query online redo log files through a SQL interface in the Oracle LogMiner utility</span></p><p class="c0"><span class="c1">(see &quot;Oracle LogMiner&quot; on page 18-8). Redo log files are a useful source of historical</span></p><p class="c0"><span class="c1">information about database activity.</span></p><p class="c0"><span class="c1">How Oracle Database Writes to the Online Redo Log</span></p><p class="c0"><span class="c1">The online redo log for a database instance is called a redo thread. In single-instance</span></p><p class="c0"><span class="c1">configurations, only one instance accesses a database, so only one redo thread is</span></p><p class="c0"><span class="c1">present. In an Oracle Real Application Clusters (Oracle RAC) configuration, however,</span></p><p class="c0"><span class="c1">two or more instances concurrently access a database, with each instance having its</span></p><p class="c0"><span class="c1">own redo thread. A separate redo thread for each instance avoids contention for a</span></p><p class="c0"><span class="c1">single set of online redo log files.</span></p><p class="c0"><span class="c1">An online redo log consists of two or more online redo log files. Oracle Database</span></p><p class="c0"><span class="c1">requires a minimum of two files to guarantee that one is always available for writing</span></p><p class="c0"><span class="c1">while the other is being archived (if the database is in ARCHIVELOG mode).</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Reference to learn about the</span></p><p class="c0"><span class="c1">V$CONTROLFILE_RECORD_SECTION view</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Reference to learn about the</span></p><p class="c0"><span class="c1">CONTROL_FILE_RECORD_KEEP_TIME initialization parameter</span></p><p class="c0"><span class="c1">See Also: &quot;Overview of Instance Recovery&quot; on page 13-12</span></p><p class="c0"><span class="c1">See Also: Oracle Database 2 Day + Real Application Clusters Guide and</span></p><p class="c0"><span class="c1">Oracle Real Application Clusters Administration and Deployment Guide to</span></p><p class="c0"><span class="c1">learn about online redo log groups in Oracle RACOverview of the Online Redo Log</span></p><p class="c0"><span class="c1">Physical Storage Structures 11-13</span></p><p class="c0"><span class="c1">Online Redo Log Switches</span></p><p class="c0"><span class="c1">Oracle Database uses only one online redo log file at a time to store records written</span></p><p class="c0"><span class="c1">from the redo log buffer. The online redo log file to which the log writer (LGWR)</span></p><p class="c0"><span class="c1">process is actively writing is called the current online redo log file.</span></p><p class="c0"><span class="c1">A log switch occurs when the database stops writing to one online redo log file and</span></p><p class="c0"><span class="c1">begins writing to another. Normally, a switch occurs when the current online redo log</span></p><p class="c0"><span class="c1">file is full and writing must continue. However, you can configure log switches to</span></p><p class="c0"><span class="c1">occur at regular intervals, regardless of whether the current online redo log file is</span></p><p class="c0"><span class="c1">filled, and force log switches manually.</span></p><p class="c0"><span class="c1">Log writer writes to online redo log files circularly. When log writer fills the last</span></p><p class="c0"><span class="c1">available online redo log file, the process writes to the first log file, restarting the cycle.</span></p><p class="c0"><span class="c1">Figure 11&ndash;6 illustrates the circular writing of the redo log.</span></p><p class="c0"><span class="c1">Figure 11&ndash;6 Reuse of Online Redo Log Files</span></p><p class="c0"><span class="c1">The numbers in Figure 11&ndash;6 shows the sequence in which LGWR writes to each online</span></p><p class="c0"><span class="c1">redo log file. The database assigns each file a new log sequence number when a log</span></p><p class="c0"><span class="c1">switches and log writers begins writing to it. When the database reuses an online redo</span></p><p class="c0"><span class="c1">log file, this file receives the next available log sequence number.</span></p><p class="c0"><span class="c1">Filled online redo log files are available for reuse depending on the archiving mode:</span></p><p class="c0"><span class="c1">&#9632; If archiving is disabled, which means that the database is in NOARCHIVELOG mode,</span></p><p class="c0"><span class="c1">then a filled online redo log file is available after the changes recorded in it have</span></p><p class="c0"><span class="c1">been checkpointed (written) to disk by database writer (DBW).</span></p><p class="c0"><span class="c1">&#9632; If archiving is enabled, which means that the database is in ARCHIVELOG mode,</span></p><p class="c0"><span class="c1">then a filled online redo log file is available to log writer after the changes have</span></p><p class="c0"><span class="c1">been written to the data files and the file has been archived.</span></p><p class="c0"><span class="c1">In some circumstances, log writer may be prevented from reusing an existing online</span></p><p class="c0"><span class="c1">redo log file. For example, an online redo log file may be active (required for instance</span></p><p class="c0"><span class="c1">LGWR</span></p><p class="c0"><span class="c1">1, 4, 7, ...</span></p><p class="c0"><span class="c1">3, 6, 9, ...</span></p><p class="c0"><span class="c1">2, 5, 8, ...</span></p><p class="c0"><span class="c1">Online Redo</span></p><p class="c0"><span class="c1">Log File</span></p><p class="c0"><span class="c1">#3</span></p><p class="c0"><span class="c1">Online Redo</span></p><p class="c0"><span class="c1">Log File</span></p><p class="c0"><span class="c1">#2</span></p><p class="c0"><span class="c1">Online Redo</span></p><p class="c0"><span class="c1">Log File</span></p><p class="c0"><span class="c1">#1Overview of the Online Redo Log</span></p><p class="c0"><span class="c1">11-14 Oracle Database Concepts</span></p><p class="c0"><span class="c1">recovery) rather than inactive (not required for instance recovery). Also, an online</span></p><p class="c0"><span class="c1">redo log file may be in the process of being cleared.</span></p><p class="c0"><span class="c1">Multiple Copies of Online Redo Log Files</span></p><p class="c0"><span class="c1">Oracle Database can automatically maintain two or more identical copies of the online</span></p><p class="c0"><span class="c1">redo log in separate locations. An online redo log group consists of an online redo log</span></p><p class="c0"><span class="c1">file and its redundant copies. Each identical copy is a member of the online redo log</span></p><p class="c0"><span class="c1">group. Each group is defined by a number, such as group 1, group 2, and so on.</span></p><p class="c0"><span class="c1">Maintaining multiple members of an online redo log group protects against the loss of</span></p><p class="c0"><span class="c1">the redo log. Ideally, the locations of the members should be on separate disks so that</span></p><p class="c0"><span class="c1">the failure of one disk does not cause the loss of the entire online redo log.</span></p><p class="c0"><span class="c1">In Figure 11&ndash;7, A_LOG1 and B_LOG1 are identical members of group 1, while A_LOG2 and</span></p><p class="c0"><span class="c1">B_LOG2 are identical members of group 2. Each member in a group must be the same</span></p><p class="c0"><span class="c1">size. LGWR writes concurrently to group 1 (members A_LOG1 and B_LOG1), then writes</span></p><p class="c0"><span class="c1">concurrently to group 2 (members A_LOG2 and B_LOG2), then writes to group 1, and so</span></p><p class="c0"><span class="c1">on. LGWR never writes concurrently to members of different groups.</span></p><p class="c0"><span class="c1">Figure 11&ndash;7 Multiple Copies of Online Redo Log Files</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Overview of Background Processes&quot; on page 15-7</span></p><p class="c0"><span class="c1">&#9632; Oracle Database 2 Day DBA and Oracle Database Administrator&#39;s</span></p><p class="c0"><span class="c1">Guide to learn how to manage the online redo log</span></p><p class="c0"><span class="c1">Note: Oracle recommends that you multiplex the online redo log.</span></p><p class="c0"><span class="c1">The loss of log files can be catastrophic if recovery is required.</span></p><p class="c0"><span class="c1">When you multiplex the online redo log, the database must</span></p><p class="c0"><span class="c1">increase the amount of I/O it performs. Depending on your system,</span></p><p class="c0"><span class="c1">this additional I/O may impact overall database performance.</span></p><p class="c0"><span class="c1">Disk A Disk B</span></p><p class="c0"><span class="c1">1, 3, 5, ...</span></p><p class="c0"><span class="c1">2, 4, 6, ...</span></p><p class="c0"><span class="c1">LGWR</span></p><p class="c0"><span class="c1">Group 1</span></p><p class="c0"><span class="c1">Members</span></p><p class="c0"><span class="c1">Group 2</span></p><p class="c0"><span class="c1">Members</span></p><p class="c0"><span class="c1">redo01a.log</span></p><p class="c0"><span class="c1">redo02a.log</span></p><p class="c0"><span class="c1">redo01b.log</span></p><p class="c0"><span class="c1">redo02b.log</span></p><p class="c0"><span class="c1">System Global Area (SGA)</span></p><p class="c0"><span class="c1">Redo</span></p><p class="c0"><span class="c1">Log</span></p><p class="c0"><span class="c1">BufferOverview of the Online Redo Log</span></p><p class="c0"><span class="c1">Physical Storage Structures 11-15</span></p><p class="c0"><span class="c1">Archived Redo Log Files</span></p><p class="c0"><span class="c1">An archived redo log file is a copy of a filled member of an online redo log group.</span></p><p class="c0"><span class="c1">This file is not considered part of the database, but is an offline copy of an online redo</span></p><p class="c0"><span class="c1">log file created by the database and written to a user-specified location.</span></p><p class="c0"><span class="c1">Archived redo log files are a crucial part of a backup and recovery strategy. You can</span></p><p class="c0"><span class="c1">use archived redo log files to:</span></p><p class="c0"><span class="c1">&#9632; Recover a database backup</span></p><p class="c0"><span class="c1">&#9632; Update a standby database (see &quot;Computer Failures&quot; on page 17-8)</span></p><p class="c0"><span class="c1">&#9632; Obtain information about the history of a database using the LogMiner utility (see</span></p><p class="c0"><span class="c1">&quot;Oracle LogMiner&quot; on page 18-8)</span></p><p class="c0"><span class="c1">Archiving is the operation of generating an archived redo log file. Archiving is either</span></p><p class="c0"><span class="c1">automatic or manual and is only possible when the database is in ARCHIVELOG mode.</span></p><p class="c0"><span class="c1">An archived redo log file includes the redo entries and the log sequence number of the</span></p><p class="c0"><span class="c1">identical member of the online redo log group. In Figure 11&ndash;7, files A_LOG1 and B_LOG1</span></p><p class="c0"><span class="c1">are identical members of Group 1. If the database is in ARCHIVELOG mode, and if</span></p><p class="c0"><span class="c1">automatic archiving is enabled, then the archiver process (ARCn) will archive one of</span></p><p class="c0"><span class="c1">these files. If A_LOG1 is corrupted, then the process can archive B_LOG1. The archived</span></p><p class="c0"><span class="c1">redo log contains a copy of every group created since you enabled archiving.</span></p><p class="c0"><span class="c1">Structure of the Online Redo Log</span></p><p class="c0"><span class="c1">Online redo log files contain redo records. A redo record is made up of a group of</span></p><p class="c0"><span class="c1">change vectors, each of which describes a change to a data block. For example, an</span></p><p class="c0"><span class="c1">update to a salary in the employees table generates a redo record that describes</span></p><p class="c0"><span class="c1">changes to the data segment block for the table, the undo segment data block, and the</span></p><p class="c0"><span class="c1">transaction table of the undo segments.</span></p><p class="c0"><span class="c1">The redo records have all relevant metadata for the change, including the following:</span></p><p class="c0"><span class="c1">&#9632; SCN and time stamp of the change</span></p><p class="c0"><span class="c1">&#9632; Transaction ID of the transaction that generated the change</span></p><p class="c0"><span class="c1">&#9632; SCN and time stamp when the transaction committed (if it committed)</span></p><p class="c0"><span class="c1">&#9632; Type of operation that made the change</span></p><p class="c0"><span class="c1">&#9632; Name and type of the modified data segment</span></p><p class="c0"><span class="c1">See Also: Oracle Database Administrator&#39;s Guide to learn how to</span></p><p class="c0"><span class="c1">maintain multiple copies of the online redo log files</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Data File Recovery&quot; on page 18-14</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn how to manage the</span></p><p class="c0"><span class="c1">archived redo log</span></p><p class="c0"><span class="c1">See Also: &quot;Overview of Data Blocks&quot; on page 12-6Overview of the Online Redo Log</span></p><p class="c0"><span class="c1">11-16 Oracle Database Concepts12</span></p><p class="c0"><span class="c1">Logical Storage Structures 12-1</span></p><p class="c0"><span class="c1">Logical Storage Structures 2 1</span></p><p class="c0"><span class="c1">This chapter describes the nature of and relationships among logical storage</span></p><p class="c0"><span class="c1">structures. These structures are created and recognized by Oracle Database and are not</span></p><p class="c0"><span class="c1">known to the operating system.</span></p><p class="c0"><span class="c1">This chapter contains the following sections:</span></p><p class="c0"><span class="c1">&#9632; Introduction to Logical Storage Structures</span></p><p class="c0"><span class="c1">&#9632; Overview of Data Blocks</span></p><p class="c0"><span class="c1">&#9632; Overview of Extents</span></p><p class="c0"><span class="c1">&#9632; Overview of Segments</span></p><p class="c0"><span class="c1">&#9632; Overview of Tablespaces</span></p><p class="c0"><span class="c1">Introduction to Logical Storage Structures</span></p><p class="c0"><span class="c1">Oracle Database allocates logical space for all data in the database. The logical units of</span></p><p class="c0"><span class="c1">database space allocation are data blocks, extents, segments, and tablespaces. At a</span></p><p class="c0"><span class="c1">physical level, the data is stored in data files on disk (see Chapter 11, &quot;Physical Storage</span></p><p class="c0"><span class="c1">Structures&quot;). The data in the data files is stored in operating system blocks.</span></p><p class="c0"><span class="c1">Figure 12&ndash;1 is an entity-relationship diagram for physical and logical storage. The</span></p><p class="c0"><span class="c1">crow&#39;s foot notation represents a one-to-many relationship.</span></p><p class="c0"><span class="c1">Figure 12&ndash;1 Logical and Physical Storage</span></p><p class="c0"><span class="c1">Oracle data</span></p><p class="c0"><span class="c1">block</span></p><p class="c0"><span class="c1">Extent</span></p><p class="c0"><span class="c1">Segment</span></p><p class="c0"><span class="c1">Tablespace</span></p><p class="c0"><span class="c1">OS block</span></p><p class="c0"><span class="c1">Data File</span></p><p class="c0"><span class="c1">Logical PhysicalIntroduction to Logical Storage Structures</span></p><p class="c0"><span class="c1">12-2 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Logical Storage Hierarchy</span></p><p class="c0"><span class="c1">Figure 12&ndash;2 shows the relationships among data blocks, extents, and segments within</span></p><p class="c0"><span class="c1">a tablespace. In this example, a segment has two extents stored in different data files.</span></p><p class="c0"><span class="c1">Figure 12&ndash;2 Segments, Extents, and Data Blocks Within a Tablespace</span></p><p class="c0"><span class="c1">At the finest level of granularity, Oracle Database stores data in data blocks. One</span></p><p class="c0"><span class="c1">logical data block corresponds to a specific number of bytes of physical disk space, for</span></p><p class="c0"><span class="c1">example, 2 KB. Data blocks are the smallest units of storage that Oracle Database can</span></p><p class="c0"><span class="c1">use or allocate.</span></p><p class="c0"><span class="c1">An extent is a set of logically contiguous data blocks allocated for storing a specific</span></p><p class="c0"><span class="c1">type of information. In Figure 12&ndash;2, the 24 KB extent has 12 data blocks, while the 72</span></p><p class="c0"><span class="c1">KB extent has 36 data blocks.</span></p><p class="c0"><span class="c1">A segment is a set of extents allocated for a specific database object, such as a table.</span></p><p class="c0"><span class="c1">For example, the data for the employees table is stored in its own data segment,</span></p><p class="c0"><span class="c1">whereas each index for employees is stored in its own index segment. Every database</span></p><p class="c0"><span class="c1">object that consumes storage consists of a single segment.</span></p><p class="c0"><span class="c1">Each segment belongs to one and only one tablespace. Thus, all extents for a segment</span></p><p class="c0"><span class="c1">are stored in the same tablespace. Within a tablespace, a segment can include extents</span></p><p class="c0"><span class="c1">from multiple data files, as shown in Figure 12&ndash;2. For example, one extent for a</span></p><p class="c0"><span class="c1">segment may be stored in users01.dbf, while another is stored in users02.dbf. A</span></p><p class="c0"><span class="c1">single extent can never span data files.</span></p><p class="c0"><span class="c1">Logical Space Management</span></p><p class="c0"><span class="c1">Oracle Database must use logical space management to track and allocate the extents</span></p><p class="c0"><span class="c1">in a tablespace. When a database object requires an extent, the database must have a</span></p><p class="c0"><span class="c1">method of finding and providing it. Similarly, when an object no longer requires an</span></p><p class="c0"><span class="c1">extent, the database must have a method of making the free extent available.</span></p><p class="c0"><span class="c1">Oracle Database manages space within a tablespace based on the type that you create.</span></p><p class="c0"><span class="c1">You can create either of the following types of tablespaces:</span></p><p class="c0"><span class="c1">See Also: &quot;Overview of Data Files&quot; on page 11-7</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">2 KB</span></p><p class="c0"><span class="c1">Data Blocks Data Blocks</span></p><p class="c0"><span class="c1">Extent</span></p><p class="c0"><span class="c1">72 KB</span></p><p class="c0"><span class="c1">Extent</span></p><p class="c0"><span class="c1">24 KB</span></p><p class="c0"><span class="c1">Data</span></p><p class="c0"><span class="c1">File</span></p><p class="c0"><span class="c1">Data</span></p><p class="c0"><span class="c1">File</span></p><p class="c0"><span class="c1">Segment</span></p><p class="c0"><span class="c1">96KbIntroduction to Logical Storage Structures</span></p><p class="c0"><span class="c1">Logical Storage Structures 12-3</span></p><p class="c0"><span class="c1">&#9632; Locally managed tablespaces (default)</span></p><p class="c0"><span class="c1">The database uses bitmaps in the tablespaces themselves to manage extents. Thus,</span></p><p class="c0"><span class="c1">locally managed tablespaces have a part of the tablespace set aside for a bitmap.</span></p><p class="c0"><span class="c1">Within a tablespace, the database can manage segments with automatic segment</span></p><p class="c0"><span class="c1">space management (ASSM) or manual segment space management (MSSM).</span></p><p class="c0"><span class="c1">&#9632; Dictionary-managed tablespaces</span></p><p class="c0"><span class="c1">The database uses the data dictionary to manage extents (see &quot;Overview of the</span></p><p class="c0"><span class="c1">Data Dictionary&quot; on page 6-1).</span></p><p class="c0"><span class="c1">Figure 12&ndash;3 shows the alternatives for logical space management in a tablespace.</span></p><p class="c0"><span class="c1">Figure 12&ndash;3 Logical Space Management</span></p><p class="c0"><span class="c1">Locally Managed Tablespaces</span></p><p class="c0"><span class="c1">A locally managed tablespace maintains a bitmap in the data file header to track free</span></p><p class="c0"><span class="c1">and used space in the data file body. Each bit corresponds to a group of blocks. When</span></p><p class="c0"><span class="c1">space is allocated or freed, Oracle Database changes the bitmap values to reflect the</span></p><p class="c0"><span class="c1">new status of the blocks.</span></p><p class="c0"><span class="c1">The following graphic is a conceptual representation of bitmap-managed storage. A 1</span></p><p class="c0"><span class="c1">in the header refers to used space, whereas a 0 refers to free space.</span></p><p class="c0"><span class="c1">A locally managed tablespace has the following advantages:</span></p><p class="c0"><span class="c1">Locally Managed Tablespace</span></p><p class="c0"><span class="c1">Dictionary-Managed Tablespace</span></p><p class="c0"><span class="c1">Automatic Segment Space Management</span></p><p class="c0"><span class="c1">Manual Segment Space Management</span></p><p class="c0"><span class="c1">1 0 0 1 0 1 . . .</span></p><p class="c0"><span class="c1">Used Space</span></p><p class="c0"><span class="c1">Free Space</span></p><p class="c0"><span class="c1">Data File Header</span></p><p class="c0"><span class="c1">Data File BodyIntroduction to Logical Storage Structures</span></p><p class="c0"><span class="c1">12-4 Oracle Database Concepts</span></p><p class="c0"><span class="c1">&#9632; Avoids using the data dictionary to manage extents</span></p><p class="c0"><span class="c1">Recursive operations can occur in dictionary-managed tablespaces if consuming or</span></p><p class="c0"><span class="c1">releasing space in an extent results in another operation that consumes or releases</span></p><p class="c0"><span class="c1">space in a data dictionary table or undo segment.</span></p><p class="c0"><span class="c1">&#9632; Tracks adjacent free space automatically</span></p><p class="c0"><span class="c1">In this way, the database eliminates the need to coalesce free extents.</span></p><p class="c0"><span class="c1">&#9632; Determines the size of locally managed extents automatically</span></p><p class="c0"><span class="c1">Alternatively, all extents can have the same size in a locally managed tablespace</span></p><p class="c0"><span class="c1">and override object storage options.</span></p><p class="c0"><span class="c1">Segment space management is an attribute inherited from the tablespace that contains</span></p><p class="c0"><span class="c1">the segment. Within a locally managed tablespace, the database can manage segments</span></p><p class="c0"><span class="c1">automatically or manually. For example, segments in tablespace users can be</span></p><p class="c0"><span class="c1">managed automatically while segments in tablespace tools are managed manually.</span></p><p class="c0"><span class="c1">Automatic Segment Space Management The ASSM method uses bitmaps to manage space.</span></p><p class="c0"><span class="c1">Bitmaps provide the following advantages:</span></p><p class="c0"><span class="c1">&#9632; Simplified administration</span></p><p class="c0"><span class="c1">ASSM avoids the need to manually determine correct settings for many storage</span></p><p class="c0"><span class="c1">parameters. Only one crucial SQL parameter controls space allocation: PCTFREE.</span></p><p class="c0"><span class="c1">This parameter specifies the percentage of space to be reserved in a block for</span></p><p class="c0"><span class="c1">future updates (see &quot;Percentage of Free Space in Data Blocks&quot; on page 12-12).</span></p><p class="c0"><span class="c1">&#9632; Increased concurrency</span></p><p class="c0"><span class="c1">Multiple transactions can search separate lists of free data blocks, thereby</span></p><p class="c0"><span class="c1">reducing contention and waits. For many standard workloads, application</span></p><p class="c0"><span class="c1">performance with ASSM is better than the performance of a well-tuned</span></p><p class="c0"><span class="c1">application that uses MSSM.</span></p><p class="c0"><span class="c1">&#9632; Dynamic affinity of space to instances in an Oracle Real Application Clusters</span></p><p class="c0"><span class="c1">(Oracle RAC) environment</span></p><p class="c0"><span class="c1">ASSM is more efficient and is the default for permanent, locally managed tablespaces.</span></p><p class="c0"><span class="c1">Manual Segment Space Management The legacy MSSM method uses a linked list called a</span></p><p class="c0"><span class="c1">free list to manage free space in the segment. For a database object that has free space,</span></p><p class="c0"><span class="c1">a free list keeps track of blocks under the high water mark (HWM), which is the</span></p><p class="c0"><span class="c1">dividing line between segment space that is used and not yet used. As blocks are used,</span></p><p class="c0"><span class="c1">the database puts blocks on or removes blocks from the free list as needed.</span></p><p class="c0"><span class="c1">In addition to PCTFREE, MSSM requires you to control space allocation with SQL</span></p><p class="c0"><span class="c1">parameters such as PCTUSED, FREELISTS, and FREELIST GROUPS. PCTUSED sets the</span></p><p class="c0"><span class="c1">percentage of free space that must exist in a currently used block for the database to</span></p><p class="c0"><span class="c1">put it on the free list. For example, if you set PCTUSED to 40 in a CREATE TABLE</span></p><p class="c0"><span class="c1">Note: Oracle strongly recommends the use of locally managed</span></p><p class="c0"><span class="c1">tablespaces with Automatic Segment Space Management.</span></p><p class="c0"><span class="c1">Note: This chapter assumes the use of ASSM in all of its discussions</span></p><p class="c0"><span class="c1">of logical storage space.Introduction to Logical Storage Structures</span></p><p class="c0"><span class="c1">Logical Storage Structures 12-5</span></p><p class="c0"><span class="c1">statement, then you cannot insert rows into a block in the segment until less than 40%</span></p><p class="c0"><span class="c1">of the block space is used.</span></p><p class="c0"><span class="c1">As an illustration, suppose you insert a row into a table. The database checks a free list</span></p><p class="c0"><span class="c1">of the table for the first available block. If the row cannot fit in the block, and if the</span></p><p class="c0"><span class="c1">used space in the block is greater than or equal to PCTUSED, then the database takes the</span></p><p class="c0"><span class="c1">block off the list and searches for another block. If you delete rows from the block, then</span></p><p class="c0"><span class="c1">the database checks whether used space in the block is now less than PCTUSED. If so,</span></p><p class="c0"><span class="c1">then the database places the block at the beginning of the free list.</span></p><p class="c0"><span class="c1">An object may have multiple free lists. In this way, multiple sessions performing DML</span></p><p class="c0"><span class="c1">on a table can use different lists, which can reduce contention. Each database session</span></p><p class="c0"><span class="c1">uses only one free list for the duration of its session.</span></p><p class="c0"><span class="c1">As shown in Figure 12&ndash;4, you can also create an object with one or more free list</span></p><p class="c0"><span class="c1">groups, which are collections of free lists. Each group has a master free list that</span></p><p class="c0"><span class="c1">manages the individual process free lists in the group. Space overhead for free lists,</span></p><p class="c0"><span class="c1">especially for free list groups, can be significant.</span></p><p class="c0"><span class="c1">Figure 12&ndash;4 Free List Groups</span></p><p class="c0"><span class="c1">Managing segment space manually can be complex. You must adjust PCTFREE and</span></p><p class="c0"><span class="c1">PCTUSED to reduce row migration (see &quot;Chained and Migrated Rows&quot; on page 12-16)</span></p><p class="c0"><span class="c1">and avoid wasting space. For example, if every used block in a segment is half full,</span></p><p class="c0"><span class="c1">and if PCTUSED is 40, then the database does not permit inserts into any of these blocks.</span></p><p class="c0"><span class="c1">Because of the difficulty of fine-tuning space allocation parameters, Oracle strongly</span></p><p class="c0"><span class="c1">recommends ASSM. In ASSM, PCTFREE determines whether a new row can be inserted</span></p><p class="c0"><span class="c1">into a block, but it does not use free lists and ignores PCTUSED.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn about locally</span></p><p class="c0"><span class="c1">managed tablespaces</span></p><p class="c0"><span class="c1">&#9632; Oracle Database 2 Day DBA and Oracle Database Administrator&#39;s</span></p><p class="c0"><span class="c1">Guide to learn more about automatic segment space management</span></p><p class="c0"><span class="c1">&#9632; Oracle Database SQL Language Reference to learn about storage</span></p><p class="c0"><span class="c1">parameters such as PCTFREE and PCTUSED</span></p><p class="c0"><span class="c1">Master</span></p><p class="c0"><span class="c1">Free</span></p><p class="c0"><span class="c1">List</span></p><p class="c0"><span class="c1">Master</span></p><p class="c0"><span class="c1">Free</span></p><p class="c0"><span class="c1">List</span></p><p class="c0"><span class="c1">Free List Group Free List Group</span></p><p class="c0"><span class="c1">Process Free Lists Process Free Lists</span></p><p class="c0"><span class="c1">Table SegmentOverview of Data Blocks</span></p><p class="c0"><span class="c1">12-6 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Dictionary-Managed Tablespaces</span></p><p class="c0"><span class="c1">A dictionary-managed tablespace uses the data dictionary to manage its extents.</span></p><p class="c0"><span class="c1">Oracle Database updates tables in the data dictionary whenever an extent is allocated</span></p><p class="c0"><span class="c1">or freed for reuse. For example, when a table needs an extent, the database queries the</span></p><p class="c0"><span class="c1">data dictionary tables, and searches for free extents. If the database finds space, then it</span></p><p class="c0"><span class="c1">modifies one data dictionary table and inserts a row into another. In this way, the</span></p><p class="c0"><span class="c1">database manages space by modifying and moving data.</span></p><p class="c0"><span class="c1">The SQL that the database executes in the background to obtain space for database</span></p><p class="c0"><span class="c1">objects is recursive SQL. Frequent use of recursive SQL can have a negative impact on</span></p><p class="c0"><span class="c1">performance because updates to the data dictionary must be serialized. Locally</span></p><p class="c0"><span class="c1">managed tablespaces, which are the default, avoid this performance problem.</span></p><p class="c0"><span class="c1">Overview of Data Blocks</span></p><p class="c0"><span class="c1">Oracle Database manages the logical storage space in the data files of a database in</span></p><p class="c0"><span class="c1">units called data blocks, also called Oracle blocks or pages. A data block is the</span></p><p class="c0"><span class="c1">minimum unit of database I/O.</span></p><p class="c0"><span class="c1">Data Blocks and Operating System Blocks</span></p><p class="c0"><span class="c1">At the physical level, database data is stored in disk files made up of operating system</span></p><p class="c0"><span class="c1">blocks. An operating system block is the minimum unit of data that the operating</span></p><p class="c0"><span class="c1">system can read or write. In contrast, an Oracle block is a logical storage structure</span></p><p class="c0"><span class="c1">whose size and structure are not known to the operating system.</span></p><p class="c0"><span class="c1">Figure 12&ndash;5 shows that operating system blocks may differ in size from data blocks.</span></p><p class="c0"><span class="c1">The database requests data in multiples of data blocks, not operating system blocks.</span></p><p class="c0"><span class="c1">Figure 12&ndash;5 Data Blocks and Operating System Blocks</span></p><p class="c0"><span class="c1">When the database requests a data block, the operating system translates this</span></p><p class="c0"><span class="c1">operation into a requests for data in permanent storage. The logical separation of data</span></p><p class="c0"><span class="c1">blocks from operating system blocks has the following implications:</span></p><p class="c0"><span class="c1">&#9632; Applications do not need to determine the physical addresses of data on disk.</span></p><p class="c0"><span class="c1">&#9632; Database data can be striped or mirrored on multiple physical disks.</span></p><p class="c0"><span class="c1">See Also: Oracle Database Administrator&#39;s Guide to learn how to</span></p><p class="c0"><span class="c1">migrate tablespaces from dictionary-managed to locally managed</span></p><p class="c0"><span class="c1">Oracle</span></p><p class="c0"><span class="c1">Data Block</span></p><p class="c0"><span class="c1">Operating</span></p><p class="c0"><span class="c1">System Blocks</span></p><p class="c0"><span class="c1">8 KB</span></p><p class="c0"><span class="c1">1 KB</span></p><p class="c0"><span class="c1">1 KB</span></p><p class="c0"><span class="c1">1 KB</span></p><p class="c0"><span class="c1">1 KB</span></p><p class="c0"><span class="c1">1 KB</span></p><p class="c0"><span class="c1">1 KB</span></p><p class="c0"><span class="c1">1 KB</span></p><p class="c0"><span class="c1">1 KBOverview of Data Blocks</span></p><p class="c0"><span class="c1">Logical Storage Structures 12-7</span></p><p class="c0"><span class="c1">Database Block Size</span></p><p class="c0"><span class="c1">Every database has a database block size. The DB_BLOCK_SIZE initialization parameter</span></p><p class="c0"><span class="c1">sets the data block size for a database when it is created. The size is set for the SYSTEM</span></p><p class="c0"><span class="c1">and SYSAUX tablespaces and is the default for all other tablespaces. The database block</span></p><p class="c0"><span class="c1">size cannot be changed except by re-creating the database.</span></p><p class="c0"><span class="c1">If DB_BLOCK_SIZE is not set, then the default data block size is operating</span></p><p class="c0"><span class="c1">system-specific. The standard data block size for a database is 4 KB or 8 KB. If the size</span></p><p class="c0"><span class="c1">differs for data blocks and operating system blocks, then the data block size must be a</span></p><p class="c0"><span class="c1">multiple of the operating system block size.</span></p><p class="c0"><span class="c1">Tablespace Block Size</span></p><p class="c0"><span class="c1">You can create individual tablespaces whose block size differs from the DB_BLOCK_SIZE</span></p><p class="c0"><span class="c1">setting. A nonstandard block size can be useful when moving a transportable</span></p><p class="c0"><span class="c1">tablespace to a different platform.</span></p><p class="c0"><span class="c1">Data Block Format</span></p><p class="c0"><span class="c1">Every data block has a format or internal structure that enables the database to track</span></p><p class="c0"><span class="c1">the data and free space in the block. This format is similar whether the data block</span></p><p class="c0"><span class="c1">contains table, index, or table cluster data. Figure 12&ndash;6 shows the format of an</span></p><p class="c0"><span class="c1">uncompressed data block (see &quot;Data Block Compression&quot; on page 12-11 to learn about</span></p><p class="c0"><span class="c1">compressed blocks).</span></p><p class="c0"><span class="c1">Figure 12&ndash;6 Data Block Format</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Reference to learn about the DB_BLOCK_SIZE</span></p><p class="c0"><span class="c1">initialization parameter</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide and Oracle Database</span></p><p class="c0"><span class="c1">Performance Tuning Guide to learn how to choose block sizes</span></p><p class="c0"><span class="c1">See Also: Oracle Database Administrator&#39;s Guide to learn how to</span></p><p class="c0"><span class="c1">specify a nonstandard block size for a tablespace</span></p><p class="c0"><span class="c1">Database Block</span></p><p class="c0"><span class="c1">Common and Variable Header</span></p><p class="c0"><span class="c1">Table Directory</span></p><p class="c0"><span class="c1">Row Directory</span></p><p class="c0"><span class="c1">Free Space</span></p><p class="c0"><span class="c1">Row DataOverview of Data Blocks</span></p><p class="c0"><span class="c1">12-8 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Data Block Overhead</span></p><p class="c0"><span class="c1">Oracle Database uses the block overhead to manage the block itself. The block</span></p><p class="c0"><span class="c1">overhead is not available to store user data. As shown in Figure 12&ndash;6, the block</span></p><p class="c0"><span class="c1">overhead includes the following parts:</span></p><p class="c0"><span class="c1">&#9632; Block header</span></p><p class="c0"><span class="c1">This part contains general information about the block, including disk address and</span></p><p class="c0"><span class="c1">segment type. For blocks that are transaction-managed, the block header contains</span></p><p class="c0"><span class="c1">active and historical transaction information.</span></p><p class="c0"><span class="c1">A transaction entry is required for every transaction that updates the block. Oracle</span></p><p class="c0"><span class="c1">Database initially reserves space in the block header for transaction entries. In data</span></p><p class="c0"><span class="c1">blocks allocated to segments that support transactional changes, free space can</span></p><p class="c0"><span class="c1">also hold transaction entries when the header space is depleted. The space</span></p><p class="c0"><span class="c1">required for transaction entries is operating system dependent. However,</span></p><p class="c0"><span class="c1">transaction entries in most operating systems require approximately 23 bytes.</span></p><p class="c0"><span class="c1">&#9632; Table directory</span></p><p class="c0"><span class="c1">For a heap-organized table, this directory contains metadata about tables whose</span></p><p class="c0"><span class="c1">rows are stored in this block. Multiple tables can store rows in the same block.</span></p><p class="c0"><span class="c1">&#9632; Row directory</span></p><p class="c0"><span class="c1">For a heap-organized table, this directory describes the location of rows in the data</span></p><p class="c0"><span class="c1">portion of the block.</span></p><p class="c0"><span class="c1">After space has been allocated in the row directory, the database does not reclaim</span></p><p class="c0"><span class="c1">this space after row deletion. Thus, a block that is currently empty but formerly</span></p><p class="c0"><span class="c1">had up to 50 rows continues to have 100 bytes allocated for the row directory. The</span></p><p class="c0"><span class="c1">database reuses this space only when new rows are inserted in the block.</span></p><p class="c0"><span class="c1">Some parts of the block overhead are fixed in size, but the total size is variable. On</span></p><p class="c0"><span class="c1">average, the block overhead totals 84 to 107 bytes.</span></p><p class="c0"><span class="c1">Row Format</span></p><p class="c0"><span class="c1">The row data part of the block contains the actual data, such as table rows or index key</span></p><p class="c0"><span class="c1">entries. Just as every data block has an internal format, every row has a row format</span></p><p class="c0"><span class="c1">that enables the database to track the data in the row.</span></p><p class="c0"><span class="c1">Oracle Database stores rows as variable-length records. A row is contained in one or</span></p><p class="c0"><span class="c1">more row pieces. Each row piece has a row header and column data.</span></p><p class="c0"><span class="c1">Figure 12&ndash;7 shows the format of a row.Overview of Data Blocks</span></p><p class="c0"><span class="c1">Logical Storage Structures 12-9</span></p><p class="c0"><span class="c1">Figure 12&ndash;7 The Format of a Row Piece</span></p><p class="c0"><span class="c1">Row Header Oracle Database uses the row header to manage the row piece stored in the</span></p><p class="c0"><span class="c1">block. The row header contains information such as the following:</span></p><p class="c0"><span class="c1">&#9632; Columns in the row piece</span></p><p class="c0"><span class="c1">&#9632; Pieces of the row located in other data blocks</span></p><p class="c0"><span class="c1">If an entire row can be inserted into a single data block, then Oracle Database</span></p><p class="c0"><span class="c1">stores the row as one row piece. However, if all of the row data cannot be inserted</span></p><p class="c0"><span class="c1">into a single block or an update causes an existing row to outgrow its block, then</span></p><p class="c0"><span class="c1">the database stores the row in multiple row pieces (see &quot;Chained and Migrated</span></p><p class="c0"><span class="c1">Rows&quot; on page 12-16). A data block usually contains only one row piece per row.</span></p><p class="c0"><span class="c1">&#9632; Cluster keys for table clusters (see &quot;Overview of Table Clusters&quot; on page 2-22)</span></p><p class="c0"><span class="c1">A row fully contained in one block has at least 3 bytes of row header.</span></p><p class="c0"><span class="c1">Column Data After the row header, the column data section stores the actual data in the</span></p><p class="c0"><span class="c1">row. The row piece usually stores columns in the order listed in the CREATE TABLE</span></p><p class="c0"><span class="c1">statement, but this order is not guaranteed. For example, columns of type LONG are</span></p><p class="c0"><span class="c1">created last.</span></p><p class="c0"><span class="c1">As shown in Figure 12&ndash;7, for each column in a row piece, Oracle Database stores the</span></p><p class="c0"><span class="c1">column length and data separately. The space required depends on the data type. If the</span></p><p class="c0"><span class="c1">data type of a column is variable length, then the space required to hold a value can</span></p><p class="c0"><span class="c1">grow and shrink with updates to the data.</span></p><p class="c0"><span class="c1">Each row has a slot in the row directory of the data block header. The slot points to the</span></p><p class="c0"><span class="c1">beginning of the row.</span></p><p class="c0"><span class="c1">See Also: &quot;Table Storage&quot; on page 2-18 and &quot;Index Storage&quot; on</span></p><p class="c0"><span class="c1">page 3-20</span></p><p class="c0"><span class="c1">Row Header Column Data</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">Block</span></p><p class="c0"><span class="c1">Row Piece in a Database Block</span></p><p class="c0"><span class="c1">Row Overhead</span></p><p class="c0"><span class="c1">Number of Columns</span></p><p class="c0"><span class="c1">Cluster Key ID (if clustered)</span></p><p class="c0"><span class="c1">ROWID of Chained Row Pieces (if any)</span></p><p class="c0"><span class="c1">Column Length</span></p><p class="c0"><span class="c1">Column ValueOverview of Data Blocks</span></p><p class="c0"><span class="c1">12-10 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Rowid Format Oracle Database uses a rowid to uniquely identify a row. Internally, the</span></p><p class="c0"><span class="c1">rowid is a structure that holds information that the database needs to access a row. A</span></p><p class="c0"><span class="c1">rowid is not physically stored in the database, but is inferred from the file and block on</span></p><p class="c0"><span class="c1">which the data is stored.</span></p><p class="c0"><span class="c1">An extended rowid includes a data object number. This rowid type uses a base 64</span></p><p class="c0"><span class="c1">encoding of the physical address for each row. The encoding characters are A-Z, a-z,</span></p><p class="c0"><span class="c1">0-9, +, and /.</span></p><p class="c0"><span class="c1">Example 12&ndash;1 queries the ROWID pseudocolumn to show the extended rowid of the</span></p><p class="c0"><span class="c1">row in the employees table for employee 100.</span></p><p class="c0"><span class="c1">Example 12&ndash;1 ROWID Pseudocolumn</span></p><p class="c0"><span class="c1">SQL&gt; SELECT ROWID FROM employees WHERE employee_id = 100;</span></p><p class="c0"><span class="c1">ROWID</span></p><p class="c0"><span class="c1">------------------</span></p><p class="c0"><span class="c1">AAAPecAAFAAAABSAAA</span></p><p class="c0"><span class="c1">Figure 12&ndash;8 illustrates the format of an extended rowid.</span></p><p class="c0"><span class="c1">Figure 12&ndash;8 ROWID Format</span></p><p class="c0"><span class="c1">An extended rowid is displayed in a four-piece format, OOOOOOFFFBBBBBBRRR, with the</span></p><p class="c0"><span class="c1">format divided into the following components:</span></p><p class="c0"><span class="c1">&#9632; OOOOOO</span></p><p class="c0"><span class="c1">The data object number identifies the segment (data object AAAPec in</span></p><p class="c0"><span class="c1">Example 12&ndash;1). A data object number is assigned to every database segment.</span></p><p class="c0"><span class="c1">Schema objects in the same segment, such as a table cluster, have the same data</span></p><p class="c0"><span class="c1">object number.</span></p><p class="c0"><span class="c1">&#9632; FFF</span></p><p class="c0"><span class="c1">The tablespace-relative data file number identifies the data file that contains the</span></p><p class="c0"><span class="c1">row (file AAF in Example 12&ndash;1).</span></p><p class="c0"><span class="c1">&#9632; BBBBBB</span></p><p class="c0"><span class="c1">The data block number identifies the block that contains the row (block AAAABS in</span></p><p class="c0"><span class="c1">Example 12&ndash;1). Block numbers are relative to their data file, not their tablespace.</span></p><p class="c0"><span class="c1">Thus, two rows with identical block numbers could reside in different data files of</span></p><p class="c0"><span class="c1">the same tablespace.</span></p><p class="c0"><span class="c1">&#9632; RRR</span></p><p class="c0"><span class="c1">The row number identifies the row in the block (row AAA in Example 12&ndash;1).</span></p><p class="c0"><span class="c1">After a rowid is assigned to a row piece, the rowid can change in special</span></p><p class="c0"><span class="c1">circumstances. For example, if row movement is enabled, then the rowid can change</span></p><p class="c0"><span class="c1">because of partition key updates, Flashback Table operations, shrink table operations,</span></p><p class="c0"><span class="c1">and so on. If row movement is disabled, then a rowid can change if the row is exported</span></p><p class="c0"><span class="c1">and imported using Oracle Database utilities.</span></p><p class="c0"><span class="c1">AAAPec . AAF . AAAABS</span></p><p class="c0"><span class="c1">Data Object Number Relative File Number Block Number</span></p><p class="c0"><span class="c1">AAA</span></p><p class="c0"><span class="c1">Row Number</span></p><p class="c0"><span class="c1">.Overview of Data Blocks</span></p><p class="c0"><span class="c1">Logical Storage Structures 12-11</span></p><p class="c0"><span class="c1">Data Block Compression</span></p><p class="c0"><span class="c1">The database can use table compression to eliminate duplicate values in a data block</span></p><p class="c0"><span class="c1">(see &quot;Table Compression&quot; on page 2-19). This section describes the format of data</span></p><p class="c0"><span class="c1">blocks that use compression.</span></p><p class="c0"><span class="c1">The format of a data block that uses basic and advanced row compression is</span></p><p class="c0"><span class="c1">essentially the same as an uncompressed block. The difference is that a symbol table at</span></p><p class="c0"><span class="c1">the beginning of the block stores duplicate values for the rows and columns. The</span></p><p class="c0"><span class="c1">database replaces occurrences of these values with a short reference to the symbol</span></p><p class="c0"><span class="c1">table.</span></p><p class="c0"><span class="c1">Assume that the rows in Example 12&ndash;2 are stored in a data block for the seven-column</span></p><p class="c0"><span class="c1">sales table.</span></p><p class="c0"><span class="c1">Example 12&ndash;2 Rows in sales Table</span></p><p class="c0"><span class="c1">2190,13770,25-NOV-00,S,9999,23,161</span></p><p class="c0"><span class="c1">2225,15720,28-NOV-00,S,9999,25,1450</span></p><p class="c0"><span class="c1">34005,120760,29-NOV-00,P,9999,44,2376</span></p><p class="c0"><span class="c1">9425,4750,29-NOV-00,I,9999,11,979</span></p><p class="c0"><span class="c1">1675,46750,29-NOV-00,S,9999,19,1121</span></p><p class="c0"><span class="c1">When basic or advanced row compression is applied to this table, the database</span></p><p class="c0"><span class="c1">replaces duplicate values with a symbol reference. Example 12&ndash;3 is a conceptual</span></p><p class="c0"><span class="c1">representation of the compression in which the symbol * replaces 29-NOV-00 and %</span></p><p class="c0"><span class="c1">replaces 9999.</span></p><p class="c0"><span class="c1">Example 12&ndash;3 OLTP Compressed Rows in sales Table</span></p><p class="c0"><span class="c1">2190,13770,25-NOV-00,S,%,23,161</span></p><p class="c0"><span class="c1">2225,15720,28-NOV-00,S,%,25,1450</span></p><p class="c0"><span class="c1">34005,120760,*,P,%,44,2376</span></p><p class="c0"><span class="c1">9425,4750,*,I,%,11,979</span></p><p class="c0"><span class="c1">1675,46750,*,S,%,19,1121</span></p><p class="c0"><span class="c1">Table 12&ndash;1 conceptually represents the symbol table that maps symbols to values.</span></p><p class="c0"><span class="c1">Note: Internally, the database performs row movement as if the row</span></p><p class="c0"><span class="c1">were physically deleted and reinserted. However, row movement is</span></p><p class="c0"><span class="c1">considered an update, which has implications for triggers.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Rowid Data Types&quot; on page 2-13</span></p><p class="c0"><span class="c1">&#9632; Oracle Database SQL Language Reference to learn about rowids</span></p><p class="c0"><span class="c1">Table 12&ndash;1 Symbol Table</span></p><p class="c0"><span class="c1">Symbol Value Column Rows</span></p><p class="c0"><span class="c1">* 29-NOV-00 3 958-960</span></p><p class="c0"><span class="c1">% 9999 5 956-960Overview of Data Blocks</span></p><p class="c0"><span class="c1">12-12 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Space Management in Data Blocks</span></p><p class="c0"><span class="c1">As the database fills a data block from the bottom up, the amount of free space</span></p><p class="c0"><span class="c1">between the row data and the block header decreases. This free space can also shrink</span></p><p class="c0"><span class="c1">during updates, as when changing a trailing null to a nonnull value. The database</span></p><p class="c0"><span class="c1">manages free space in the data block to optimize performance and avoid wasted space.</span></p><p class="c0"><span class="c1">Percentage of Free Space in Data Blocks</span></p><p class="c0"><span class="c1">The PCTFREE storage parameter is essential to how the database manages free space.</span></p><p class="c0"><span class="c1">This SQL parameter sets the minimum percentage of a data block reserved as free</span></p><p class="c0"><span class="c1">space for updates to existing rows. Thus, PCTFREE is important for preventing row</span></p><p class="c0"><span class="c1">migration and avoiding wasted space.</span></p><p class="c0"><span class="c1">For example, assume that you create a table that will require only occasional updates,</span></p><p class="c0"><span class="c1">most of which will not increase the size of the existing data. You specify the PCTFREE</span></p><p class="c0"><span class="c1">parameter within a CREATE TABLE statement as follows:</span></p><p class="c0"><span class="c1">CREATE TABLE test_table (n NUMBER) PCTFREE 20;</span></p><p class="c0"><span class="c1">Figure 12&ndash;9 shows how a PCTFREE setting of 20 affects space management. The</span></p><p class="c0"><span class="c1">database adds rows to the block over time, causing the row data to grow upwards</span></p><p class="c0"><span class="c1">toward the block header, which is itself expanding downward toward the row data.</span></p><p class="c0"><span class="c1">The PCTFREE setting ensures that at least 20% of the data block is free. For example, the</span></p><p class="c0"><span class="c1">database prevents an INSERT statement from filling the block so that the row data and</span></p><p class="c0"><span class="c1">header occupy a combined 90% of the total block space, leaving only 10% free.</span></p><p class="c0"><span class="c1">Figure 12&ndash;9 PCTFREE</span></p><p class="c0"><span class="c1">Note: This section assumes the use of automatic segment space</span></p><p class="c0"><span class="c1">management.</span></p><p class="c0"><span class="c1">Note: This discussion does not apply to LOB data types, which do</span></p><p class="c0"><span class="c1">not use the PCTFREE storage parameter or free lists. See &quot;Overview of</span></p><p class="c0"><span class="c1">LOBs&quot; on page 19-12.</span></p><p class="c0"><span class="c1">PCTFREE = 20</span></p><p class="c0"><span class="c1">Data Block</span></p><p class="c0"><span class="c1">20% Free Space</span></p><p class="c0"><span class="c1">Block allows row inserts</span></p><p class="c0"><span class="c1">until 80% is occupied,</span></p><p class="c0"><span class="c1">leaving 20% free for updates</span></p><p class="c0"><span class="c1">to existing rows in the blockOverview of Data Blocks</span></p><p class="c0"><span class="c1">Logical Storage Structures 12-13</span></p><p class="c0"><span class="c1">Optimization of Free Space in Data Blocks</span></p><p class="c0"><span class="c1">While the percentage of free space cannot be less than PCTFREE, the amount of free</span></p><p class="c0"><span class="c1">space can be greater. For example, a PCTFREE setting of 20% prevents the total amount</span></p><p class="c0"><span class="c1">of free space from dropping to 5% of the block, but permits 50% of the block to be free</span></p><p class="c0"><span class="c1">space. The following SQL statements can increase free space:</span></p><p class="c0"><span class="c1">&#9632; DELETE statements</span></p><p class="c0"><span class="c1">&#9632; UPDATE statements that either update existing values to smaller values or increase</span></p><p class="c0"><span class="c1">existing values and force a row to migrate</span></p><p class="c0"><span class="c1">&#9632; INSERT statements on a table that uses OLTP compression</span></p><p class="c0"><span class="c1">If inserts fill a block with data, then the database invokes block compression,</span></p><p class="c0"><span class="c1">which may result in the block having more free space.</span></p><p class="c0"><span class="c1">The space released is available for INSERT statements under the following conditions:</span></p><p class="c0"><span class="c1">&#9632; If the INSERT statement is in the same transaction and after the statement that frees</span></p><p class="c0"><span class="c1">space, then the statement can use the space.</span></p><p class="c0"><span class="c1">&#9632; If the INSERT statement is in a separate transaction from the statement that frees</span></p><p class="c0"><span class="c1">space (perhaps run by another user), then the statement can use the space made</span></p><p class="c0"><span class="c1">available only after the other transaction commits and only if the space is needed.</span></p><p class="c0"><span class="c1">Coalescing Fragmented Space Released space may or may not be contiguous with the</span></p><p class="c0"><span class="c1">main area of free space in a data block, as shown in Figure 12&ndash;10. Noncontiguous free</span></p><p class="c0"><span class="c1">space is called fragmented space.</span></p><p class="c0"><span class="c1">Figure 12&ndash;10 Data Block with Fragmented Space</span></p><p class="c0"><span class="c1">Oracle Database automatically and transparently coalesces the free space of a data</span></p><p class="c0"><span class="c1">block only when the following conditions are true:</span></p><p class="c0"><span class="c1">See Also: Oracle Database SQL Language Reference for the syntax and</span></p><p class="c0"><span class="c1">semantics of the PCTFREE parameter</span></p><p class="c0"><span class="c1">See Also: Oracle Database Administrator&#39;s Guide to learn about OLTP</span></p><p class="c0"><span class="c1">compression</span></p><p class="c0"><span class="c1">Database Block</span></p><p class="c0"><span class="c1">Data Block Header</span></p><p class="c0"><span class="c1">Free SpaceOverview of Data Blocks</span></p><p class="c0"><span class="c1">12-14 Oracle Database Concepts</span></p><p class="c0"><span class="c1">&#9632; An INSERT or UPDATE statement attempts to use a block that contains sufficient free</span></p><p class="c0"><span class="c1">space to contain a new row piece.</span></p><p class="c0"><span class="c1">&#9632; The free space is fragmented so that the row piece cannot be inserted in a</span></p><p class="c0"><span class="c1">contiguous section of the block.</span></p><p class="c0"><span class="c1">After coalescing, the amount of free space is identical to the amount before the</span></p><p class="c0"><span class="c1">operation, but the space is now contiguous. Figure 12&ndash;11 shows a data block after</span></p><p class="c0"><span class="c1">space has been coalesced.</span></p><p class="c0"><span class="c1">Figure 12&ndash;11 Data Block After Coalescing Free Space</span></p><p class="c0"><span class="c1">Oracle Database performs coalescing only in the preceding situations because</span></p><p class="c0"><span class="c1">otherwise performance would decrease because of the continuous coalescing of the</span></p><p class="c0"><span class="c1">free space in data blocks.</span></p><p class="c0"><span class="c1">Reuse of Index Space The database can reuse space within an index block. For example,</span></p><p class="c0"><span class="c1">if you insert a value into a column and delete it, and if an index exists on this column,</span></p><p class="c0"><span class="c1">then the database can reuse the index slot when a row requires it.</span></p><p class="c0"><span class="c1">The database can reuse an index block itself. Unlike a table block, an index block only</span></p><p class="c0"><span class="c1">becomes free when it is empty. The database places the empty block on the free list of</span></p><p class="c0"><span class="c1">the index structure and makes it eligible for reuse. However, Oracle Database does not</span></p><p class="c0"><span class="c1">automatically compact the index: an ALTER INDEX REBUILD or COALESCE statement is</span></p><p class="c0"><span class="c1">required.</span></p><p class="c0"><span class="c1">Figure 12&ndash;12 represents an index of the employees.department_id column before the</span></p><p class="c0"><span class="c1">index is coalesced. The first three leaf blocks are only partially full, as indicated by the</span></p><p class="c0"><span class="c1">gray fill lines.</span></p><p class="c0"><span class="c1">Database Block</span></p><p class="c0"><span class="c1">Data Block Header</span></p><p class="c0"><span class="c1">Free SpaceOverview of Data Blocks</span></p><p class="c0"><span class="c1">Logical Storage Structures 12-15</span></p><p class="c0"><span class="c1">Figure 12&ndash;12 Index Before Coalescing</span></p><p class="c0"><span class="c1">Figure 12&ndash;13 shows the index in Figure 12&ndash;12 after the index has been coalesced. The</span></p><p class="c0"><span class="c1">first two leaf blocks are now full, as indicated by the gray fill lines, and the third leaf</span></p><p class="c0"><span class="c1">block has been freed.</span></p><p class="c0"><span class="c1">. . .</span></p><p class="c0"><span class="c1">26..48</span></p><p class="c0"><span class="c1">49..53</span></p><p class="c0"><span class="c1">54..65</span></p><p class="c0"><span class="c1">....</span></p><p class="c0"><span class="c1">78..80</span></p><p class="c0"><span class="c1">11,rowid</span></p><p class="c0"><span class="c1">12,rowid</span></p><p class="c0"><span class="c1">12,rowid</span></p><p class="c0"><span class="c1">19,rowid</span></p><p class="c0"><span class="c1">22,rowid</span></p><p class="c0"><span class="c1">23,rowid</span></p><p class="c0"><span class="c1">221,rowid</span></p><p class="c0"><span class="c1">222,rowid</span></p><p class="c0"><span class="c1">223,rowid</span></p><p class="c0"><span class="c1">....</span></p><p class="c0"><span class="c1">228,rowid</span></p><p class="c0"><span class="c1">246,rowid</span></p><p class="c0"><span class="c1">248,rowid</span></p><p class="c0"><span class="c1">248,rowid</span></p><p class="c0"><span class="c1">....</span></p><p class="c0"><span class="c1">250,rowid</span></p><p class="c0"><span class="c1">0,rowid</span></p><p class="c0"><span class="c1">0,rowid</span></p><p class="c0"><span class="c1">1,rowid</span></p><p class="c0"><span class="c1">5,rowid</span></p><p class="c0"><span class="c1">0..25</span></p><p class="c0"><span class="c1">26..80</span></p><p class="c0"><span class="c1">81..120</span></p><p class="c0"><span class="c1">....</span></p><p class="c0"><span class="c1">200..250</span></p><p class="c0"><span class="c1">. . . . . .</span></p><p class="c0"><span class="c1">0..10</span></p><p class="c0"><span class="c1">11..19</span></p><p class="c0"><span class="c1">20..25</span></p><p class="c0"><span class="c1">200..209</span></p><p class="c0"><span class="c1">210..220</span></p><p class="c0"><span class="c1">221..228</span></p><p class="c0"><span class="c1">....</span></p><p class="c0"><span class="c1">246..250</span></p><p class="c0"><span class="c1">Branch Blocks</span></p><p class="c0"><span class="c1">Leaf BlocksOverview of Data Blocks</span></p><p class="c0"><span class="c1">12-16 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Figure 12&ndash;13 Index After Coalescing</span></p><p class="c0"><span class="c1">Chained and Migrated Rows</span></p><p class="c0"><span class="c1">Oracle Database must manage rows that are too large to fit into a single block. The</span></p><p class="c0"><span class="c1">following situations are possible:</span></p><p class="c0"><span class="c1">&#9632; The row is too large to fit into one data block when it is first inserted.</span></p><p class="c0"><span class="c1">In row chaining, Oracle Database stores the data for the row in a chain of one or</span></p><p class="c0"><span class="c1">more data blocks reserved for the segment. Row chaining most often occurs with</span></p><p class="c0"><span class="c1">large rows. Examples include rows that contain a column of data type LONG or LONG</span></p><p class="c0"><span class="c1">RAW, a VARCHAR2(4000) column in a 2 KB block, or a row with a huge number of</span></p><p class="c0"><span class="c1">columns. Row chaining in these cases is unavoidable.</span></p><p class="c0"><span class="c1">&#9632; A row that originally fit into one data block is updated so that the overall row</span></p><p class="c0"><span class="c1">length increases, but insufficient free space exists to hold the updated row.</span></p><p class="c0"><span class="c1">In row migration, Oracle Database moves the entire row to a new data block,</span></p><p class="c0"><span class="c1">assuming the row can fit in a new block. The original row piece of a migrated row</span></p><p class="c0"><span class="c1">contains a pointer or &quot;forwarding address&quot; to the new block containing the</span></p><p class="c0"><span class="c1">migrated row. The rowid of a migrated row does not change.</span></p><p class="c0"><span class="c1">&#9632; A row has more than 255 columns.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn how to coalesce and</span></p><p class="c0"><span class="c1">rebuild indexes</span></p><p class="c0"><span class="c1">&#9632; Oracle Database SQL Language Reference to learn about the</span></p><p class="c0"><span class="c1">COALESCE statement</span></p><p class="c0"><span class="c1">. . .</span></p><p class="c0"><span class="c1">24..48</span></p><p class="c0"><span class="c1">49..53</span></p><p class="c0"><span class="c1">54..65</span></p><p class="c0"><span class="c1">....</span></p><p class="c0"><span class="c1">78..80</span></p><p class="c0"><span class="c1">12,rowid</span></p><p class="c0"><span class="c1">12,rowid</span></p><p class="c0"><span class="c1">19,rowid</span></p><p class="c0"><span class="c1">22,rowid</span></p><p class="c0"><span class="c1">23,rowid</span></p><p class="c0"><span class="c1">221,rowid</span></p><p class="c0"><span class="c1">222,rowid</span></p><p class="c0"><span class="c1">223,rowid</span></p><p class="c0"><span class="c1">....</span></p><p class="c0"><span class="c1">228,rowid</span></p><p class="c0"><span class="c1">246,rowid</span></p><p class="c0"><span class="c1">248,rowid</span></p><p class="c0"><span class="c1">248,rowid</span></p><p class="c0"><span class="c1">....</span></p><p class="c0"><span class="c1">250,rowid</span></p><p class="c0"><span class="c1">0,rowid</span></p><p class="c0"><span class="c1">0,rowid</span></p><p class="c0"><span class="c1">1,rowid</span></p><p class="c0"><span class="c1">5,rowid</span></p><p class="c0"><span class="c1">11,rowid</span></p><p class="c0"><span class="c1">0..23</span></p><p class="c0"><span class="c1">24..80</span></p><p class="c0"><span class="c1">81..120</span></p><p class="c0"><span class="c1">....</span></p><p class="c0"><span class="c1">200..250</span></p><p class="c0"><span class="c1">. . . . . .</span></p><p class="c0"><span class="c1">0..11</span></p><p class="c0"><span class="c1">12..23</span></p><p class="c0"><span class="c1">200..209</span></p><p class="c0"><span class="c1">210..220</span></p><p class="c0"><span class="c1">221..228</span></p><p class="c0"><span class="c1">....</span></p><p class="c0"><span class="c1">246..250</span></p><p class="c0"><span class="c1">Branch Blocks</span></p><p class="c0"><span class="c1">Leaf BlocksOverview of Data Blocks</span></p><p class="c0"><span class="c1">Logical Storage Structures 12-17</span></p><p class="c0"><span class="c1">Oracle Database can only store 255 columns in a row piece. Thus, if you insert a</span></p><p class="c0"><span class="c1">row into a table that has 1000 columns, then the database creates 4 row pieces,</span></p><p class="c0"><span class="c1">typically chained over multiple blocks.</span></p><p class="c0"><span class="c1">Figure 12&ndash;14 depicts shows the insertion of a large row in a data block. The row is too</span></p><p class="c0"><span class="c1">large for the left block, so the database chains the row by placing the first row piece in</span></p><p class="c0"><span class="c1">the left block and the second row piece in the right block.</span></p><p class="c0"><span class="c1">Figure 12&ndash;14 Row Chaining</span></p><p class="c0"><span class="c1">Figure 12&ndash;15, the left block contains a row that is updated so that the row is now too</span></p><p class="c0"><span class="c1">large for the block. The database moves the entire row to the right block and leaves a</span></p><p class="c0"><span class="c1">pointer to the migrated row in the left block.</span></p><p class="c0"><span class="c1">Figure 12&ndash;15 Row Migration</span></p><p class="c0"><span class="c1">Database Block</span></p><p class="c0"><span class="c1">Data Block Header</span></p><p class="c0"><span class="c1">Piece 1 of Inserted Row</span></p><p class="c0"><span class="c1">Row Piece Pointer</span></p><p class="c0"><span class="c1">Database Block</span></p><p class="c0"><span class="c1">Data Block</span></p><p class="c0"><span class="c1">Header</span></p><p class="c0"><span class="c1">Free Space</span></p><p class="c0"><span class="c1">Piece 2 of</span></p><p class="c0"><span class="c1">Inserted</span></p><p class="c0"><span class="c1">Row</span></p><p class="c0"><span class="c1">Database Block</span></p><p class="c0"><span class="c1">Data Block</span></p><p class="c0"><span class="c1">Header</span></p><p class="c0"><span class="c1">Free Space</span></p><p class="c0"><span class="c1">Pointer to Updated</span></p><p class="c0"><span class="c1">Row</span></p><p class="c0"><span class="c1">Database Block</span></p><p class="c0"><span class="c1">Data Block</span></p><p class="c0"><span class="c1">Header</span></p><p class="c0"><span class="c1">Free</span></p><p class="c0"><span class="c1">Space</span></p><p class="c0"><span class="c1">Updated</span></p><p class="c0"><span class="c1">RowOverview of Extents</span></p><p class="c0"><span class="c1">12-18 Oracle Database Concepts</span></p><p class="c0"><span class="c1">When a row is chained or migrated, the I/O needed to retrieve the data increases. This</span></p><p class="c0"><span class="c1">situation results because Oracle Database must scan multiple blocks to retrieve the</span></p><p class="c0"><span class="c1">information for the row. For example, if the database performs one I/O to read an</span></p><p class="c0"><span class="c1">index and one I/O to read a nonmigrated table row, then an additional I/O is required</span></p><p class="c0"><span class="c1">to obtain the data for a migrated row.</span></p><p class="c0"><span class="c1">The Segment Advisor, which can be run both manually and automatically, is an Oracle</span></p><p class="c0"><span class="c1">Database component that identifies segments that have space available for</span></p><p class="c0"><span class="c1">reclamation. The advisor can offer advice about objects that have significant free space</span></p><p class="c0"><span class="c1">or too many chained rows.</span></p><p class="c0"><span class="c1">Overview of Extents</span></p><p class="c0"><span class="c1">An extent is a logical unit of database storage space allocation made up of contiguous</span></p><p class="c0"><span class="c1">data blocks. Data blocks in an extent are logically contiguous but can be physically</span></p><p class="c0"><span class="c1">spread out on disk because of RAID striping and file system implementations.</span></p><p class="c0"><span class="c1">Allocation of Extents</span></p><p class="c0"><span class="c1">By default, the database allocates an initial extent for a data segment when the</span></p><p class="c0"><span class="c1">segment is created. An extent is always contained in one data file.</span></p><p class="c0"><span class="c1">Although no data has been added to the segment, the data blocks in the initial extent</span></p><p class="c0"><span class="c1">are reserved for this segment exclusively. The first data block of every segment</span></p><p class="c0"><span class="c1">contains a directory of the extents in the segment. Figure 12&ndash;16 shows the initial extent</span></p><p class="c0"><span class="c1">in a segment in a data file that previously contained no data.</span></p><p class="c0"><span class="c1">Figure 12&ndash;16 Initial Extent of a Segment</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Row Storage&quot; on page 2-19 and &quot;Rowids of Row Pieces&quot; on</span></p><p class="c0"><span class="c1">page 2-19</span></p><p class="c0"><span class="c1">&#9632; Oracle Database 2 Day DBA and Oracle Database Administrator&#39;s</span></p><p class="c0"><span class="c1">Guide to learn how to reclaim wasted space</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Performance Tuning Guide to learn about reducing</span></p><p class="c0"><span class="c1">chained and migrated rows</span></p><p class="c0"><span class="c1">Data File Header</span></p><p class="c0"><span class="c1">Used</span></p><p class="c0"><span class="c1">Free (Formatted, Never Used)</span></p><p class="c0"><span class="c1">Initial Extent</span></p><p class="c0"><span class="c1">of Segment</span></p><p class="c0"><span class="c1">Data Block</span></p><p class="c0"><span class="c1">(logically contiguous</span></p><p class="c0"><span class="c1">with other blocks</span></p><p class="c0"><span class="c1">in the extent)</span></p><p class="c0"><span class="c1">First Block of Segment</span></p><p class="c0"><span class="c1">(contains directory</span></p><p class="c0"><span class="c1">of extents)Overview of Extents</span></p><p class="c0"><span class="c1">Logical Storage Structures 12-19</span></p><p class="c0"><span class="c1">If the initial extent become full, and if more space is required, then the database</span></p><p class="c0"><span class="c1">automatically allocates an incremental extent for this segment. An incremental extent</span></p><p class="c0"><span class="c1">is a subsequent extent created for the segment.</span></p><p class="c0"><span class="c1">The allocation algorithm depends on whether the tablespace is locally managed or</span></p><p class="c0"><span class="c1">dictionary-managed. In the locally managed case, the database searches the bitmap of</span></p><p class="c0"><span class="c1">a data file for adjacent free blocks. If the data file has insufficient space, then the</span></p><p class="c0"><span class="c1">database looks in another data file. Extents for a segment are always in the same</span></p><p class="c0"><span class="c1">tablespace but may be in different data files.</span></p><p class="c0"><span class="c1">Figure 12&ndash;17 shows that the database can allocate extents for a segment in any data file</span></p><p class="c0"><span class="c1">in the tablespace. For example, the segment can allocate the initial extent in</span></p><p class="c0"><span class="c1">users01.dbf, allocate the first incremental extent in users02.dbf, and allocate the next</span></p><p class="c0"><span class="c1">extent in users01.dbf.</span></p><p class="c0"><span class="c1">Figure 12&ndash;17 Incremental Extent of a Segment</span></p><p class="c0"><span class="c1">The blocks of a newly allocated extent, although they were free, may not be empty of</span></p><p class="c0"><span class="c1">old data. In ASSM, Oracle Database formats the blocks of a newly allocated extent</span></p><p class="c0"><span class="c1">when it starts using the extent, but only as needed (see &quot;Segment Space and the High</span></p><p class="c0"><span class="c1">Water Mark&quot; on page 12-27).</span></p><p class="c0"><span class="c1">Deallocation of Extents</span></p><p class="c0"><span class="c1">In general, the extents of a user segment do not return to the tablespace unless you</span></p><p class="c0"><span class="c1">drop the object using a DROP command. In Oracle Database 11g Release 2 (11.2.0.2), you</span></p><p class="c0"><span class="c1">can also drop the segment using the DBMS_SPACE_ADMIN package. For example, if you</span></p><p class="c0"><span class="c1">delete all rows in a table, then the database does not reclaim the data blocks for use by</span></p><p class="c0"><span class="c1">other objects in the tablespace.</span></p><p class="c0"><span class="c1">Note: This section applies to serial operations, in which one server</span></p><p class="c0"><span class="c1">process parses and runs a statement. Extents are allocated differently</span></p><p class="c0"><span class="c1">in parallel SQL statements, which entail multiple server processes.</span></p><p class="c0"><span class="c1">See Also: Oracle Database Administrator&#39;s Guide to learn how to</span></p><p class="c0"><span class="c1">manually allocate extents</span></p><p class="c0"><span class="c1">Initial</span></p><p class="c0"><span class="c1">Extent</span></p><p class="c0"><span class="c1">users01.dbf</span></p><p class="c0"><span class="c1">Incremental</span></p><p class="c0"><span class="c1">Extents</span></p><p class="c0"><span class="c1">Space Used by Other Segments</span></p><p class="c0"><span class="c1">users02.dbf</span></p><p class="c0"><span class="c1">Data File Header</span></p><p class="c0"><span class="c1">Used</span></p><p class="c0"><span class="c1">Free (Formatted, Never Used)Overview of Extents</span></p><p class="c0"><span class="c1">12-20 Oracle Database Concepts</span></p><p class="c0"><span class="c1">In some circumstances, you can manually deallocate space. The Oracle Segment</span></p><p class="c0"><span class="c1">Advisor helps determine whether an object has space available for reclamation based</span></p><p class="c0"><span class="c1">on the level of fragmentation in the object. The following techniques can free extents:</span></p><p class="c0"><span class="c1">&#9632; You can use an online segment shrink to reclaim fragmented space in a segment.</span></p><p class="c0"><span class="c1">Segment shrink is an online, in-place operation. In general, data compaction leads</span></p><p class="c0"><span class="c1">to better cache utilization and requires fewer blocks to be read in a full table scan.</span></p><p class="c0"><span class="c1">&#9632; You can move the data of a nonpartitioned table or table partition into a new</span></p><p class="c0"><span class="c1">segment, and optionally into a different tablespace for which you have quota.</span></p><p class="c0"><span class="c1">&#9632; You can rebuild or coalesce the index (see &quot;Reuse of Index Space&quot; on page 12-14).</span></p><p class="c0"><span class="c1">&#9632; You can truncate a table or table cluster, which removes all rows. By default,</span></p><p class="c0"><span class="c1">Oracle Database deallocates all space used by the removed rows except that</span></p><p class="c0"><span class="c1">specified by the MINEXTENTS storage parameter. In Oracle Database 11g Release 2</span></p><p class="c0"><span class="c1">(11.2.0.2), you can also use TRUNCATE with the DROP ALL STORAGE option to drop</span></p><p class="c0"><span class="c1">entire segments.</span></p><p class="c0"><span class="c1">&#9632; You can deallocate unused space, which frees the unused space at the high water</span></p><p class="c0"><span class="c1">mark end of the database segment and makes the space available for other</span></p><p class="c0"><span class="c1">segments in the tablespace (see &quot;Segment Space and the High Water Mark&quot; on</span></p><p class="c0"><span class="c1">page 12-27).</span></p><p class="c0"><span class="c1">When extents are freed, Oracle Database modifies the bitmap in the data file for locally</span></p><p class="c0"><span class="c1">managed tablespaces to reflect the regained extents as available space. Any data in the</span></p><p class="c0"><span class="c1">blocks of freed extents becomes inaccessible.</span></p><p class="c0"><span class="c1">Storage Parameters for Extents</span></p><p class="c0"><span class="c1">Every segment is defined by storage parameters expressed in terms of extents. These</span></p><p class="c0"><span class="c1">parameters control how Oracle Database allocates free space for a segment.</span></p><p class="c0"><span class="c1">The storage settings are determined in the following order of precedence, with setting</span></p><p class="c0"><span class="c1">higher on the list overriding settings lower on the list:</span></p><p class="c0"><span class="c1">1. Segment storage clause</span></p><p class="c0"><span class="c1">2. Tablespace storage clause</span></p><p class="c0"><span class="c1">3. Oracle Database default</span></p><p class="c0"><span class="c1">A locally managed tablespace can have either uniform extent sizes or variable extent</span></p><p class="c0"><span class="c1">sizes determined automatically by the system:</span></p><p class="c0"><span class="c1">&#9632; For uniform extents, you can specify an extent size or use the default size of 1 MB.</span></p><p class="c0"><span class="c1">All extents in the tablespace are of this size. Locally managed temporary</span></p><p class="c0"><span class="c1">tablespaces can only use this type of allocation.</span></p><p class="c0"><span class="c1">&#9632; For automatically allocated extents, Oracle Database determines the optimal size</span></p><p class="c0"><span class="c1">of additional extents.</span></p><p class="c0"><span class="c1">Note: In an undo segment, Oracle Database periodically deallocates</span></p><p class="c0"><span class="c1">one or more extents if it has the OPTIMAL size specified or if the</span></p><p class="c0"><span class="c1">database is in automatic undo management mode (see &quot;Undo</span></p><p class="c0"><span class="c1">Tablespaces&quot; on page 12-33).</span></p><p class="c0"><span class="c1">See Also: Oracle Database Administrator&#39;s Guide to learn how to</span></p><p class="c0"><span class="c1">reclaim segment spaceOverview of Segments</span></p><p class="c0"><span class="c1">Logical Storage Structures 12-21</span></p><p class="c0"><span class="c1">For locally managed tablespaces, some storage parameters cannot be specified at the</span></p><p class="c0"><span class="c1">tablespace level. However, you can specify these parameters at the segment level. In</span></p><p class="c0"><span class="c1">this case, the databases uses all parameters together to compute the initial size of the</span></p><p class="c0"><span class="c1">segment. Internal algorithms determine the subsequent size of each extent.</span></p><p class="c0"><span class="c1">Overview of Segments</span></p><p class="c0"><span class="c1">A segment is a set of extents that contains all the data for a logical storage structure</span></p><p class="c0"><span class="c1">within a tablespace. For example, Oracle Database allocates one or more extents to</span></p><p class="c0"><span class="c1">form the data segment for a table. The database also allocates one or more extents to</span></p><p class="c0"><span class="c1">form the index segment for a table.</span></p><p class="c0"><span class="c1">As explained in &quot;Logical Space Management&quot;, Oracle Database manages segment</span></p><p class="c0"><span class="c1">space automatically or manually. This section assumes the use of ASSM.</span></p><p class="c0"><span class="c1">User Segments</span></p><p class="c0"><span class="c1">A single data segment in a database stores the data for one user object. There are</span></p><p class="c0"><span class="c1">different types of segments. Examples of user segments include:</span></p><p class="c0"><span class="c1">&#9632; Table, table partition, or table cluster</span></p><p class="c0"><span class="c1">&#9632; LOB or LOB partition</span></p><p class="c0"><span class="c1">&#9632; Index or index partition</span></p><p class="c0"><span class="c1">Each nonpartitioned object and object partition is stored in its own segment. For</span></p><p class="c0"><span class="c1">example, if an index has five partitions, then five segments contain the index data.</span></p><p class="c0"><span class="c1">User Segment Creation</span></p><p class="c0"><span class="c1">By default, the database uses deferred segment creation to update only database</span></p><p class="c0"><span class="c1">metadata when creating tables and indexes. Starting in Oracle Database 11g Release 2</span></p><p class="c0"><span class="c1">(11.2.0.2), the database also defers segment creation when creating partitions. When a</span></p><p class="c0"><span class="c1">user inserts the first row into a table or partition, the database creates segments for the</span></p><p class="c0"><span class="c1">table or partition, its LOB columns, and its indexes.</span></p><p class="c0"><span class="c1">Deferred segment creation enables you to avoid using database resources</span></p><p class="c0"><span class="c1">unnecessarily. For example, installation of an application can create thousands of</span></p><p class="c0"><span class="c1">objects, consuming significant disk space. Many of these objects may never be used.</span></p><p class="c0"><span class="c1">You can use the DBMS_SPACE_ADMIN package to manage segments for empty objects.</span></p><p class="c0"><span class="c1">Starting with Oracle Database 11g Release 2 (11.2.0.2), you can use this PL/SQL</span></p><p class="c0"><span class="c1">package to do the following:</span></p><p class="c0"><span class="c1">&#9632; Manually materialize segments for empty tables or partitions that do not have</span></p><p class="c0"><span class="c1">segments created</span></p><p class="c0"><span class="c1">&#9632; Remove segments from empty tables or partitions that currently have an empty</span></p><p class="c0"><span class="c1">segment allocated</span></p><p class="c0"><span class="c1">To best illustrate the relationship between object creation and segment creation,</span></p><p class="c0"><span class="c1">assume that deferred segment creation is disabled. You create a table as follows:</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn about extent</span></p><p class="c0"><span class="c1">management considerations when creating a locally managed</span></p><p class="c0"><span class="c1">tablespace</span></p><p class="c0"><span class="c1">&#9632; Oracle Database SQL Language Reference to learn about options in</span></p><p class="c0"><span class="c1">the storage clauseOverview of Segments</span></p><p class="c0"><span class="c1">12-22 Oracle Database Concepts</span></p><p class="c0"><span class="c1">CREATE TABLE test_table (my_column NUMBER);</span></p><p class="c0"><span class="c1">As shown in Figure 12&ndash;18, the database creates one segment for the table.</span></p><p class="c0"><span class="c1">Figure 12&ndash;18 Creation of a User Segment</span></p><p class="c0"><span class="c1">When you create a table with a primary key or unique key, Oracle Database</span></p><p class="c0"><span class="c1">automatically creates an index for this key. Again assume that deferred segment</span></p><p class="c0"><span class="c1">creation is disabled. You create a table as follows:</span></p><p class="c0"><span class="c1">CREATE TABLE lob_table (my_column NUMBER PRIMARY KEY, clob_column CLOB);</span></p><p class="c0"><span class="c1">Figure 12&ndash;19 shows that the data for lob_table is stored in one segment, while the</span></p><p class="c0"><span class="c1">implicitly created index is in a different segment. Also, the CLOB data is stored in its</span></p><p class="c0"><span class="c1">own segment, as is its associated CLOB index (see &quot;Internal LOBs&quot; on page 19-12).</span></p><p class="c0"><span class="c1">Thus, the CREATE TABLE statement results in the creation of four different segments.</span></p><p class="c0"><span class="c1">Figure 12&ndash;19 Multiple Segments</span></p><p class="c0"><span class="c1">The database allocates one or more extents when a segment is created. Storage</span></p><p class="c0"><span class="c1">parameters for the object determine how the extents for each segment are allocated</span></p><p class="c0"><span class="c1">(see &quot;Storage Parameters for Extents&quot; on page 12-20). The parameters affect the</span></p><p class="c0"><span class="c1">efficiency of data retrieval and storage for the data segment associated with the object.</span></p><p class="c0"><span class="c1">Note: The segments of a table and the index for this table do not</span></p><p class="c0"><span class="c1">have to occupy the same tablespace.</span></p><p class="c0"><span class="c1">SQL Statement Schema Object Segment</span></p><p class="c0"><span class="c1">test_table</span></p><p class="c0"><span class="c1">CREATE TABLE</span></p><p class="c0"><span class="c1">test_table</span></p><p class="c0"><span class="c1">(my_column</span></p><p class="c0"><span class="c1">NUMBER);</span></p><p class="c0"><span class="c1">SQL Statement Schema Object Segment</span></p><p class="c0"><span class="c1">Table</span></p><p class="c0"><span class="c1">lob_table</span></p><p class="c0"><span class="c1">Index on</span></p><p class="c0"><span class="c1">my_column</span></p><p class="c0"><span class="c1">CLOB</span></p><p class="c0"><span class="c1">Index on</span></p><p class="c0"><span class="c1">CLOB</span></p><p class="c0"><span class="c1">CREATE TABLE</span></p><p class="c0"><span class="c1">lob_table</span></p><p class="c0"><span class="c1">(my_column</span></p><p class="c0"><span class="c1">NUMBER PRIMARY</span></p><p class="c0"><span class="c1">KEY, clob_column</span></p><p class="c0"><span class="c1">CLOB);Overview of Segments</span></p><p class="c0"><span class="c1">Logical Storage Structures 12-23</span></p><p class="c0"><span class="c1">Temporary Segments</span></p><p class="c0"><span class="c1">When processing a query, Oracle Database often requires temporary workspace for</span></p><p class="c0"><span class="c1">intermediate stages of SQL statement execution. Typical operations that may require a</span></p><p class="c0"><span class="c1">temporary segment include sorting, hashing, and merging bitmaps. While creating an</span></p><p class="c0"><span class="c1">index, Oracle Database also places index segments into temporary segments and then</span></p><p class="c0"><span class="c1">converts them into permanent segments when the index is complete.</span></p><p class="c0"><span class="c1">Oracle Database does not create a temporary segment if an operation can be</span></p><p class="c0"><span class="c1">performed in memory. However, if memory use is not possible, then the database</span></p><p class="c0"><span class="c1">automatically allocates a temporary segment on disk.</span></p><p class="c0"><span class="c1">Allocation of Temporary Segments for Queries</span></p><p class="c0"><span class="c1">Oracle Database allocates temporary segments for queries as needed during a user</span></p><p class="c0"><span class="c1">session and drops them when the query completes. Changes to temporary segments</span></p><p class="c0"><span class="c1">are not recorded in the online redo log, except for space management operations on</span></p><p class="c0"><span class="c1">the temporary segment (see &quot;Overview of the Online Redo Log&quot; on page 11-12).</span></p><p class="c0"><span class="c1">The database creates temporary segments in the temporary tablespace assigned to the</span></p><p class="c0"><span class="c1">user. The default storage characteristics of the tablespace determine the characteristics</span></p><p class="c0"><span class="c1">of the extents in the temporary segment. Because allocation and deallocation of</span></p><p class="c0"><span class="c1">temporary segments occurs frequently, the best practice is to create at least one special</span></p><p class="c0"><span class="c1">tablespace for temporary segments. The database distributes I/O across disks and</span></p><p class="c0"><span class="c1">avoids fragmenting SYSTEM and other tablespaces with temporary segments.</span></p><p class="c0"><span class="c1">Allocation of Temporary Segments for Temporary Tables and Indexes</span></p><p class="c0"><span class="c1">Oracle Database can also allocate temporary segments for temporary tables and their</span></p><p class="c0"><span class="c1">indexes. Temporary tables hold data that exists only for the duration of a transaction</span></p><p class="c0"><span class="c1">or session. Each session accesses only the extents allocated for the session and cannot</span></p><p class="c0"><span class="c1">access extents allocated for other sessions.</span></p><p class="c0"><span class="c1">Oracle Database allocates segments for a temporary table when the first INSERT into</span></p><p class="c0"><span class="c1">that table occurs. The insertion can occur explicitly or because of CREATE TABLE AS</span></p><p class="c0"><span class="c1">SELECT. The first INSERT into a temporary table allocates the segments for the table and</span></p><p class="c0"><span class="c1">its indexes, creates the root page for the indexes, and allocates any LOB segments.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn how to manage</span></p><p class="c0"><span class="c1">deferred segment creation</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Advanced Replication for information on</span></p><p class="c0"><span class="c1">materialized views and materialized view logs</span></p><p class="c0"><span class="c1">&#9632; Oracle Database SQL Language Reference for CREATE TABLE syntax</span></p><p class="c0"><span class="c1">Note: When SYSTEM is locally managed, you must define a default</span></p><p class="c0"><span class="c1">temporary tablespace at database creation. A locally managed SYSTEM</span></p><p class="c0"><span class="c1">tablespace cannot be used for default temporary storage.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn how to create</span></p><p class="c0"><span class="c1">temporary tablespaces</span></p><p class="c0"><span class="c1">&#9632; Oracle Database SQL Language Reference for CREATE TEMPORARY</span></p><p class="c0"><span class="c1">TABLESPACE syntax and semanticsOverview of Segments</span></p><p class="c0"><span class="c1">12-24 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Segments for a temporary table are allocated in a temporary tablespace of the current</span></p><p class="c0"><span class="c1">user. Assume that the temporary tablespace assigned to user1 is temp1 and the</span></p><p class="c0"><span class="c1">temporary tablespace assigned to user2 is temp2. In this case, user1 stores temporary</span></p><p class="c0"><span class="c1">data in the temp1 segments, while user2 stores temporary data in the temp2 segments.</span></p><p class="c0"><span class="c1">Undo Segments</span></p><p class="c0"><span class="c1">Oracle Database maintains records of the actions of transactions, collectively known as</span></p><p class="c0"><span class="c1">undo data. Oracle Database uses undo to do the following:</span></p><p class="c0"><span class="c1">&#9632; Roll back an active transaction</span></p><p class="c0"><span class="c1">&#9632; Recover a terminated transaction</span></p><p class="c0"><span class="c1">&#9632; Provide read consistency</span></p><p class="c0"><span class="c1">&#9632; Perform some logical flashback operations</span></p><p class="c0"><span class="c1">Oracle Database stores undo data inside the database rather than in external logs.</span></p><p class="c0"><span class="c1">Undo data is stored in blocks that are updated just like data blocks, with changes to</span></p><p class="c0"><span class="c1">these blocks generating redo. In this way, Oracle Database can efficiently access undo</span></p><p class="c0"><span class="c1">data without needing to read external logs.</span></p><p class="c0"><span class="c1">Undo data is stored in an undo tablespace. Oracle Database provides a fully</span></p><p class="c0"><span class="c1">automated mechanism, known as automatic undo management mode, for managing</span></p><p class="c0"><span class="c1">undo segments and space in an undo tablespace.</span></p><p class="c0"><span class="c1">Undo Segments and Transactions</span></p><p class="c0"><span class="c1">When a transaction starts, the database binds (assigns) the transaction to an undo</span></p><p class="c0"><span class="c1">segment, and therefore to a transaction table, in the current undo tablespace. In rare</span></p><p class="c0"><span class="c1">circumstances, if the database instance does not have a designated undo tablespace,</span></p><p class="c0"><span class="c1">then the transaction binds to the system undo segment.</span></p><p class="c0"><span class="c1">Multiple active transactions can write concurrently to the same undo segment or to</span></p><p class="c0"><span class="c1">different segments. For example, transactions T1 and T2 can both write to undo</span></p><p class="c0"><span class="c1">segment U1, or T1 can write to U1 while T2 writes to undo segment U2.</span></p><p class="c0"><span class="c1">Conceptually, the extents in an undo segment form a ring. Transactions write to one</span></p><p class="c0"><span class="c1">undo extent, and then to the next extent in the ring, and so on in cyclical fashion.</span></p><p class="c0"><span class="c1">Figure 12&ndash;20 shows two transactions, T1 and T2, which begin writing in the third</span></p><p class="c0"><span class="c1">extent (E3) of an undo segment and continue writing to the fourth extent (E4).</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Temporary Tables&quot; on page 2-15</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn how to create</span></p><p class="c0"><span class="c1">temporary tablesOverview of Segments</span></p><p class="c0"><span class="c1">Logical Storage Structures 12-25</span></p><p class="c0"><span class="c1">Figure 12&ndash;20 Ring of Allocated Extents in an Undo Segment</span></p><p class="c0"><span class="c1">At any given time, a transaction writes sequentially to only one extent in an undo</span></p><p class="c0"><span class="c1">segment, known as the current extent for the transaction. Multiple active transactions</span></p><p class="c0"><span class="c1">can write simultaneously to the same current extent or to different current extents.</span></p><p class="c0"><span class="c1">Figure 12&ndash;20 shows transactions T1 and T2 writing simultaneously to extent E3.</span></p><p class="c0"><span class="c1">Within an undo extent, a data block contains data for only one transaction.</span></p><p class="c0"><span class="c1">As the current undo extent fills, the first transaction needing space checks the</span></p><p class="c0"><span class="c1">availability of the next allocated extent in the ring. If the next extent does not contain</span></p><p class="c0"><span class="c1">data from an active transaction, then this extent becomes the current extent. Now all</span></p><p class="c0"><span class="c1">transactions that need space can write to the new current extent. In Figure 12&ndash;21, when</span></p><p class="c0"><span class="c1">E4 is full, T1 and T2 continue writing to E1, overwriting the nonactive undo data in E1.</span></p><p class="c0"><span class="c1">E1</span></p><p class="c0"><span class="c1">E2</span></p><p class="c0"><span class="c1">E3</span></p><p class="c0"><span class="c1">E4</span></p><p class="c0"><span class="c1">E1</span></p><p class="c0"><span class="c1">E2</span></p><p class="c0"><span class="c1">E3</span></p><p class="c0"><span class="c1">E4</span></p><p class="c0"><span class="c1">UPDATE</span></p><p class="c0"><span class="c1">UPDATE</span></p><p class="c0"><span class="c1">INSERT</span></p><p class="c0"><span class="c1">INSERT</span></p><p class="c0"><span class="c1">UPDATE</span></p><p class="c0"><span class="c1">. . .</span></p><p class="c0"><span class="c1">UPDATE</span></p><p class="c0"><span class="c1">UPDATE</span></p><p class="c0"><span class="c1">INSERT</span></p><p class="c0"><span class="c1">INSERT</span></p><p class="c0"><span class="c1">UPDATE</span></p><p class="c0"><span class="c1">. . .</span></p><p class="c0"><span class="c1">Undo Segment</span></p><p class="c0"><span class="c1">Active extent without space</span></p><p class="c0"><span class="c1">Nonactive extent with space</span></p><p class="c0"><span class="c1">T2</span></p><p class="c0"><span class="c1">T1Overview of Segments</span></p><p class="c0"><span class="c1">12-26 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Figure 12&ndash;21 Cyclical Use of Allocated Extents in an Undo Segment</span></p><p class="c0"><span class="c1">If the next extent does contain data from an active transaction, then the database must</span></p><p class="c0"><span class="c1">allocate a new extent. Figure 12&ndash;22 shows a scenario in which T1 and T2 are writing to</span></p><p class="c0"><span class="c1">E4. When E4 fills up, the transactions cannot continue writing to E1 because E1</span></p><p class="c0"><span class="c1">contains active undo entries. Therefore, the database allocates a new extent (E5) for</span></p><p class="c0"><span class="c1">this undo segment. The transactions continue writing to E5.</span></p><p class="c0"><span class="c1">E1</span></p><p class="c0"><span class="c1">E2</span></p><p class="c0"><span class="c1">E3</span></p><p class="c0"><span class="c1">E4</span></p><p class="c0"><span class="c1">E1</span></p><p class="c0"><span class="c1">E2</span></p><p class="c0"><span class="c1">E3</span></p><p class="c0"><span class="c1">E4</span></p><p class="c0"><span class="c1">E1</span></p><p class="c0"><span class="c1">E2</span></p><p class="c0"><span class="c1">E3</span></p><p class="c0"><span class="c1">E4</span></p><p class="c0"><span class="c1">E2</span></p><p class="c0"><span class="c1">E3</span></p><p class="c0"><span class="c1">E4</span></p><p class="c0"><span class="c1">E1</span></p><p class="c0"><span class="c1">Undo Segment</span></p><p class="c0"><span class="c1">Active extent without space</span></p><p class="c0"><span class="c1">Nonactive extent with space</span></p><p class="c0"><span class="c1">T1</span></p><p class="c0"><span class="c1">T2</span></p><p class="c0"><span class="c1">UPDATE</span></p><p class="c0"><span class="c1">UPDATE</span></p><p class="c0"><span class="c1">INSERT</span></p><p class="c0"><span class="c1">INSERT</span></p><p class="c0"><span class="c1">UPDATE</span></p><p class="c0"><span class="c1">. . .</span></p><p class="c0"><span class="c1">UPDATE</span></p><p class="c0"><span class="c1">UPDATE</span></p><p class="c0"><span class="c1">INSERT</span></p><p class="c0"><span class="c1">INSERT</span></p><p class="c0"><span class="c1">UPDATE</span></p><p class="c0"><span class="c1">. . .Overview of Segments</span></p><p class="c0"><span class="c1">Logical Storage Structures 12-27</span></p><p class="c0"><span class="c1">Figure 12&ndash;22 Allocation of a New Extent for an Undo Segment</span></p><p class="c0"><span class="c1">Transaction Rollback</span></p><p class="c0"><span class="c1">When a ROLLBACK statement is issued, the database uses undo records to roll back</span></p><p class="c0"><span class="c1">changes made to the database by the uncommitted transaction. During recovery, the</span></p><p class="c0"><span class="c1">database rolls back any uncommitted changes applied from the online redo log to the</span></p><p class="c0"><span class="c1">data files. Undo records provide read consistency by maintaining the before image of</span></p><p class="c0"><span class="c1">the data for users accessing data at the same time that another user is changing it.</span></p><p class="c0"><span class="c1">Segment Space and the High Water Mark</span></p><p class="c0"><span class="c1">To manage space, Oracle Database tracks the state of blocks in the segment. The high</span></p><p class="c0"><span class="c1">water mark (HWM) is the point in a segment beyond which data blocks are</span></p><p class="c0"><span class="c1">unformatted and have never been used.</span></p><p class="c0"><span class="c1">MSSM uses free lists to manage segment space. At table creation, no blocks in the</span></p><p class="c0"><span class="c1">segment are formatted. When a session first inserts rows into the table, the database</span></p><p class="c0"><span class="c1">searches the free list for usable blocks. If the database finds no usable blocks, then it</span></p><p class="c0"><span class="c1">preformats a group of blocks, places them on the free list, and begins inserting data</span></p><p class="c0"><span class="c1">into the blocks. In MSSM, a full table scan reads all blocks below the HWM.</span></p><p class="c0"><span class="c1">ASSM does not use free lists and so must manage space differently. When a session</span></p><p class="c0"><span class="c1">first inserts data into a table, the database formats a single bitmap block instead of</span></p><p class="c0"><span class="c1">preformatting a group of blocks as in MSSM. The bitmap tracks the state of blocks in</span></p><p class="c0"><span class="c1">the segment, taking the place of the free list. The database uses the bitmap to find free</span></p><p class="c0"><span class="c1">blocks and then formats each block before filling it with data. ASSM spread out inserts</span></p><p class="c0"><span class="c1">among blocks to avoid concurrency issues.</span></p><p class="c0"><span class="c1">See Also: Oracle Database 2 Day DBA and Oracle Database</span></p><p class="c0"><span class="c1">Administrator&#39;s Guide to learn how to manage undo segments</span></p><p class="c0"><span class="c1">E2</span></p><p class="c0"><span class="c1">E3</span></p><p class="c0"><span class="c1">E4</span></p><p class="c0"><span class="c1">E5</span></p><p class="c0"><span class="c1">E1</span></p><p class="c0"><span class="c1">New Extent</span></p><p class="c0"><span class="c1">Active extent without space</span></p><p class="c0"><span class="c1">Nonactive extent with space</span></p><p class="c0"><span class="c1">Undo Segment</span></p><p class="c0"><span class="c1">T1</span></p><p class="c0"><span class="c1">T2</span></p><p class="c0"><span class="c1">UPDATE</span></p><p class="c0"><span class="c1">UPDATE</span></p><p class="c0"><span class="c1">INSERT</span></p><p class="c0"><span class="c1">INSERT</span></p><p class="c0"><span class="c1">UPDATE</span></p><p class="c0"><span class="c1">. . .</span></p><p class="c0"><span class="c1">UPDATE</span></p><p class="c0"><span class="c1">UPDATE</span></p><p class="c0"><span class="c1">INSERT</span></p><p class="c0"><span class="c1">INSERT</span></p><p class="c0"><span class="c1">UPDATE</span></p><p class="c0"><span class="c1">. . .Overview of Segments</span></p><p class="c0"><span class="c1">12-28 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Every data block in an ASSM segment is in one of the following states:</span></p><p class="c0"><span class="c1">&#9632; Above the HWM</span></p><p class="c0"><span class="c1">These blocks are unformatted and have never been used.</span></p><p class="c0"><span class="c1">&#9632; Below the HWM</span></p><p class="c0"><span class="c1">These blocks are in one of the following states:</span></p><p class="c0"><span class="c1">&ndash; Allocated, but currently unformatted and unused</span></p><p class="c0"><span class="c1">&ndash; Formatted and contain data</span></p><p class="c0"><span class="c1">&ndash; Formatted and empty because the data was deleted</span></p><p class="c0"><span class="c1">Figure 12&ndash;23 depicts an ASSM segment as a horizontal series of blocks. At table</span></p><p class="c0"><span class="c1">creation, the HWM is at the beginning of the segment on the left. Because no data has</span></p><p class="c0"><span class="c1">been inserted yet, all blocks in the segment are unformatted and never used.</span></p><p class="c0"><span class="c1">Figure 12&ndash;23 HWM at Table Creation</span></p><p class="c0"><span class="c1">Suppose that a transaction inserts rows into the segment. The database must allocate a</span></p><p class="c0"><span class="c1">group of blocks to hold the rows. The allocated blocks fall below the HWM. The</span></p><p class="c0"><span class="c1">database formats a bitmap block in this group to hold the metadata, but does not</span></p><p class="c0"><span class="c1">preformat the remaining blocks in the group.</span></p><p class="c0"><span class="c1">In Figure 12&ndash;24, the blocks below the HWM are allocated, whereas blocks above the</span></p><p class="c0"><span class="c1">HWM are neither allocated or formatted. As inserts occur, the database can write to</span></p><p class="c0"><span class="c1">any block with available space. The low high water mark (low HWM) marks the point</span></p><p class="c0"><span class="c1">below which all blocks are known to be formatted because they either contain data or</span></p><p class="c0"><span class="c1">formerly contained data.</span></p><p class="c0"><span class="c1">HWM at Table Creation</span></p><p class="c0"><span class="c1">Never Used,</span></p><p class="c0"><span class="c1">UnformattedOverview of Segments</span></p><p class="c0"><span class="c1">Logical Storage Structures 12-29</span></p><p class="c0"><span class="c1">Figure 12&ndash;24 HWM and Low HWM</span></p><p class="c0"><span class="c1">In Figure 12&ndash;25, the database chooses a block between the HWM and low HWM and</span></p><p class="c0"><span class="c1">writes to it. The database could have just as easily chosen any other block between the</span></p><p class="c0"><span class="c1">HWM and low HWM, or any block below the low HWM that had available space. In</span></p><p class="c0"><span class="c1">Figure 12&ndash;25, the blocks to either side of the newly filled block are unformatted.</span></p><p class="c0"><span class="c1">Figure 12&ndash;25 HWM and Low HWM</span></p><p class="c0"><span class="c1">The low HWM is important in a full table scan. Because blocks below the HWM are</span></p><p class="c0"><span class="c1">formatted only when used, some blocks could be unformatted, as in Figure 12&ndash;25. For</span></p><p class="c0"><span class="c1">this reason, the database reads the bitmap block to obtain the location of the low</span></p><p class="c0"><span class="c1">HWM. The database reads all blocks up to the low HWM because they are known to</span></p><p class="c0"><span class="c1">be formatted, and then carefully reads only the formatted blocks between the low</span></p><p class="c0"><span class="c1">HWM and the HWM.</span></p><p class="c0"><span class="c1">Assume that a new transaction inserts rows into the table, but the bitmap indicates</span></p><p class="c0"><span class="c1">that insufficient free space exists under the HWM. In Figure 12&ndash;26, the database</span></p><p class="c0"><span class="c1">advances the HWM to the right, allocating a new group of unformatted blocks.</span></p><p class="c0"><span class="c1">Low HWM HWM</span></p><p class="c0"><span class="c1">Never Used,</span></p><p class="c0"><span class="c1">Unformatted</span></p><p class="c0"><span class="c1">Used</span></p><p class="c0"><span class="c1">Low HWM HWM</span></p><p class="c0"><span class="c1">Never Used,</span></p><p class="c0"><span class="c1">Unformatted</span></p><p class="c0"><span class="c1">UsedOverview of Tablespaces</span></p><p class="c0"><span class="c1">12-30 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Figure 12&ndash;26 Advancing HWM and Low HWM</span></p><p class="c0"><span class="c1">When the blocks between the HWM and low HWM are full, the HWM advances to the</span></p><p class="c0"><span class="c1">right and the low HWM advances to the location of the old HWM. As the database</span></p><p class="c0"><span class="c1">inserts data over time, the HWM continues to advance to the right, with the low HWM</span></p><p class="c0"><span class="c1">always trailing behind it. Unless you manually rebuild, truncate, or shrink the object,</span></p><p class="c0"><span class="c1">the HWM never retreats.</span></p><p class="c0"><span class="c1">Overview of Tablespaces</span></p><p class="c0"><span class="c1">A tablespace is a logical storage container for segments. Segments are database</span></p><p class="c0"><span class="c1">objects, such as tables and indexes, that consume storage space. At the physical level, a</span></p><p class="c0"><span class="c1">tablespace stores data in one or more data files or temp files.</span></p><p class="c0"><span class="c1">A database must have the SYSTEM and SYSAUX tablespaces. Figure 12&ndash;27 shows the</span></p><p class="c0"><span class="c1">tablespaces in a typical database. The following sections describe the tablespace types.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn how to shrink</span></p><p class="c0"><span class="c1">segments online</span></p><p class="c0"><span class="c1">&#9632; Oracle Database SQL Language Reference for TRUNCATE TABLE syntax</span></p><p class="c0"><span class="c1">and semantics</span></p><p class="c0"><span class="c1">Low HWM HWM</span></p><p class="c0"><span class="c1">Never Used,</span></p><p class="c0"><span class="c1">Unformatted</span></p><p class="c0"><span class="c1">UsedOverview of Tablespaces</span></p><p class="c0"><span class="c1">Logical Storage Structures 12-31</span></p><p class="c0"><span class="c1">Figure 12&ndash;27 Tablespaces</span></p><p class="c0"><span class="c1">Permanent Tablespaces</span></p><p class="c0"><span class="c1">A permanent tablespace groups persistent schema objects. The segments for objects in</span></p><p class="c0"><span class="c1">the tablespace are stored physically in data files.</span></p><p class="c0"><span class="c1">Each database user is assigned a default permanent tablespace. A very small database</span></p><p class="c0"><span class="c1">may need only the default SYSTEM and SYSAUX tablespaces. However, Oracle</span></p><p class="c0"><span class="c1">recommends that you create at least one tablespace to store user and application data.</span></p><p class="c0"><span class="c1">You can use tablespaces to achieve the following goals:</span></p><p class="c0"><span class="c1">&#9632; Control disk space allocation for database data</span></p><p class="c0"><span class="c1">&#9632; Assign a quota (space allowance or limit) to a database user</span></p><p class="c0"><span class="c1">&#9632; Take individual tablespaces online or offline without affecting the availability of</span></p><p class="c0"><span class="c1">the whole database</span></p><p class="c0"><span class="c1">&#9632; Perform backup and recovery of individual tablespaces</span></p><p class="c0"><span class="c1">&#9632; Import or export application data by using the Oracle Data Pump utility (see</span></p><p class="c0"><span class="c1">&quot;Oracle Data Pump Export and Import&quot; on page 18-7)</span></p><p class="c0"><span class="c1">&#9632; Create a transportable tablespace that you can copy or move from one database to</span></p><p class="c0"><span class="c1">another, even across platforms</span></p><p class="c0"><span class="c1">Moving data by transporting tablespaces can be orders of magnitude faster than</span></p><p class="c0"><span class="c1">either export/import or unload/load of the same data, because transporting a</span></p><p class="c0"><span class="c1">tablespace involves only copying data files and integrating the tablespace</span></p><p class="c0"><span class="c1">metadata. When you transport tablespaces you can also move index data.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn how to transport</span></p><p class="c0"><span class="c1">tablespaces</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Utilities to learn about Oracle Data Pump</span></p><p class="c0"><span class="c1">&#9632; Oracle Streams Concepts and Administration for more information on</span></p><p class="c0"><span class="c1">ways to copy or transport files</span></p><p class="c0"><span class="c1">Optional User</span></p><p class="c0"><span class="c1">Tablespace</span></p><p class="c0"><span class="c1">10101 10101</span></p><p class="c0"><span class="c1">SYSTEM SYSAUX UNDO Optional User</span></p><p class="c0"><span class="c1">Tablespace TEMP</span></p><p class="c0"><span class="c1">Permanent</span></p><p class="c0"><span class="c1">Tablespaces</span></p><p class="c0"><span class="c1">Temporary</span></p><p class="c0"><span class="c1">Tablespaces</span></p><p class="c0"><span class="c1">10101</span></p><p class="c0"><span class="c1">10101 10101</span></p><p class="c0"><span class="c1">10101</span></p><p class="c0"><span class="c1">10101 10101 10101 10101</span></p><p class="c0"><span class="c1">10101</span></p><p class="c0"><span class="c1">10101 10101</span></p><p class="c0"><span class="c1">10101</span></p><p class="c0"><span class="c1">10101 10101</span></p><p class="c0"><span class="c1">Data Files Temp Files</span></p><p class="c0"><span class="c1">Logical</span></p><p class="c0"><span class="c1">PhysicalOverview of Tablespaces</span></p><p class="c0"><span class="c1">12-32 Oracle Database Concepts</span></p><p class="c0"><span class="c1">The SYSTEM Tablespace</span></p><p class="c0"><span class="c1">The SYSTEM tablespace is a necessary administrative tablespace included with the</span></p><p class="c0"><span class="c1">database when it is created. Oracle Database uses SYSTEM to manage the database.</span></p><p class="c0"><span class="c1">The SYSTEM tablespace includes the following information, all owned by the SYS user:</span></p><p class="c0"><span class="c1">&#9632; The data dictionary</span></p><p class="c0"><span class="c1">&#9632; Tables and views that contain administrative information about the database</span></p><p class="c0"><span class="c1">&#9632; Compiled stored objects such as triggers, procedures, and packages</span></p><p class="c0"><span class="c1">The SYSTEM tablespace is managed as any other tablespace, but requires a higher level</span></p><p class="c0"><span class="c1">of privilege and is restricted in some ways. For example, you cannot rename or drop</span></p><p class="c0"><span class="c1">the SYSTEM tablespace.</span></p><p class="c0"><span class="c1">By default, Oracle Database sets all newly created user tablespaces to be locally</span></p><p class="c0"><span class="c1">managed. In a database with a locally managed SYSTEM tablespace, you cannot create</span></p><p class="c0"><span class="c1">dictionary-managed tablespaces (which are deprecated). However, if you execute the</span></p><p class="c0"><span class="c1">CREATE DATABASE statement manually and accept the defaults, then the SYSTEM</span></p><p class="c0"><span class="c1">tablespace is dictionary managed. You can migrate an existing dictionary-managed</span></p><p class="c0"><span class="c1">SYSTEM tablespace to a locally managed format.</span></p><p class="c0"><span class="c1">The SYSAUX Tablespace</span></p><p class="c0"><span class="c1">The SYSAUX tablespace is an auxiliary tablespace to the SYSTEM tablespace. The SYSAUX</span></p><p class="c0"><span class="c1">tablespace provides a centralized location for database metadata that does not reside</span></p><p class="c0"><span class="c1">in the SYSTEM tablespace. It reduces the number of tablespaces created by default, both</span></p><p class="c0"><span class="c1">in the seed database and in user-defined databases.</span></p><p class="c0"><span class="c1">Several database components, including Oracle Enterprise Manager and Oracle</span></p><p class="c0"><span class="c1">Streams, use the SYSAUX tablespace as their default storage location. Therefore, the</span></p><p class="c0"><span class="c1">SYSAUX tablespace is created automatically during database creation or upgrade.</span></p><p class="c0"><span class="c1">During normal database operation, the database does not allow the SYSAUX tablespace</span></p><p class="c0"><span class="c1">to be dropped or renamed. If the SYSAUX tablespace becomes unavailable, then core</span></p><p class="c0"><span class="c1">database functionality remains operational. The database features that use the SYSAUX</span></p><p class="c0"><span class="c1">tablespace could fail, or function with limited capability.</span></p><p class="c0"><span class="c1">Note: Oracle strongly recommends that you use Database</span></p><p class="c0"><span class="c1">Configuration Assistant (DBCA) to create new databases so that all</span></p><p class="c0"><span class="c1">tablespaces, including SYSTEM, are locally managed by default.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Online and Offline Tablespaces&quot; on page 12-35 for information</span></p><p class="c0"><span class="c1">about the permanent online condition of the SYSTEM tablespace</span></p><p class="c0"><span class="c1">&#9632; &quot;Tools for Database Installation and Configuration&quot; on page 18-4</span></p><p class="c0"><span class="c1">to learn about DBCA</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn how to create or</span></p><p class="c0"><span class="c1">migrate to a locally managed SYSTEM tablespace</span></p><p class="c0"><span class="c1">&#9632; Oracle Database SQL Language Reference for CREATE DATABASE</span></p><p class="c0"><span class="c1">syntax and semantics</span></p><p class="c0"><span class="c1">See Also: Oracle Database Administrator&#39;s Guide to learn about the</span></p><p class="c0"><span class="c1">SYSAUX tablespaceOverview of Tablespaces</span></p><p class="c0"><span class="c1">Logical Storage Structures 12-33</span></p><p class="c0"><span class="c1">Undo Tablespaces</span></p><p class="c0"><span class="c1">An undo tablespace is a locally managed tablespace reserved for system-managed</span></p><p class="c0"><span class="c1">undo data (see &quot;Undo Segments&quot; on page 12-24). Like other permanent tablespaces,</span></p><p class="c0"><span class="c1">undo tablespaces contain data files. Undo blocks in these files are grouped in extents.</span></p><p class="c0"><span class="c1">Automatic Undo Management Mode Undo tablespaces require the database to be in the</span></p><p class="c0"><span class="c1">default automatic undo management mode. This mode eliminates the complexities of</span></p><p class="c0"><span class="c1">manually administering undo segments. The database automatically tunes itself to</span></p><p class="c0"><span class="c1">provide the best possible retention of undo data to satisfy long-running queries that</span></p><p class="c0"><span class="c1">may require this data.</span></p><p class="c0"><span class="c1">An undo tablespace is automatically created with a new installation of Oracle</span></p><p class="c0"><span class="c1">Database. Earlier versions of Oracle Database may not include an undo tablespace and</span></p><p class="c0"><span class="c1">use legacy rollback segments instead, known as manual undo management mode.</span></p><p class="c0"><span class="c1">When upgrading to Oracle Database 11g, you can enable automatic undo management</span></p><p class="c0"><span class="c1">mode and create an undo tablespace. Oracle Database contains an Undo Advisor that</span></p><p class="c0"><span class="c1">provides advice on and helps automate your undo environment.</span></p><p class="c0"><span class="c1">A database can contain multiple undo tablespaces, but only one can be in use at a time.</span></p><p class="c0"><span class="c1">When an instance attempts to open a database, Oracle Database automatically selects</span></p><p class="c0"><span class="c1">the first available undo tablespace. If no undo tablespace is available, then the instance</span></p><p class="c0"><span class="c1">starts without an undo tablespace and stores undo data in the SYSTEM tablespace.</span></p><p class="c0"><span class="c1">Storing undo data in SYSTEM is not recommended.</span></p><p class="c0"><span class="c1">Automatic Undo Retention The undo retention period is the minimum amount of time</span></p><p class="c0"><span class="c1">that Oracle Database attempts to retain old undo data before overwriting it. Undo</span></p><p class="c0"><span class="c1">retention is important because long-running queries may require older block images to</span></p><p class="c0"><span class="c1">supply read consistency. Also, some Oracle Flashback features can depend on undo</span></p><p class="c0"><span class="c1">availability.</span></p><p class="c0"><span class="c1">In general, it is desirable to retain old undo data as long as possible. After a transaction</span></p><p class="c0"><span class="c1">commits, undo data is no longer needed for rollback or transaction recovery. The</span></p><p class="c0"><span class="c1">database can retain old undo data if the undo tablespace has space for new</span></p><p class="c0"><span class="c1">transactions. When available space is low, the database begins to overwrite old undo</span></p><p class="c0"><span class="c1">data for committed transactions.</span></p><p class="c0"><span class="c1">Oracle Database automatically provides the best possible undo retention for the</span></p><p class="c0"><span class="c1">current undo tablespace. The database collects usage statistics and tunes the retention</span></p><p class="c0"><span class="c1">period based on these statistics and the undo tablespace size. If the undo tablespace is</span></p><p class="c0"><span class="c1">configured with the AUTOEXTEND option, and if the maximum size is not specified, then</span></p><p class="c0"><span class="c1">undo retention tuning is different. In this case, the database tunes the undo retention</span></p><p class="c0"><span class="c1">period to be slightly longer than the longest-running query, if space allows.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn about automatic</span></p><p class="c0"><span class="c1">undo management</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Upgrade Guide to learn how to migrate to</span></p><p class="c0"><span class="c1">automatic undo management mode</span></p><p class="c0"><span class="c1">&#9632; Oracle Database 2 Day DBA for information on the Undo Advisor</span></p><p class="c0"><span class="c1">and on how to use advisors</span></p><p class="c0"><span class="c1">See Also: Oracle Database Administrator&#39;s Guide for more details on</span></p><p class="c0"><span class="c1">automatic tuning of undo retentionOverview of Tablespaces</span></p><p class="c0"><span class="c1">12-34 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Temporary Tablespaces</span></p><p class="c0"><span class="c1">A temporary tablespace contains transient data that persists only for the duration of a</span></p><p class="c0"><span class="c1">session. No permanent schema objects can reside in a temporary tablespace. The</span></p><p class="c0"><span class="c1">database stores temporary tablespace data in temp files.</span></p><p class="c0"><span class="c1">Temporary tablespaces can improve the concurrency of multiple sort operations that</span></p><p class="c0"><span class="c1">do not fit in memory. These tablespaces also improve the efficiency of space</span></p><p class="c0"><span class="c1">management operations during sorts.</span></p><p class="c0"><span class="c1">When the SYSTEM tablespace is locally managed, a default temporary tablespace is</span></p><p class="c0"><span class="c1">included in the database by default during database creation. A locally managed</span></p><p class="c0"><span class="c1">SYSTEM tablespace cannot serve as default temporary storage.</span></p><p class="c0"><span class="c1">You can specify a user-named default temporary tablespace when you create a</span></p><p class="c0"><span class="c1">database by using the DEFAULT TEMPORARY TABLESPACE extension to the CREATE</span></p><p class="c0"><span class="c1">DATABASE statement. If SYSTEM is dictionary managed, and if a default temporary</span></p><p class="c0"><span class="c1">tablespace is not defined at database creation, then SYSTEM is the default temporary</span></p><p class="c0"><span class="c1">storage. However, the database writes a warning in the alert log saying that a default</span></p><p class="c0"><span class="c1">temporary tablespace is recommended.</span></p><p class="c0"><span class="c1">Tablespace Modes</span></p><p class="c0"><span class="c1">The tablespace mode determines the accessibility of the tablespace.</span></p><p class="c0"><span class="c1">Read/Write and Read-Only Tablespaces</span></p><p class="c0"><span class="c1">Every tablespace is in a write mode that specifies whether it can be written to. The</span></p><p class="c0"><span class="c1">mutually exclusive modes are as follows:</span></p><p class="c0"><span class="c1">&#9632; Read/write mode</span></p><p class="c0"><span class="c1">Users can read and write to the tablespace. All tablespaces are initially created as</span></p><p class="c0"><span class="c1">read/write. The SYSTEM and SYSAUX tablespaces and temporary tablespaces are</span></p><p class="c0"><span class="c1">permanently read/write, which means that they cannot be made read-only.</span></p><p class="c0"><span class="c1">&#9632; Read-only mode</span></p><p class="c0"><span class="c1">Write operations to the data files in the tablespace are prevented. A read-only</span></p><p class="c0"><span class="c1">tablespace can reside on read-only media such as DVDs or WORM drives.</span></p><p class="c0"><span class="c1">Read-only tablespaces eliminate the need to perform backup and recovery of</span></p><p class="c0"><span class="c1">large, static portions of a database. Read-only tablespaces do not change and thus</span></p><p class="c0"><span class="c1">do not require repeated backup. If you recover a database after a media failure,</span></p><p class="c0"><span class="c1">then you do not need to recover read-only tablespaces.</span></p><p class="c0"><span class="c1">Note: You cannot make a default temporary tablespace permanent.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Permanent and Temporary Data Files&quot; on page 11-8</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn how to create a</span></p><p class="c0"><span class="c1">default temporary tablespace</span></p><p class="c0"><span class="c1">&#9632; Oracle Database SQL Language Reference for the syntax of the</span></p><p class="c0"><span class="c1">DEFAULT TEMPORARY TABLESPACE clause of CREATE DATABASE and</span></p><p class="c0"><span class="c1">ALTER DATABASEOverview of Tablespaces</span></p><p class="c0"><span class="c1">Logical Storage Structures 12-35</span></p><p class="c0"><span class="c1">Online and Offline Tablespaces</span></p><p class="c0"><span class="c1">A tablespace can be online (accessible) or offline (not accessible) whenever the</span></p><p class="c0"><span class="c1">database is open. A tablespace is usually online so that its data is available to users.</span></p><p class="c0"><span class="c1">The SYSTEM tablespace and temporary tablespaces cannot be taken offline.</span></p><p class="c0"><span class="c1">A tablespace can go offline automatically or manually. For example, you can take a</span></p><p class="c0"><span class="c1">tablespace offline for maintenance or backup and recovery. The database automatically</span></p><p class="c0"><span class="c1">takes a tablespace offline when certain errors are encountered, as when the database</span></p><p class="c0"><span class="c1">writer (DBW) process fails in several attempts to write to a data file. Users trying to</span></p><p class="c0"><span class="c1">access tables in an offline tablespace receive an error.</span></p><p class="c0"><span class="c1">When a tablespace goes offline, the database does the following:</span></p><p class="c0"><span class="c1">&#9632; The database does not permit subsequent DML statements to reference objects in</span></p><p class="c0"><span class="c1">the offline tablespace. An offline tablespace cannot be read or edited by any utility</span></p><p class="c0"><span class="c1">other than Oracle Database.</span></p><p class="c0"><span class="c1">&#9632; Active transactions with completed statements that refer to data in that tablespace</span></p><p class="c0"><span class="c1">are not affected at the transaction level.</span></p><p class="c0"><span class="c1">&#9632; The database saves undo data corresponding to those completed statements in a</span></p><p class="c0"><span class="c1">deferred undo segment in the SYSTEM tablespace. When the tablespace is brought</span></p><p class="c0"><span class="c1">online, the database applies the undo data to the tablespace, if needed.</span></p><p class="c0"><span class="c1">Tablespace File Size</span></p><p class="c0"><span class="c1">A tablespace is either a bigfile tablespace or a smallfile tablespace. These tablespaces</span></p><p class="c0"><span class="c1">are indistinguishable in terms of execution of SQL statements that do not explicitly</span></p><p class="c0"><span class="c1">refer to data files or temp files. The difference is as follows:</span></p><p class="c0"><span class="c1">&#9632; A smallfile tablespace can contain multiple data files or temp files, but the files</span></p><p class="c0"><span class="c1">cannot be as large as in a bigfile tablespace. This is the default tablespace type.</span></p><p class="c0"><span class="c1">&#9632; A bigfile tablespace contains one very large data file or temp file. This type of</span></p><p class="c0"><span class="c1">tablespaces can do the following:</span></p><p class="c0"><span class="c1">&ndash; Increase the storage capacity of a database</span></p><p class="c0"><span class="c1">The maximum number of data files in a database is limited (usually to 64 KB</span></p><p class="c0"><span class="c1">files), so increasing the size of each data file increases the overall storage.</span></p><p class="c0"><span class="c1">&ndash; Reduce the burden of managing many data files and temp files</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn how to change a</span></p><p class="c0"><span class="c1">tablespace to read only or read/write mode</span></p><p class="c0"><span class="c1">&#9632; Oracle Database SQL Language Reference for ALTER TABLESPACE</span></p><p class="c0"><span class="c1">syntax and semantics</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Backup and Recovery User&#39;s Guide for more</span></p><p class="c0"><span class="c1">information about recovery</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Online and Offline Data Files&quot; on page 11-9</span></p><p class="c0"><span class="c1">&#9632; &quot;Database Writer Process (DBWn)&quot; on page 15-8</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn how to alter</span></p><p class="c0"><span class="c1">tablespace availabilityOverview of Tablespaces</span></p><p class="c0"><span class="c1">12-36 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Bigfile tablespaces simplify file management with Oracle Managed Files and</span></p><p class="c0"><span class="c1">Automatic Storage Management (Oracle ASM) by eliminating the need for</span></p><p class="c0"><span class="c1">adding new files and dealing with multiple files.</span></p><p class="c0"><span class="c1">&ndash; Perform operations on tablespaces rather than individual files</span></p><p class="c0"><span class="c1">Bigfile tablespaces make the tablespace the main unit of the disk space</span></p><p class="c0"><span class="c1">administration, backup and recovery, and so on.</span></p><p class="c0"><span class="c1">Bigfile tablespaces are supported only for locally managed tablespaces with</span></p><p class="c0"><span class="c1">ASSM. However, locally managed undo and temporary tablespaces can be bigfile</span></p><p class="c0"><span class="c1">tablespaces even when segments are manually managed.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Backup and Recovery&quot; on page 18-9</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn how to manage</span></p><p class="c0"><span class="c1">bigfile tablespacesPart V</span></p><p class="c0"><span class="c1">Part VOracle Instance Architecture</span></p><p class="c0"><span class="c1">This part describes the basic structural architecture of the Oracle database instance.</span></p><p class="c0"><span class="c1">This part contains the following chapters:</span></p><p class="c0"><span class="c1">&#9632; Chapter 13, &quot;Oracle Database Instance&quot;</span></p><p class="c0"><span class="c1">&#9632; Chapter 14, &quot;Memory Architecture&quot;</span></p><p class="c0"><span class="c1">&#9632; Chapter 15, &quot;Process Architecture&quot;</span></p><p class="c0"><span class="c1">&#9632; Chapter 16, &quot;Application and Networking Architecture&quot;13</span></p><p class="c0"><span class="c1">Oracle Database Instance 13-1</span></p><p class="c0"><span class="c1">Oracle Database Instance 3 1</span></p><p class="c0"><span class="c1">This chapter explains the nature of an Oracle database instance, the parameter and</span></p><p class="c0"><span class="c1">diagnostic files associated with an instance, and what occurs during instance creation</span></p><p class="c0"><span class="c1">and the opening and closing of a database.</span></p><p class="c0"><span class="c1">This chapter contains the following sections:</span></p><p class="c0"><span class="c1">&#9632; Introduction to the Oracle Database Instance</span></p><p class="c0"><span class="c1">&#9632; Overview of Instance Startup and Shutdown</span></p><p class="c0"><span class="c1">&#9632; Overview of Checkpoints</span></p><p class="c0"><span class="c1">&#9632; Overview of Instance Recovery</span></p><p class="c0"><span class="c1">&#9632; Overview of Parameter Files</span></p><p class="c0"><span class="c1">&#9632; Overview of Diagnostic Files</span></p><p class="c0"><span class="c1">Introduction to the Oracle Database Instance</span></p><p class="c0"><span class="c1">A database instance is a set of memory structures that manage database files. A</span></p><p class="c0"><span class="c1">database is a set of physical files on disk created by the CREATE DATABASE statement.</span></p><p class="c0"><span class="c1">The instance manages its associated data and serves the users of the database.</span></p><p class="c0"><span class="c1">Every running Oracle database is associated with at least one Oracle database instance.</span></p><p class="c0"><span class="c1">Because an instance exists in memory and a database exists on disk, an instance can</span></p><p class="c0"><span class="c1">exist without a database and a database can exist without an instance.</span></p><p class="c0"><span class="c1">Database Instance Structure</span></p><p class="c0"><span class="c1">When an instance is started, Oracle Database allocates a memory area called the</span></p><p class="c0"><span class="c1">system global area (SGA) and starts one or more background processes. The SGA</span></p><p class="c0"><span class="c1">serves various purposes, including the following:</span></p><p class="c0"><span class="c1">&#9632; Maintaining internal data structures that are accessed by many processes and</span></p><p class="c0"><span class="c1">threads concurrently</span></p><p class="c0"><span class="c1">&#9632; Caching data blocks read from disk</span></p><p class="c0"><span class="c1">&#9632; Buffering redo data before writing it to the online redo log files</span></p><p class="c0"><span class="c1">&#9632; Storing SQL execution plans</span></p><p class="c0"><span class="c1">The SGA is shared by the Oracle processes, which include server processes and</span></p><p class="c0"><span class="c1">background processes, running on a single computer. The way in which Oracle</span></p><p class="c0"><span class="c1">processes are associated with the SGA varies according to operating system.Introduction to the Oracle Database Instance</span></p><p class="c0"><span class="c1">13-2 Oracle Database Concepts</span></p><p class="c0"><span class="c1">A database instance includes background processes. Server processes, and the process</span></p><p class="c0"><span class="c1">memory allocated in these processes, also exist in the instance. The instance continues</span></p><p class="c0"><span class="c1">to function when server processes terminate.</span></p><p class="c0"><span class="c1">Figure 13&ndash;1 shows the main components of an Oracle database instance.</span></p><p class="c0"><span class="c1">Figure 13&ndash;1 Database Instance</span></p><p class="c0"><span class="c1">Database Instance Configurations</span></p><p class="c0"><span class="c1">You can run Oracle Database in either of the following mutually exclusive</span></p><p class="c0"><span class="c1">configurations:</span></p><p class="c0"><span class="c1">&#9632; Single-instance configuration</span></p><p class="c0"><span class="c1">A one-to-one relationship exists between the database and an instance.</span></p><p class="c0"><span class="c1">&#9632; Oracle Real Application Clusters (Oracle RAC) configuration</span></p><p class="c0"><span class="c1">A one-to-many relationship exists between the database and instances.</span></p><p class="c0"><span class="c1">Figure 13&ndash;2 shows possible database instance configurations.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Overview of the System Global Area&quot; on page 14-8</span></p><p class="c0"><span class="c1">&#9632; &quot;Overview of Background Processes&quot; on page 15-7</span></p><p class="c0"><span class="c1">System Global Area (SGA)</span></p><p class="c0"><span class="c1">Large Pool</span></p><p class="c0"><span class="c1">Instance</span></p><p class="c0"><span class="c1">Large Pool</span></p><p class="c0"><span class="c1">Response</span></p><p class="c0"><span class="c1">Queue</span></p><p class="c0"><span class="c1">Request</span></p><p class="c0"><span class="c1">Queue</span></p><p class="c0"><span class="c1">Shared Pool</span></p><p class="c0"><span class="c1">Private</span></p><p class="c0"><span class="c1">SQL Area</span></p><p class="c0"><span class="c1">(Shared</span></p><p class="c0"><span class="c1">Server Only)</span></p><p class="c0"><span class="c1">Shared SQL Area</span></p><p class="c0"><span class="c1">Library Cache</span></p><p class="c0"><span class="c1">Data</span></p><p class="c0"><span class="c1">Dictionary</span></p><p class="c0"><span class="c1">Cache</span></p><p class="c0"><span class="c1">Server</span></p><p class="c0"><span class="c1">Result</span></p><p class="c0"><span class="c1">Cache</span></p><p class="c0"><span class="c1">Other Reserved</span></p><p class="c0"><span class="c1">Pool</span></p><p class="c0"><span class="c1">SELECT * FROM</span></p><p class="c0"><span class="c1">employees</span></p><p class="c0"><span class="c1">PMON SMON DBWn LGWR CKPT Others</span></p><p class="c0"><span class="c1">Background Processes</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">Buffer Cache Redo</span></p><p class="c0"><span class="c1">Log</span></p><p class="c0"><span class="c1">Buffer</span></p><p class="c0"><span class="c1">Java</span></p><p class="c0"><span class="c1">Pool</span></p><p class="c0"><span class="c1">Streams</span></p><p class="c0"><span class="c1">Pool</span></p><p class="c0"><span class="c1">Fixed</span></p><p class="c0"><span class="c1">SGAIntroduction to the Oracle Database Instance</span></p><p class="c0"><span class="c1">Oracle Database Instance 13-3</span></p><p class="c0"><span class="c1">Figure 13&ndash;2 Database Instance Configurations</span></p><p class="c0"><span class="c1">Whether in a single-instance or Oracle RAC configuration, a database instance is</span></p><p class="c0"><span class="c1">associated with only one database at a time. You can start a database instance and</span></p><p class="c0"><span class="c1">mount (associate the instance with) one database, but not mount two databases</span></p><p class="c0"><span class="c1">simultaneously with the same instance.</span></p><p class="c0"><span class="c1">Multiple instances can run concurrently on the same computer, each accessing its own</span></p><p class="c0"><span class="c1">database. For example, a computer can host two distinct databases: prod1 and prod2.</span></p><p class="c0"><span class="c1">One database instance manages prod1, while a separate instance manages prod2.</span></p><p class="c0"><span class="c1">Duration of an Instance</span></p><p class="c0"><span class="c1">An instance begins when it is created with the STARTUP command and ends when it is</span></p><p class="c0"><span class="c1">terminated. During this period, an instance can associate itself with one and only one</span></p><p class="c0"><span class="c1">database. Furthermore, the instance can mount a database only once, close it only</span></p><p class="c0"><span class="c1">once, and open it only once. After a database has been closed or shut down, you must</span></p><p class="c0"><span class="c1">start a different instance to mount and open this database.</span></p><p class="c0"><span class="c1">Table 13&ndash;1 illustrates a database instance attempting to reopen a database that it</span></p><p class="c0"><span class="c1">previously closed.</span></p><p class="c0"><span class="c1">Note: This chapter discusses a single-instance database configuration</span></p><p class="c0"><span class="c1">unless otherwise noted.</span></p><p class="c0"><span class="c1">See Also: Oracle Real Application Clusters Administration and</span></p><p class="c0"><span class="c1">Deployment Guide for information specific to Oracle RAC</span></p><p class="c0"><span class="c1">Database Instance</span></p><p class="c0"><span class="c1">Single-Instance Database Oracle RAC Database</span></p><p class="c0"><span class="c1">10101</span></p><p class="c0"><span class="c1">10101</span></p><p class="c0"><span class="c1">10101 10101</span></p><p class="c0"><span class="c1">10101</span></p><p class="c0"><span class="c1">10101</span></p><p class="c0"><span class="c1">10101 10101</span></p><p class="c0"><span class="c1">Data</span></p><p class="c0"><span class="c1">Files</span></p><p class="c0"><span class="c1">Control</span></p><p class="c0"><span class="c1">Files</span></p><p class="c0"><span class="c1">Online</span></p><p class="c0"><span class="c1">Redo Log</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">10101</span></p><p class="c0"><span class="c1">10101</span></p><p class="c0"><span class="c1">10101 10101</span></p><p class="c0"><span class="c1">10101</span></p><p class="c0"><span class="c1">10101</span></p><p class="c0"><span class="c1">10101 10101</span></p><p class="c0"><span class="c1">Data</span></p><p class="c0"><span class="c1">Files</span></p><p class="c0"><span class="c1">Control</span></p><p class="c0"><span class="c1">Files</span></p><p class="c0"><span class="c1">Online</span></p><p class="c0"><span class="c1">Redo Log</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">Database Instance Database InstanceOverview of Instance Startup and Shutdown</span></p><p class="c0"><span class="c1">13-4 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Oracle System Identifier (SID)</span></p><p class="c0"><span class="c1">The system identifier (SID) is a unique name for an Oracle database instance on a</span></p><p class="c0"><span class="c1">specific host. On UNIX and Linux, Oracle Database uses the SID and Oracle home</span></p><p class="c0"><span class="c1">values to create a key to shared memory. Also, the SID is used by default to locate the</span></p><p class="c0"><span class="c1">parameter file, which is used to locate relevant files such as the database control files.</span></p><p class="c0"><span class="c1">On most platforms, the ORACLE_SID environment variable sets the SID, whereas the</span></p><p class="c0"><span class="c1">ORACLE_HOME variable sets the Oracle home. When connecting to an instance, clients</span></p><p class="c0"><span class="c1">can specify the SID in an Oracle Net connection or use a net service name. Oracle</span></p><p class="c0"><span class="c1">Database converts a service name into an ORACLE_HOME and ORACLE_SID.</span></p><p class="c0"><span class="c1">Overview of Instance Startup and Shutdown</span></p><p class="c0"><span class="c1">A database instance provides user access to a database. This section explains the</span></p><p class="c0"><span class="c1">possible states of the instance and the database.</span></p><p class="c0"><span class="c1">Table 13&ndash;1 Duration of an Instance</span></p><p class="c0"><span class="c1">Statement Explanation</span></p><p class="c0"><span class="c1">SQL&gt; STARTUP</span></p><p class="c0"><span class="c1">ORACLE instance started.</span></p><p class="c0"><span class="c1">Total System Global Area 468729856 bytes</span></p><p class="c0"><span class="c1">Fixed Size 1333556 bytes</span></p><p class="c0"><span class="c1">Variable Size 440403660 bytes</span></p><p class="c0"><span class="c1">Database Buffers 16777216 bytes</span></p><p class="c0"><span class="c1">Redo Buffers 10215424 bytes</span></p><p class="c0"><span class="c1">Database mounted.</span></p><p class="c0"><span class="c1">Database opened.</span></p><p class="c0"><span class="c1">The STARTUP command creates an</span></p><p class="c0"><span class="c1">instance, which mounts and opens the</span></p><p class="c0"><span class="c1">database.</span></p><p class="c0"><span class="c1">SQL&gt; SELECT</span></p><p class="c0"><span class="c1">TO_CHAR(STARTUP_TIME,&#39;MON-DD-RR HH24:MI:SS&#39;)</span></p><p class="c0"><span class="c1">AS &quot;Inst Start Time&quot; FROM V$INSTANCE;</span></p><p class="c0"><span class="c1">Inst Start Time</span></p><p class="c0"><span class="c1">------------------</span></p><p class="c0"><span class="c1">JUN-18-11 13:14:48</span></p><p class="c0"><span class="c1">This query shows the time that the</span></p><p class="c0"><span class="c1">current instance was started.</span></p><p class="c0"><span class="c1">SQL&gt; SHUTDOWN IMMEDIATE The instance closes the database and</span></p><p class="c0"><span class="c1">shuts down, ending the life of this</span></p><p class="c0"><span class="c1">instance.</span></p><p class="c0"><span class="c1">SQL&gt; STARTUP</span></p><p class="c0"><span class="c1">Oracle instance started.</span></p><p class="c0"><span class="c1">. . .</span></p><p class="c0"><span class="c1">The STARTUP command creates a new</span></p><p class="c0"><span class="c1">instance and mounts and open the</span></p><p class="c0"><span class="c1">database.</span></p><p class="c0"><span class="c1">SQL&gt; SELECT</span></p><p class="c0"><span class="c1">TO_CHAR(STARTUP_TIME,&#39;MON-DD-RR HH24:MI:SS&#39;)</span></p><p class="c0"><span class="c1">AS &quot;Inst Start Time&quot; FROM V$INSTANCE;</span></p><p class="c0"><span class="c1">Inst Start Time</span></p><p class="c0"><span class="c1">------------------</span></p><p class="c0"><span class="c1">JUN-18-11 13:16:40</span></p><p class="c0"><span class="c1">This query shows the time that the</span></p><p class="c0"><span class="c1">current instance was started. The</span></p><p class="c0"><span class="c1">different start time shows that this</span></p><p class="c0"><span class="c1">instance is different from the one that</span></p><p class="c0"><span class="c1">shut down the database.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Service Names&quot; on page 16-8</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn how to specify an</span></p><p class="c0"><span class="c1">Oracle SIDOverview of Instance Startup and Shutdown</span></p><p class="c0"><span class="c1">Oracle Database Instance 13-5</span></p><p class="c0"><span class="c1">Overview of Instance and Database Startup</span></p><p class="c0"><span class="c1">In a typical use case, you manually start an instance and then mount and open the</span></p><p class="c0"><span class="c1">database, making it available for users. You can use the SQL*Plus STARTUP command,</span></p><p class="c0"><span class="c1">Oracle Enterprise Manager (Enterprise Manager), or the SRVCTL utility to perform</span></p><p class="c0"><span class="c1">these steps. Figure 13&ndash;3 shows how a database progresses from a shutdown state to an</span></p><p class="c0"><span class="c1">open state.</span></p><p class="c0"><span class="c1">Figure 13&ndash;3 Instance and Database Startup Sequence</span></p><p class="c0"><span class="c1">A database goes through the following phases when it proceeds from a shutdown</span></p><p class="c0"><span class="c1">state to an open database state:</span></p><p class="c0"><span class="c1">1. Instance started without mounting database</span></p><p class="c0"><span class="c1">The instance is started, but is not yet associated with a database.</span></p><p class="c0"><span class="c1">&quot;How an Instance Is Started&quot; on page 13-6 explains this stage.</span></p><p class="c0"><span class="c1">2. Database mounted</span></p><p class="c0"><span class="c1">The instance is started and is associated with a database by reading its control file</span></p><p class="c0"><span class="c1">(see &quot;Overview of Control Files&quot; on page 11-10). The database is closed to users.</span></p><p class="c0"><span class="c1">&quot;How a Database Is Mounted&quot; on page 13-6 explains this stage.</span></p><p class="c0"><span class="c1">3. Database open</span></p><p class="c0"><span class="c1">The instance is started and is associated with an open database. The data</span></p><p class="c0"><span class="c1">contained in the data files is accessible to authorized users.</span></p><p class="c0"><span class="c1">&quot;How a Database Is Opened&quot; on page 13-7 explains this stage.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Oracle Enterprise Manager&quot; on page 18-2</span></p><p class="c0"><span class="c1">&#9632; Oracle Database 2 Day DBA and Oracle Database Administrator&#39;s</span></p><p class="c0"><span class="c1">Guide to learn how to start an instance</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn how to use SRVCTL</span></p><p class="c0"><span class="c1">Instance</span></p><p class="c0"><span class="c1">started</span></p><p class="c0"><span class="c1">Control file</span></p><p class="c0"><span class="c1">opened for</span></p><p class="c0"><span class="c1">this</span></p><p class="c0"><span class="c1">instance</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">opened</span></p><p class="c0"><span class="c1">for this</span></p><p class="c0"><span class="c1">instance</span></p><p class="c0"><span class="c1">STARTUP</span></p><p class="c0"><span class="c1">OPEN</span></p><p class="c0"><span class="c1">MOUNT</span></p><p class="c0"><span class="c1">NOMOUNT</span></p><p class="c0"><span class="c1">SHUTDOWNOverview of Instance Startup and Shutdown</span></p><p class="c0"><span class="c1">13-6 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Connection with Administrator Privileges</span></p><p class="c0"><span class="c1">Database startup and shutdown are powerful administrative options that are restricted</span></p><p class="c0"><span class="c1">to users who connect to Oracle Database with administrator privileges. Normal users</span></p><p class="c0"><span class="c1">do not have control over the current status of an Oracle database.</span></p><p class="c0"><span class="c1">Depending on the operating system, one of the following conditions establishes</span></p><p class="c0"><span class="c1">administrator privileges for a user:</span></p><p class="c0"><span class="c1">&#9632; The operating system privileges of the user enable him or her to connect using</span></p><p class="c0"><span class="c1">administrator privileges.</span></p><p class="c0"><span class="c1">&#9632; The user is granted the SYSDBA or SYSOPER system privileges and the database uses</span></p><p class="c0"><span class="c1">password files to authenticate database administrators over the network.</span></p><p class="c0"><span class="c1">SYSDBA and SYSOPER are special system privileges that enable access to a database</span></p><p class="c0"><span class="c1">instance even when the database is not open. Control of these privileges is outside of</span></p><p class="c0"><span class="c1">the database itself.</span></p><p class="c0"><span class="c1">When you connect with the SYSDBA system privilege, you are in the schema owned by</span></p><p class="c0"><span class="c1">SYS. When you connect as SYSOPER, you are in the public schema. SYSOPER privileges</span></p><p class="c0"><span class="c1">are a subset of SYSDBA privileges.</span></p><p class="c0"><span class="c1">How an Instance Is Started</span></p><p class="c0"><span class="c1">When Oracle Database starts an instance, it performs the following basic steps:</span></p><p class="c0"><span class="c1">1. Searches for a server parameter file in a platform-specific default location and, if</span></p><p class="c0"><span class="c1">not found, for a text initialization parameter file (specifying STARTUP with the</span></p><p class="c0"><span class="c1">SPFILE or PFILE parameters overrides the default behavior)</span></p><p class="c0"><span class="c1">2. Reads the parameter file to determine the values of initialization parameters</span></p><p class="c0"><span class="c1">3. Allocates the SGA based on the initialization parameter settings</span></p><p class="c0"><span class="c1">4. Starts the Oracle background processes</span></p><p class="c0"><span class="c1">5. Opens the alert log and trace files and writes all explicit parameter settings to the</span></p><p class="c0"><span class="c1">alert log in valid parameter syntax</span></p><p class="c0"><span class="c1">At this stage, no database is associated with the instance. Scenarios that require a</span></p><p class="c0"><span class="c1">NOMOUNT state include database creation and certain backup and recovery operations.</span></p><p class="c0"><span class="c1">How a Database Is Mounted</span></p><p class="c0"><span class="c1">The instance mounts a database to associate the database with this instance. To mount</span></p><p class="c0"><span class="c1">the database, the instance obtains the names of the database control files specified in</span></p><p class="c0"><span class="c1">the CONTROL_FILES initialization parameter and opens the files. Oracle Database reads</span></p><p class="c0"><span class="c1">the control files to find the names of the data files and the online redo log files that it</span></p><p class="c0"><span class="c1">will attempt to access when opening the database.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;SYS and SYSTEM Schemas&quot; on page 2-5</span></p><p class="c0"><span class="c1">&#9632; &quot;Overview of Database Security&quot; on page 17-1 to learn about</span></p><p class="c0"><span class="c1">password files and authentication for database administrators</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn about SYSDBA and</span></p><p class="c0"><span class="c1">SYSOPER</span></p><p class="c0"><span class="c1">See Also: Oracle Database Administrator&#39;s Guide to learn how to</span></p><p class="c0"><span class="c1">manage initialization parameters using a server parameter fileOverview of Instance Startup and Shutdown</span></p><p class="c0"><span class="c1">Oracle Database Instance 13-7</span></p><p class="c0"><span class="c1">In a mounted database, the database is closed and accessible only to database</span></p><p class="c0"><span class="c1">administrators. Administrators can keep the database closed while completing specific</span></p><p class="c0"><span class="c1">maintenance operations. However, the database is not available for normal operations.</span></p><p class="c0"><span class="c1">If Oracle Database allows multiple instances to mount the same database concurrently,</span></p><p class="c0"><span class="c1">then the CLUSTER_DATABASE initialization parameter setting can make the database</span></p><p class="c0"><span class="c1">available to multiple instances. Database behavior depends on the setting:</span></p><p class="c0"><span class="c1">&#9632; If CLUSTER_DATABASE is false (default) for the first instance that mounts a</span></p><p class="c0"><span class="c1">database, then only this instance can mount the database.</span></p><p class="c0"><span class="c1">&#9632; If CLUSTER_DATABASE is true for the first instance, then other instances can mount</span></p><p class="c0"><span class="c1">the database if their CLUSTER_DATABASE parameter settings are set to true. The</span></p><p class="c0"><span class="c1">number of instances that can mount the database is subject to a predetermined</span></p><p class="c0"><span class="c1">maximum specified when creating the database.</span></p><p class="c0"><span class="c1">How a Database Is Opened</span></p><p class="c0"><span class="c1">Opening a mounted database makes it available for normal database operations. Any</span></p><p class="c0"><span class="c1">valid user can connect to an open database and access its information. Usually, a</span></p><p class="c0"><span class="c1">database administrator opens the database to make it available for general use.</span></p><p class="c0"><span class="c1">When you open the database, Oracle Database performs the following actions:</span></p><p class="c0"><span class="c1">&#9632; Opens the online data files in tablespaces other than undo tablespaces</span></p><p class="c0"><span class="c1">If a tablespace was offline when the database was previously shut down (see</span></p><p class="c0"><span class="c1">&quot;Online and Offline Tablespaces&quot; on page 12-35), then the tablespace and its</span></p><p class="c0"><span class="c1">corresponding data files will be offline when the database reopens.</span></p><p class="c0"><span class="c1">&#9632; Acquires an undo tablespace</span></p><p class="c0"><span class="c1">If multiple undo tablespaces exists, then the UNDO_TABLESPACE initialization</span></p><p class="c0"><span class="c1">parameter designates the undo tablespace to use. If this parameter is not set, then</span></p><p class="c0"><span class="c1">the first available undo tablespace is chosen.</span></p><p class="c0"><span class="c1">&#9632; Opens the online redo log files</span></p><p class="c0"><span class="c1">Read-Only Mode By default, the database opens in read/write mode. In this mode, users</span></p><p class="c0"><span class="c1">can make changes to the data, generating redo in the online redo log. Alternatively,</span></p><p class="c0"><span class="c1">you can open in read-only mode to prevent data modification by user transactions.</span></p><p class="c0"><span class="c1">Read-only mode restricts database access to read-only transactions, which cannot</span></p><p class="c0"><span class="c1">write to data files or to online redo log files. However, the database can perform</span></p><p class="c0"><span class="c1">recovery or operations that change the database state without generating redo. For</span></p><p class="c0"><span class="c1">example, in read-only mode:</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn how to mount a</span></p><p class="c0"><span class="c1">database</span></p><p class="c0"><span class="c1">&#9632; Oracle Real Application Clusters Administration and Deployment</span></p><p class="c0"><span class="c1">Guide for more information about the use of multiple instances</span></p><p class="c0"><span class="c1">with a single database</span></p><p class="c0"><span class="c1">See Also: &quot;Data Repair&quot; on page 18-12</span></p><p class="c0"><span class="c1">Note: By default, a physical standby database opens in read-only</span></p><p class="c0"><span class="c1">mode. See Oracle Data Guard Concepts and Administration.Overview of Instance Startup and Shutdown</span></p><p class="c0"><span class="c1">13-8 Oracle Database Concepts</span></p><p class="c0"><span class="c1">&#9632; Data files can be taken offline and online. However, you cannot take permanent</span></p><p class="c0"><span class="c1">tablespaces offline.</span></p><p class="c0"><span class="c1">&#9632; Offline data files and tablespaces can be recovered.</span></p><p class="c0"><span class="c1">&#9632; The control file remains available for updates about the state of the database.</span></p><p class="c0"><span class="c1">&#9632; Temporary tablespaces created with the CREATE TEMPORARY TABLESPACE statement</span></p><p class="c0"><span class="c1">are read/write.</span></p><p class="c0"><span class="c1">&#9632; Writes to operating system audit trails, trace files, and alert logs can continue.</span></p><p class="c0"><span class="c1">Database File Checks If any of the data files or redo log files are not present when the</span></p><p class="c0"><span class="c1">instance attempts to open the database, or if the files are present but fail consistency</span></p><p class="c0"><span class="c1">tests, then the database returns an error. Media recovery may be required.</span></p><p class="c0"><span class="c1">Overview of Database and Instance Shutdown</span></p><p class="c0"><span class="c1">In a typical use case, you manually shut down the database, making it unavailable for</span></p><p class="c0"><span class="c1">users while you perform maintenance or other administrative tasks. You can use the</span></p><p class="c0"><span class="c1">SQL*Plus SHUTDOWN command or Enterprise Manager to perform these steps.</span></p><p class="c0"><span class="c1">Figure 13&ndash;4 shows the progression from an open state to a consistent shutdown.</span></p><p class="c0"><span class="c1">Figure 13&ndash;4 Instance and Database Shutdown Sequence</span></p><p class="c0"><span class="c1">Oracle Database automatically performs the following steps whenever an open</span></p><p class="c0"><span class="c1">database is shut down consistently:</span></p><p class="c0"><span class="c1">1. Database closed</span></p><p class="c0"><span class="c1">The database is mounted, but online data files and redo log files are closed.</span></p><p class="c0"><span class="c1">&quot;How a Database Is Closed&quot; explains this stage.</span></p><p class="c0"><span class="c1">2. Database unmounted</span></p><p class="c0"><span class="c1">The instance is started, but is no longer associated with the control file of the</span></p><p class="c0"><span class="c1">database.</span></p><p class="c0"><span class="c1">See Also: Oracle Database Administrator&#39;s Guide to learn how to</span></p><p class="c0"><span class="c1">open a database in read-only mode</span></p><p class="c0"><span class="c1">See Also: &quot;Backup and Recovery&quot; on page 18-9</span></p><p class="c0"><span class="c1">Control file</span></p><p class="c0"><span class="c1">closed and</span></p><p class="c0"><span class="c1">instance</span></p><p class="c0"><span class="c1">started</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">closed and</span></p><p class="c0"><span class="c1">control file</span></p><p class="c0"><span class="c1">opened</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">opened</span></p><p class="c0"><span class="c1">for this</span></p><p class="c0"><span class="c1">instance</span></p><p class="c0"><span class="c1">SHUTDOWN</span></p><p class="c0"><span class="c1">OPEN</span></p><p class="c0"><span class="c1">CLOSE</span></p><p class="c0"><span class="c1">NOMOUNT</span></p><p class="c0"><span class="c1">SHUTDOWNOverview of Instance Startup and Shutdown</span></p><p class="c0"><span class="c1">Oracle Database Instance 13-9</span></p><p class="c0"><span class="c1">&quot;How a Database Is Unmounted&quot; explains this stage.</span></p><p class="c0"><span class="c1">3. Database instance shut down</span></p><p class="c0"><span class="c1">The database instance is no longer started.</span></p><p class="c0"><span class="c1">&quot;How an Instance Is Shut Down&quot; explains this stage.</span></p><p class="c0"><span class="c1">Oracle Database does not go through all of the preceding steps in an instance failure or</span></p><p class="c0"><span class="c1">SHUTDOWN ABORT, which immediately terminates the instance.</span></p><p class="c0"><span class="c1">Shutdown Modes</span></p><p class="c0"><span class="c1">A database administrator with SYSDBA or SYSOPER privileges can shut down the</span></p><p class="c0"><span class="c1">database using the SQL*Plus SHUTDOWN command or Enterprise Manager. The</span></p><p class="c0"><span class="c1">SHUTDOWN command has options that determine shutdown behavior. Table 13&ndash;2</span></p><p class="c0"><span class="c1">summarizes the behavior of the different shutdown modes.</span></p><p class="c0"><span class="c1">The possible SHUTDOWN statements are:</span></p><p class="c0"><span class="c1">&#9632; SHUTDOWN ABORT</span></p><p class="c0"><span class="c1">This mode is intended for emergency situations, such as when no other form of</span></p><p class="c0"><span class="c1">shutdown is successful. This mode of shutdown is the fastest. However, a</span></p><p class="c0"><span class="c1">subsequent open of this database may take substantially longer because instance</span></p><p class="c0"><span class="c1">recovery must be performed to make the data files consistent.</span></p><p class="c0"><span class="c1">&#9632; SHUTDOWN IMMEDIATE</span></p><p class="c0"><span class="c1">This mode is typically the fastest next to SHUTDOWN ABORT. Oracle Database</span></p><p class="c0"><span class="c1">terminates any executing SQL statements and disconnects users. Active</span></p><p class="c0"><span class="c1">transactions are terminated and uncommitted changes are rolled back.</span></p><p class="c0"><span class="c1">&#9632; SHUTDOWN TRANSACTIONAL</span></p><p class="c0"><span class="c1">This mode prevents users from starting new transactions, but waits for all current</span></p><p class="c0"><span class="c1">transactions to complete before shutting down. This mode can take a significant</span></p><p class="c0"><span class="c1">amount of time depending on the nature of the current transactions.</span></p><p class="c0"><span class="c1">See Also: Oracle Database 2 Day DBA and Oracle Database</span></p><p class="c0"><span class="c1">Administrator&#39;s Guide to learn how to shut down a database</span></p><p class="c0"><span class="c1">Table 13&ndash;2 Shutdown Modes</span></p><p class="c0"><span class="c1">Database Behavior ABORT IMMEDIATE TRANSACTIONAL NORMAL</span></p><p class="c0"><span class="c1">Permits new user</span></p><p class="c0"><span class="c1">connections</span></p><p class="c0"><span class="c1">No No No No</span></p><p class="c0"><span class="c1">Waits until current</span></p><p class="c0"><span class="c1">sessions end</span></p><p class="c0"><span class="c1">No No No Yes</span></p><p class="c0"><span class="c1">Waits until current</span></p><p class="c0"><span class="c1">transactions end</span></p><p class="c0"><span class="c1">No No Yes Yes</span></p><p class="c0"><span class="c1">Performs a checkpoint</span></p><p class="c0"><span class="c1">and closes open files</span></p><p class="c0"><span class="c1">No Yes Yes Yes</span></p><p class="c0"><span class="c1">Note: Because SHUTDOWN ABORT does not checkpoint the open data</span></p><p class="c0"><span class="c1">files, instance recovery is necessary before the database can reopen.</span></p><p class="c0"><span class="c1">The other shutdown modes do not require instance recovery before</span></p><p class="c0"><span class="c1">the database can reopen.Overview of Instance Startup and Shutdown</span></p><p class="c0"><span class="c1">13-10 Oracle Database Concepts</span></p><p class="c0"><span class="c1">&#9632; SHUTDOWN NORMAL</span></p><p class="c0"><span class="c1">This is the default mode of shutdown. The database waits for all connected users</span></p><p class="c0"><span class="c1">to disconnect before shutting down.</span></p><p class="c0"><span class="c1">How a Database Is Closed</span></p><p class="c0"><span class="c1">The database close operation is implicit in a database shutdown. The nature of the</span></p><p class="c0"><span class="c1">operation depends on whether the database shutdown is normal or abnormal.</span></p><p class="c0"><span class="c1">How a Database Is Closed During Normal Shutdown When a database is closed as part of a</span></p><p class="c0"><span class="c1">SHUTDOWN with any option other than ABORT, Oracle Database writes data in the SGA to</span></p><p class="c0"><span class="c1">the data files and online redo log files. Next, the database closes online data files and</span></p><p class="c0"><span class="c1">online redo log files. Any offline data files of offline tablespaces have been closed</span></p><p class="c0"><span class="c1">already. When the database reopens, any tablespace that was offline remains offline.</span></p><p class="c0"><span class="c1">At this stage, the database is closed and inaccessible for normal operations. The control</span></p><p class="c0"><span class="c1">files remain open after a database is closed.</span></p><p class="c0"><span class="c1">How a Database Is Closed During Abnormal Shutdown If a SHUTDOWN ABORT or abnormal</span></p><p class="c0"><span class="c1">termination occurs, then the instance of an open database closes and shuts down the</span></p><p class="c0"><span class="c1">database instantaneously. Oracle Database does not write data in the buffers of the</span></p><p class="c0"><span class="c1">SGA to the data files and redo log files. The subsequent reopening of the database</span></p><p class="c0"><span class="c1">requires instance recovery, which Oracle Database performs automatically.</span></p><p class="c0"><span class="c1">How a Database Is Unmounted</span></p><p class="c0"><span class="c1">After the database is closed, Oracle Database unmounts the database to disassociate it</span></p><p class="c0"><span class="c1">from the instance. After a database is unmounted, Oracle Database closes the control</span></p><p class="c0"><span class="c1">files of the database. At this point, the instance remains in memory.</span></p><p class="c0"><span class="c1">How an Instance Is Shut Down</span></p><p class="c0"><span class="c1">The final step in database shutdown is shutting down the instance. When the database</span></p><p class="c0"><span class="c1">instance is shut down, the SGA is removed from memory and the background</span></p><p class="c0"><span class="c1">processes are terminated.</span></p><p class="c0"><span class="c1">In unusual circumstances, shutdown of an instance may not occur cleanly. Memory</span></p><p class="c0"><span class="c1">structures may not be removed from memory or one of the background processes may</span></p><p class="c0"><span class="c1">not be terminated. When remnants of a previous instance exist, a subsequent instance</span></p><p class="c0"><span class="c1">startup may fail. In such situations, you can force the new instance to start by</span></p><p class="c0"><span class="c1">removing the remnants of the previous instance and then starting a new instance, or</span></p><p class="c0"><span class="c1">by issuing a SHUTDOWN ABORT statement in SQL*Plus or using Enterprise Manager.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database 2 Day DBA and Oracle Database Administrator&#39;s</span></p><p class="c0"><span class="c1">Guide to learn about the different shutdown modes</span></p><p class="c0"><span class="c1">&#9632; SQL*Plus User&#39;s Guide and Reference to learn about the SHUTDOWN</span></p><p class="c0"><span class="c1">command</span></p><p class="c0"><span class="c1">See Also: Oracle Database Administrator&#39;s Guide for more detailed</span></p><p class="c0"><span class="c1">information about database shutdownOverview of Checkpoints</span></p><p class="c0"><span class="c1">Oracle Database Instance 13-11</span></p><p class="c0"><span class="c1">Overview of Checkpoints</span></p><p class="c0"><span class="c1">A checkpoint is a crucial mechanism in consistent database shutdowns, instance</span></p><p class="c0"><span class="c1">recovery, and Oracle Database operation generally. The term checkpoint has the</span></p><p class="c0"><span class="c1">following related meanings:</span></p><p class="c0"><span class="c1">&#9632; A data structure that indicates the checkpoint position, which is the SCN in the</span></p><p class="c0"><span class="c1">redo stream where instance recovery must begin</span></p><p class="c0"><span class="c1">The checkpoint position is determined by the oldest dirty buffer in the database</span></p><p class="c0"><span class="c1">buffer cache. The checkpoint position acts as a pointer to the redo stream and is</span></p><p class="c0"><span class="c1">stored in the control file and in each data file header.</span></p><p class="c0"><span class="c1">&#9632; The writing of modified database buffers in the database buffer cache to disk</span></p><p class="c0"><span class="c1">Purpose of Checkpoints</span></p><p class="c0"><span class="c1">Oracle Database uses checkpoints to achieve the following goals:</span></p><p class="c0"><span class="c1">&#9632; Reduce the time required for recovery in case of an instance or media failure</span></p><p class="c0"><span class="c1">&#9632; Ensure that dirty buffers in the buffer cache are written to disk regularly</span></p><p class="c0"><span class="c1">&#9632; Ensure that all committed data is written to disk during a consistent shutdown</span></p><p class="c0"><span class="c1">When Oracle Database Initiates Checkpoints</span></p><p class="c0"><span class="c1">The checkpoint process (CKPT) is responsible for writing checkpoints to the data file</span></p><p class="c0"><span class="c1">headers and control file. Checkpoints occur in a variety of situations. For example,</span></p><p class="c0"><span class="c1">Oracle Database uses the following types of checkpoints:</span></p><p class="c0"><span class="c1">&#9632; Thread checkpoints</span></p><p class="c0"><span class="c1">The database writes to disk all buffers modified by redo in a specific thread before</span></p><p class="c0"><span class="c1">a certain target. The set of thread checkpoints on all instances in a database is a</span></p><p class="c0"><span class="c1">database checkpoint. Thread checkpoints occur in the following situations:</span></p><p class="c0"><span class="c1">&ndash; Consistent database shutdown</span></p><p class="c0"><span class="c1">&ndash; ALTER SYSTEM CHECKPOINT statement</span></p><p class="c0"><span class="c1">&ndash; Online redo log switch</span></p><p class="c0"><span class="c1">&ndash; ALTER DATABASE BEGIN BACKUP statement</span></p><p class="c0"><span class="c1">&#9632; Tablespace and data file checkpoints</span></p><p class="c0"><span class="c1">The database writes to disk all buffers modified by redo before a specific target. A</span></p><p class="c0"><span class="c1">tablespace checkpoint is a set of data file checkpoints, one for each data file in the</span></p><p class="c0"><span class="c1">tablespace. These checkpoints occur in a variety of situations, including making a</span></p><p class="c0"><span class="c1">tablespace read-only or taking it offline normal, shrinking a data file, or executing</span></p><p class="c0"><span class="c1">ALTER TABLESPACE BEGIN BACKUP.</span></p><p class="c0"><span class="c1">&#9632; Incremental checkpoints</span></p><p class="c0"><span class="c1">An incremental checkpoint is a type of thread checkpoint partly intended to avoid</span></p><p class="c0"><span class="c1">writing large numbers of blocks at online redo log switches. DBWn checks at least</span></p><p class="c0"><span class="c1">every three seconds to determine whether it has work to do. When DBWn writes</span></p><p class="c0"><span class="c1">dirty buffers, it advances the checkpoint position, causing CKPT to write the</span></p><p class="c0"><span class="c1">checkpoint position to the control file, but not to the data file headers.</span></p><p class="c0"><span class="c1">See Also: &quot;System Change Numbers (SCNs)&quot; on page 10-5Overview of Instance Recovery</span></p><p class="c0"><span class="c1">13-12 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Other types of checkpoints include instance and media recovery checkpoints and</span></p><p class="c0"><span class="c1">checkpoints when schema objects are dropped or truncated.</span></p><p class="c0"><span class="c1">Overview of Instance Recovery</span></p><p class="c0"><span class="c1">Instance recovery is the process of applying records in the online redo log to data files</span></p><p class="c0"><span class="c1">to reconstruct changes made after the most recent checkpoint. Instance recovery</span></p><p class="c0"><span class="c1">occurs automatically when an administrator attempts to open a database that was</span></p><p class="c0"><span class="c1">previously shut down inconsistently.</span></p><p class="c0"><span class="c1">Purpose of Instance Recovery</span></p><p class="c0"><span class="c1">Instance recovery ensures that the database is in a consistent state after an instance</span></p><p class="c0"><span class="c1">failure. The files of a database can be left in an inconsistent state because of how Oracle</span></p><p class="c0"><span class="c1">Database manages database changes.</span></p><p class="c0"><span class="c1">A redo thread is a record of all of the changes generated by an instance. A</span></p><p class="c0"><span class="c1">single-instance database has one thread of redo, whereas an Oracle RAC database has</span></p><p class="c0"><span class="c1">multiple redo threads, one for each database instance.</span></p><p class="c0"><span class="c1">When a transaction is committed, log writer (LGWR) writes both the remaining redo</span></p><p class="c0"><span class="c1">entries in memory and the transaction SCN to the online redo log. However, the</span></p><p class="c0"><span class="c1">database writer (DBW) process writes modified data blocks to the data files whenever</span></p><p class="c0"><span class="c1">it is most efficient. For this reason, uncommitted changes may temporarily exist in the</span></p><p class="c0"><span class="c1">data files while committed changes do not yet exist in the data files.</span></p><p class="c0"><span class="c1">If an instance of an open database fails, either because of a SHUTDOWN ABORT statement</span></p><p class="c0"><span class="c1">or abnormal termination, then the following situations can result:</span></p><p class="c0"><span class="c1">&#9632; Data blocks committed by a transaction are not written to the data files and appear</span></p><p class="c0"><span class="c1">only in the online redo log. These changes must be reapplied to the database.</span></p><p class="c0"><span class="c1">&#9632; The data files contains changes that had not been committed when the instance</span></p><p class="c0"><span class="c1">failed. These changes must be rolled back to ensure transactional consistency.</span></p><p class="c0"><span class="c1">Instance recovery uses only online redo log files and current online data files to</span></p><p class="c0"><span class="c1">synchronize the data files and ensure that they are consistent.</span></p><p class="c0"><span class="c1">When Oracle Database Performs Instance Recovery</span></p><p class="c0"><span class="c1">Whether instance recovery is required depends on the state of the redo threads. A redo</span></p><p class="c0"><span class="c1">thread is marked open in the control file when a database instance opens in read/write</span></p><p class="c0"><span class="c1">mode, and is marked closed when the instance is shut down consistently. If redo</span></p><p class="c0"><span class="c1">threads are marked open in the control file, but no live instances hold the thread</span></p><p class="c0"><span class="c1">enqueues corresponding to these threads, then the database requires instance recovery.</span></p><p class="c0"><span class="c1">Oracle Database performs instance recovery automatically in the following situations:</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Checkpoint Process (CKPT)&quot; on page 15-10</span></p><p class="c0"><span class="c1">&#9632; Oracle Real Application Clusters Administration and Deployment</span></p><p class="c0"><span class="c1">Guide for information about global checkpoints in Oracle RAC</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Database Writer Process (DBWn)&quot; on page 15-8 and &quot;Database</span></p><p class="c0"><span class="c1">Buffer Cache&quot; on page 14-9</span></p><p class="c0"><span class="c1">&#9632; &quot;Introduction to Data Concurrency and Consistency&quot; on page 9-1Overview of Instance Recovery</span></p><p class="c0"><span class="c1">Oracle Database Instance 13-13</span></p><p class="c0"><span class="c1">&#9632; The database opens for the first time after the failure of a single-instance database</span></p><p class="c0"><span class="c1">or all instances of an Oracle RAC database. This form of instance recovery is also</span></p><p class="c0"><span class="c1">called crash recovery. Oracle Database recovers the online redo threads of the</span></p><p class="c0"><span class="c1">terminated instances together.</span></p><p class="c0"><span class="c1">&#9632; Some but not all instances of an Oracle RAC database fail. Instance recovery is</span></p><p class="c0"><span class="c1">performed automatically by a surviving instance in the configuration.</span></p><p class="c0"><span class="c1">The SMON background process performs instance recovery, applying online redo</span></p><p class="c0"><span class="c1">automatically. No user intervention is required.</span></p><p class="c0"><span class="c1">Importance of Checkpoints for Instance Recovery</span></p><p class="c0"><span class="c1">Instance recovery uses checkpoints to determine which changes must be applied to the</span></p><p class="c0"><span class="c1">data files. The checkpoint position guarantees that every committed change with an</span></p><p class="c0"><span class="c1">SCN lower than the checkpoint SCN is saved to the data files.</span></p><p class="c0"><span class="c1">Figure 13&ndash;5 depicts the redo thread in the online redo log.</span></p><p class="c0"><span class="c1">Figure 13&ndash;5 Checkpoint Position in Online Redo Log</span></p><p class="c0"><span class="c1">During instance recovery, the database must apply the changes that occur between the</span></p><p class="c0"><span class="c1">checkpoint position and the end of the redo thread. As shown in Figure 13&ndash;5, some</span></p><p class="c0"><span class="c1">changes may already have been written to the data files. However, only changes with</span></p><p class="c0"><span class="c1">SCNs lower than the checkpoint position are guaranteed to be on disk.</span></p><p class="c0"><span class="c1">Instance Recovery Phases</span></p><p class="c0"><span class="c1">The first phase of instance recovery is called cache recovery or rolling forward, and</span></p><p class="c0"><span class="c1">involves reapplying all of the changes recorded in the online redo log to the data files.</span></p><p class="c0"><span class="c1">Because rollback data is recorded in the online redo log, rolling forward also</span></p><p class="c0"><span class="c1">regenerates the corresponding undo segments.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;System Monitor Process (SMON)&quot; on page 15-8</span></p><p class="c0"><span class="c1">&#9632; Oracle Real Application Clusters Administration and Deployment</span></p><p class="c0"><span class="c1">Guide to learn about instance recovery in an Oracle RAC database</span></p><p class="c0"><span class="c1">See Also: Oracle Database Performance Tuning Guide to learn how to</span></p><p class="c0"><span class="c1">limit instance recovery time</span></p><p class="c0"><span class="c1">Change in</span></p><p class="c0"><span class="c1">Data File</span></p><p class="c0"><span class="c1">Change Not</span></p><p class="c0"><span class="c1">in Data File</span></p><p class="c0"><span class="c1">End of Redo</span></p><p class="c0"><span class="c1">Thread</span></p><p class="c0"><span class="c1">Checkpoint</span></p><p class="c0"><span class="c1">Position</span></p><p class="c0"><span class="c1">Instance Recovery</span></p><p class="c0"><span class="c1">Writes to Online Redo Log</span></p><p class="c0"><span class="c1">Committed</span></p><p class="c0"><span class="c1">Change</span></p><p class="c0"><span class="c1">Uncommitted</span></p><p class="c0"><span class="c1">ChangeOverview of Parameter Files</span></p><p class="c0"><span class="c1">13-14 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Rolling forward proceeds through as many online redo log files as necessary to bring</span></p><p class="c0"><span class="c1">the database forward in time. After rolling forward, the data blocks contain all</span></p><p class="c0"><span class="c1">committed changes recorded in the online redo log files. These files could also contain</span></p><p class="c0"><span class="c1">uncommitted changes that were either saved to the data files before the failure, or</span></p><p class="c0"><span class="c1">were recorded in the online redo log and introduced during cache recovery.</span></p><p class="c0"><span class="c1">After the roll forward, any changes that were not committed must be undone. Oracle</span></p><p class="c0"><span class="c1">Database uses the checkpoint position, which guarantees that every committed change</span></p><p class="c0"><span class="c1">with an SCN lower than the checkpoint SCN is saved on disk. Oracle Database applies</span></p><p class="c0"><span class="c1">undo blocks to roll back uncommitted changes in data blocks that were written before</span></p><p class="c0"><span class="c1">the failure or introduced during cache recovery. This phase is called rolling back or</span></p><p class="c0"><span class="c1">transaction recovery.</span></p><p class="c0"><span class="c1">Figure 13&ndash;6 illustrates rolling forward and rolling back, the two steps necessary to</span></p><p class="c0"><span class="c1">recover from database instance failure.</span></p><p class="c0"><span class="c1">Figure 13&ndash;6 Basic Instance Recovery Steps: Rolling Forward and Rolling Back</span></p><p class="c0"><span class="c1">Oracle Database can roll back multiple transactions simultaneously as needed. All</span></p><p class="c0"><span class="c1">transactions that were active at the time of failure are marked as terminated. Instead of</span></p><p class="c0"><span class="c1">waiting for the SMON process to roll back terminated transactions, new transactions</span></p><p class="c0"><span class="c1">can roll back individual blocks themselves to obtain the required data.</span></p><p class="c0"><span class="c1">Overview of Parameter Files</span></p><p class="c0"><span class="c1">To start a database instance, Oracle Database must read either a server parameter file,</span></p><p class="c0"><span class="c1">which is recommended, or a text initialization parameter file, which is a legacy</span></p><p class="c0"><span class="c1">implementation. These files contain a list of configuration parameters.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Undo Segments&quot; on page 12-24 to learn more about undo data</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Performance Tuning Guide for a discussion of</span></p><p class="c0"><span class="c1">instance recovery mechanics and tuning</span></p><p class="c0"><span class="c1">Database with</span></p><p class="c0"><span class="c1">Committed and</span></p><p class="c0"><span class="c1">Uncommitted</span></p><p class="c0"><span class="c1">Changes</span></p><p class="c0"><span class="c1">Changes from</span></p><p class="c0"><span class="c1">Online Redo Log</span></p><p class="c0"><span class="c1">Applied</span></p><p class="c0"><span class="c1">Uncommitted Changes</span></p><p class="c0"><span class="c1">Rolled Back</span></p><p class="c0"><span class="c1">Database Requiring</span></p><p class="c0"><span class="c1">Instance Recovery</span></p><p class="c0"><span class="c1">Database with</span></p><p class="c0"><span class="c1">Only Committed</span></p><p class="c0"><span class="c1">Transactions</span></p><p class="c0"><span class="c1">Database Database</span></p><p class="c0"><span class="c1">Online</span></p><p class="c0"><span class="c1">Redo Log</span></p><p class="c0"><span class="c1">Change in</span></p><p class="c0"><span class="c1">Data File</span></p><p class="c0"><span class="c1">Change Not</span></p><p class="c0"><span class="c1">in Data File</span></p><p class="c0"><span class="c1">Committed</span></p><p class="c0"><span class="c1">Change</span></p><p class="c0"><span class="c1">Uncommitted</span></p><p class="c0"><span class="c1">Change</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">Undo</span></p><p class="c0"><span class="c1">SegmentsOverview of Parameter Files</span></p><p class="c0"><span class="c1">Oracle Database Instance 13-15</span></p><p class="c0"><span class="c1">To create a database manually, you must start an instance with a parameter file and</span></p><p class="c0"><span class="c1">then issue a CREATE DATABASE command. Thus, the instance and parameter file can</span></p><p class="c0"><span class="c1">exist even when the database itself does not exist.</span></p><p class="c0"><span class="c1">Initialization Parameters</span></p><p class="c0"><span class="c1">Initialization parameters are configuration parameters that affect the basic operation</span></p><p class="c0"><span class="c1">of an instance. The instance reads initialization parameters from a file at startup.</span></p><p class="c0"><span class="c1">Oracle Database provides many initialization parameters to optimize its operation in</span></p><p class="c0"><span class="c1">diverse environments. Only a few of these parameters must be explicitly set because</span></p><p class="c0"><span class="c1">the default values are adequate in most cases.</span></p><p class="c0"><span class="c1">Functional Groups of Initialization Parameters</span></p><p class="c0"><span class="c1">Most initialization parameters belong to one of the following functional groups:</span></p><p class="c0"><span class="c1">&#9632; Parameters that name entities such as files or directories</span></p><p class="c0"><span class="c1">&#9632; Parameters that set limits for a process, database resource, or the database itself</span></p><p class="c0"><span class="c1">&#9632; Parameters that affect capacity, such as the size of the SGA (these parameters are</span></p><p class="c0"><span class="c1">called variable parameters)</span></p><p class="c0"><span class="c1">Variable parameters are of particular interest to database administrators because they</span></p><p class="c0"><span class="c1">can use these parameters to improve database performance.</span></p><p class="c0"><span class="c1">Basic and Advanced Initialization Parameters</span></p><p class="c0"><span class="c1">Initialization parameters are divided into two groups: basic and advanced. In most</span></p><p class="c0"><span class="c1">cases, you must set and tune only the approximately 30 basic parameters to obtain</span></p><p class="c0"><span class="c1">reasonable performance. The basic parameters set characteristics such as the database</span></p><p class="c0"><span class="c1">name, locations of the control files, database block size, and undo tablespace.</span></p><p class="c0"><span class="c1">In rare situations, modification to the advanced parameters may be required for</span></p><p class="c0"><span class="c1">optimal performance. The advanced parameters enable expert DBAs to adapt the</span></p><p class="c0"><span class="c1">behavior of the Oracle Database to meet unique requirements.</span></p><p class="c0"><span class="c1">Oracle Database provides values in the starter initialization parameter file provided</span></p><p class="c0"><span class="c1">with your database software, or as created for you by the Database Configuration</span></p><p class="c0"><span class="c1">Assistant (see &quot;Tools for Database Installation and Configuration&quot; on page 18-4). You</span></p><p class="c0"><span class="c1">can edit these Oracle-supplied initialization parameters and add others, depending on</span></p><p class="c0"><span class="c1">your configuration and how you plan to tune the database. For relevant initialization</span></p><p class="c0"><span class="c1">parameters not included in the parameter file, Oracle Database supplies defaults.</span></p><p class="c0"><span class="c1">Server Parameter Files</span></p><p class="c0"><span class="c1">A server parameter file is a repository for initialization parameters that is managed by</span></p><p class="c0"><span class="c1">Oracle Database. A server parameter file has the following key characteristics:</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database 2 Day DBA and Oracle Database Administrator&#39;s</span></p><p class="c0"><span class="c1">Guide to learn how to specify initialization parameters</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Reference for an explanation of the types of</span></p><p class="c0"><span class="c1">initialization parameters</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Reference for a description of V$PARAMETER and</span></p><p class="c0"><span class="c1">SQL*Plus User&#39;s Guide and Reference for SHOW PARAMETER syntaxOverview of Parameter Files</span></p><p class="c0"><span class="c1">13-16 Oracle Database Concepts</span></p><p class="c0"><span class="c1">&#9632; Only one server parameter file exists for a database. This file must reside on the</span></p><p class="c0"><span class="c1">database host.</span></p><p class="c0"><span class="c1">&#9632; The server parameter file is written to and read by only by Oracle Database, not by</span></p><p class="c0"><span class="c1">client applications.</span></p><p class="c0"><span class="c1">&#9632; The server parameter file is binary and cannot be modified by a text editor.</span></p><p class="c0"><span class="c1">&#9632; Initialization parameters stored in the server parameter file are persistent. Any</span></p><p class="c0"><span class="c1">changes made to the parameters while a database instance is running can persist</span></p><p class="c0"><span class="c1">across instance shutdown and startup.</span></p><p class="c0"><span class="c1">A server parameter file eliminates the need to maintain multiple text initialization</span></p><p class="c0"><span class="c1">parameter files for client applications. A server parameter file is initially built from a</span></p><p class="c0"><span class="c1">text initialization parameter file using the CREATE SPFILE statement. It can also be</span></p><p class="c0"><span class="c1">created directly by the Database Configuration Assistant.</span></p><p class="c0"><span class="c1">Text Initialization Parameter Files</span></p><p class="c0"><span class="c1">A text initialization parameter file is a text file that contains a list of initialization</span></p><p class="c0"><span class="c1">parameters. This type of parameter file, which is a legacy implementation of the</span></p><p class="c0"><span class="c1">parameter file, has the following key characteristics:</span></p><p class="c0"><span class="c1">&#9632; When starting up or shutting down a database, the text initialization parameter</span></p><p class="c0"><span class="c1">file must reside on the same host as the client application that connects to the</span></p><p class="c0"><span class="c1">database.</span></p><p class="c0"><span class="c1">&#9632; A text initialization parameter file is text-based, not binary.</span></p><p class="c0"><span class="c1">&#9632; Oracle Database can read but not write to the text initialization parameter file. To</span></p><p class="c0"><span class="c1">change the parameter values you must manually alter the file with a text editor.</span></p><p class="c0"><span class="c1">&#9632; Changes to initialization parameter values by ALTER SYSTEM are only in effect for</span></p><p class="c0"><span class="c1">the current instance. You must manually update the text initialization parameter</span></p><p class="c0"><span class="c1">file and restart the instance for the changes to be known.</span></p><p class="c0"><span class="c1">The text initialization parameter file contains a series of key=value pairs, one per line.</span></p><p class="c0"><span class="c1">For example, a portion of an initialization parameter file could look as follows:</span></p><p class="c0"><span class="c1">db_name=sample</span></p><p class="c0"><span class="c1">control_files=/disk1/oradata/sample_cf.dbf</span></p><p class="c0"><span class="c1">db_block_size=8192</span></p><p class="c0"><span class="c1">open_cursors=52</span></p><p class="c0"><span class="c1">undo_management=auto</span></p><p class="c0"><span class="c1">shared_pool_size=280M</span></p><p class="c0"><span class="c1">pga_aggregate_target=29M</span></p><p class="c0"><span class="c1">. . .</span></p><p class="c0"><span class="c1">To illustrate the manageability problems that text parameter files can create, assume</span></p><p class="c0"><span class="c1">that you use computers clienta and clientb and must be able to start the database</span></p><p class="c0"><span class="c1">with SQL*Plus on either computer. In this case, two separate text initialization</span></p><p class="c0"><span class="c1">parameter files must exist, one on each computer, as shown in Figure 13&ndash;7. A server</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn more about server</span></p><p class="c0"><span class="c1">parameter files</span></p><p class="c0"><span class="c1">&#9632; Oracle Database SQL Language Reference to learn about CREATE</span></p><p class="c0"><span class="c1">SPFILEOverview of Parameter Files</span></p><p class="c0"><span class="c1">Oracle Database Instance 13-17</span></p><p class="c0"><span class="c1">parameter file solves the problem of the proliferation of parameter files.</span></p><p class="c0"><span class="c1">Figure 13&ndash;7 Multiple Initialization Parameter Files</span></p><p class="c0"><span class="c1">Modification of Initialization Parameter Values</span></p><p class="c0"><span class="c1">You can adjust initialization parameters to modify the behavior of a database. The</span></p><p class="c0"><span class="c1">classification of parameters as static or dynamic determines how they can be</span></p><p class="c0"><span class="c1">modified. Table 13&ndash;3 summarizes the differences.</span></p><p class="c0"><span class="c1">Static parameters include DB_BLOCK_SIZE, DB_NAME, and COMPATIBLE. Dynamic</span></p><p class="c0"><span class="c1">parameters are grouped into session-level parameters, which affect only the current</span></p><p class="c0"><span class="c1">user session, and system-level parameters, which affect the database and all sessions.</span></p><p class="c0"><span class="c1">For example, MEMORY_TARGET is a system-level parameter, while NLS_DATE_FORMAT is a</span></p><p class="c0"><span class="c1">session-level parameter (see &quot;Locale-Specific Settings&quot; on page 19-10).</span></p><p class="c0"><span class="c1">The scope of a parameter change depends on when the change takes effect. When an</span></p><p class="c0"><span class="c1">instance has been started with a server parameter file, you can use the ALTER SYSTEM</span></p><p class="c0"><span class="c1">SET statement to change values for system-level parameters as follows:</span></p><p class="c0"><span class="c1">&#9632; SCOPE=MEMORY</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn more about text</span></p><p class="c0"><span class="c1">initialization parameter files</span></p><p class="c0"><span class="c1">&#9632; Oracle Database SQL Language Reference to learn about CREATE</span></p><p class="c0"><span class="c1">PFILE</span></p><p class="c0"><span class="c1">Table 13&ndash;3 Static and Dynamic Initialization Parameters</span></p><p class="c0"><span class="c1">Characteristic Static Dynamic</span></p><p class="c0"><span class="c1">Requires modification of the parameter file</span></p><p class="c0"><span class="c1">(text or server)</span></p><p class="c0"><span class="c1">Yes No</span></p><p class="c0"><span class="c1">Requires database instance restart before</span></p><p class="c0"><span class="c1">setting takes affect</span></p><p class="c0"><span class="c1">Yes No</span></p><p class="c0"><span class="c1">Described as &quot;Modifiable&quot; in Oracle Database</span></p><p class="c0"><span class="c1">Reference initialization parameter entry</span></p><p class="c0"><span class="c1">No Yes</span></p><p class="c0"><span class="c1">Modifiable only for the database or instance Yes No</span></p><p class="c0"><span class="c1">Application</span></p><p class="c0"><span class="c1">pfile</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">spfile</span></p><p class="c0"><span class="c1">Binary, located only</span></p><p class="c0"><span class="c1">on database</span></p><p class="c0"><span class="c1">server</span></p><p class="c0"><span class="c1">Clientb</span></p><p class="c0"><span class="c1">Application</span></p><p class="c0"><span class="c1">pfile</span></p><p class="c0"><span class="c1">Text, located</span></p><p class="c0"><span class="c1">on same</span></p><p class="c0"><span class="c1">computer</span></p><p class="c0"><span class="c1">as client</span></p><p class="c0"><span class="c1">application</span></p><p class="c0"><span class="c1">Text, located on</span></p><p class="c0"><span class="c1">same computer as</span></p><p class="c0"><span class="c1">client application</span></p><p class="c0"><span class="c1">Clienta</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">ServerOverview of Diagnostic Files</span></p><p class="c0"><span class="c1">13-18 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Changes apply to the database instance only. The change will not persist if the</span></p><p class="c0"><span class="c1">database is shut down and restarted.</span></p><p class="c0"><span class="c1">&#9632; SCOPE=SPFILE</span></p><p class="c0"><span class="c1">Changes are written to the server parameter file but do not affect the current</span></p><p class="c0"><span class="c1">instance. Thus, the changes do not take effect until the instance is restarted.</span></p><p class="c0"><span class="c1">&#9632; SCOPE=BOTH</span></p><p class="c0"><span class="c1">Changes are written both to memory and to the server parameter file. This is the</span></p><p class="c0"><span class="c1">default scope when the database is using a server parameter file.</span></p><p class="c0"><span class="c1">The database prints the new value and the old value of an initialization parameter to</span></p><p class="c0"><span class="c1">the alert log. As a preventative measure, the database validates changes of basic</span></p><p class="c0"><span class="c1">parameter to prevent illegal values from being written to the server parameter file.</span></p><p class="c0"><span class="c1">Overview of Diagnostic Files</span></p><p class="c0"><span class="c1">Oracle Database includes a fault diagnosability infrastructure for preventing,</span></p><p class="c0"><span class="c1">detecting, diagnosing, and resolving database problems. Problems include critical</span></p><p class="c0"><span class="c1">errors such as code bugs, metadata corruption, and customer data corruption.</span></p><p class="c0"><span class="c1">The goals of the advanced fault diagnosability infrastructure are the following:</span></p><p class="c0"><span class="c1">&#9632; Detecting problems proactively</span></p><p class="c0"><span class="c1">&#9632; Limiting damage and interruptions after a problem is detected</span></p><p class="c0"><span class="c1">&#9632; Reducing problem diagnostic and resolution time</span></p><p class="c0"><span class="c1">&#9632; Simplifying customer interaction with Oracle Support</span></p><p class="c0"><span class="c1">Automatic Diagnostic Repository</span></p><p class="c0"><span class="c1">Automatic Diagnostic Repository (ADR) is a file-based repository that stores</span></p><p class="c0"><span class="c1">database diagnostic data such as trace files, the alert log, and Health Monitor reports.</span></p><p class="c0"><span class="c1">Key characteristics of ADR include:</span></p><p class="c0"><span class="c1">&#9632; Unified directory structure</span></p><p class="c0"><span class="c1">&#9632; Consistent diagnostic data formats</span></p><p class="c0"><span class="c1">&#9632; Unified tool set</span></p><p class="c0"><span class="c1">The preceding characteristics enable customers and Oracle Support to correlate and</span></p><p class="c0"><span class="c1">analyze diagnostic data across multiple Oracle instances, components, and products.</span></p><p class="c0"><span class="c1">Note: You must specify SPFILE when changing the value of a</span></p><p class="c0"><span class="c1">parameter described as not modifiable in Oracle Database Reference.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn how to change</span></p><p class="c0"><span class="c1">initialization parameter settings</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Reference for descriptions of all initialization</span></p><p class="c0"><span class="c1">parameters</span></p><p class="c0"><span class="c1">&#9632; Oracle Database SQL Language Reference for ALTER SYSTEM syntax</span></p><p class="c0"><span class="c1">and semanticsOverview of Diagnostic Files</span></p><p class="c0"><span class="c1">Oracle Database Instance 13-19</span></p><p class="c0"><span class="c1">ADR is located outside the database, which enables Oracle Database to access and</span></p><p class="c0"><span class="c1">manage ADR when the physical database is unavailable. An instance can create ADR</span></p><p class="c0"><span class="c1">before a database has been created.</span></p><p class="c0"><span class="c1">Problems and Incidents</span></p><p class="c0"><span class="c1">ADR proactively tracks problems, which are critical errors in the database. Critical</span></p><p class="c0"><span class="c1">errors manifest as internal errors, such as ORA-600, or other severe errors. Each</span></p><p class="c0"><span class="c1">problem has a problem key, which is a text string that describes the problem.</span></p><p class="c0"><span class="c1">When a problem occurs multiple times, ADR creates a time-stamped incident for each</span></p><p class="c0"><span class="c1">occurrence. An incident is uniquely identified by a numeric incident ID. When an</span></p><p class="c0"><span class="c1">incident occurs, ADR sends an incident alert to Enterprise Manager. Diagnosis and</span></p><p class="c0"><span class="c1">resolution of a critical error usually starts with an incident alert.</span></p><p class="c0"><span class="c1">Because a problem could generate many incidents in a short time, ADR applies flood</span></p><p class="c0"><span class="c1">control to incident generation after certain thresholds are reached. A flood-controlled</span></p><p class="c0"><span class="c1">incident generates an alert log entry, but does not generate incident dumps. In this</span></p><p class="c0"><span class="c1">way, ADR informs you that a critical error is ongoing without overloading the system</span></p><p class="c0"><span class="c1">with diagnostic data.</span></p><p class="c0"><span class="c1">ADR Structure</span></p><p class="c0"><span class="c1">The ADR base is the ADR root directory. The ADR base can contain multiple ADR</span></p><p class="c0"><span class="c1">homes, where each ADR home is the root directory for all diagnostic data&mdash;traces,</span></p><p class="c0"><span class="c1">dumps, the alert log, and so on&mdash;for an instance of an Oracle product or component.</span></p><p class="c0"><span class="c1">For example, in an Oracle RAC environment with shared storage and ASM, each</span></p><p class="c0"><span class="c1">database instance and each ASM instance has its own ADR home.</span></p><p class="c0"><span class="c1">Figure 13&ndash;8 illustrates the ADR directory hierarchy for a database instance. Other ADR</span></p><p class="c0"><span class="c1">homes for other Oracle products or components, such as ASM or Oracle Net Services,</span></p><p class="c0"><span class="c1">can exist within this hierarchy, under the same ADR base.</span></p><p class="c0"><span class="c1">Figure 13&ndash;8 ADR Directory Structure for an Oracle Database Instance</span></p><p class="c0"><span class="c1">See Also: Oracle Database Administrator&#39;s Guide for detailed</span></p><p class="c0"><span class="c1">information about the fault diagnosability infrastructure</span></p><p class="c0"><span class="c1">diag</span></p><p class="c0"><span class="c1">rdbms</span></p><p class="c0"><span class="c1">alert cdump incident trace (others)</span></p><p class="c0"><span class="c1">ADR</span></p><p class="c0"><span class="c1">base</span></p><p class="c0"><span class="c1">ADR</span></p><p class="c0"><span class="c1">home</span></p><p class="c0"><span class="c1">database name</span></p><p class="c0"><span class="c1">SIDOverview of Diagnostic Files</span></p><p class="c0"><span class="c1">13-20 Oracle Database Concepts</span></p><p class="c0"><span class="c1">As the following Linux example shows, when you start an instance with a unique SID</span></p><p class="c0"><span class="c1">and database name before creating a database, Oracle Database creates ADR by default</span></p><p class="c0"><span class="c1">as a directory structure in the host file system. The SID and database name form part</span></p><p class="c0"><span class="c1">of the path name for files in the ADR Home.</span></p><p class="c0"><span class="c1">Example 13&ndash;1 Creation of ADR</span></p><p class="c0"><span class="c1">% setenv ORACLE_SID osi</span></p><p class="c0"><span class="c1">% echo &quot;DB_NAME=dbn&quot; &gt; init.ora</span></p><p class="c0"><span class="c1">% sqlplus / as sysdba</span></p><p class="c0"><span class="c1">. .</span></p><p class="c0"><span class="c1">.</span></p><p class="c0"><span class="c1">Connected to an idle instance.</span></p><p class="c0"><span class="c1">SQL&gt; STARTUP NOMOUNT PFILE=&quot;./init.ora&quot;</span></p><p class="c0"><span class="c1">ORACLE instance started.</span></p><p class="c0"><span class="c1">Total System Global Area 146472960 bytes</span></p><p class="c0"><span class="c1">Fixed Size 1317424 bytes</span></p><p class="c0"><span class="c1">Variable Size 92276176 bytes</span></p><p class="c0"><span class="c1">Database Buffers 50331648 bytes</span></p><p class="c0"><span class="c1">Redo Buffers 2547712 bytes</span></p><p class="c0"><span class="c1">SQL&gt; SELECT NAME, VALUE FROM V$DIAG_INFO;</span></p><p class="c0"><span class="c1">NAME VALUE</span></p><p class="c0"><span class="c1">--------------------- --------------------------------------------------</span></p><p class="c0"><span class="c1">Diag Enabled TRUE</span></p><p class="c0"><span class="c1">ADR Base /u01/oracle/log</span></p><p class="c0"><span class="c1">ADR Home /u01/oracle/log/diag/rdbms/dbn/osi</span></p><p class="c0"><span class="c1">Diag Trace /u01/oracle/log/diag/rdbms/dbn/osi/trace</span></p><p class="c0"><span class="c1">Diag Alert /u01/oracle/log/diag/rdbms/dbn/osi/alert</span></p><p class="c0"><span class="c1">Diag Incident /u01/oracle/log/diag/rdbms/dbn/osi/incident</span></p><p class="c0"><span class="c1">Diag Cdump /u01/oracle/log/diag/rdbms/dbn/osi/cdump</span></p><p class="c0"><span class="c1">Health Monitor /u01/oracle/log/diag/rdbms/dbn/osi/hm</span></p><p class="c0"><span class="c1">Default Trace File /u01/oracle/log/diag/rdbms/dbn/osi/trace/osi_ora_10533.trc</span></p><p class="c0"><span class="c1">Active Problem Count 0</span></p><p class="c0"><span class="c1">Active Incident Count 0</span></p><p class="c0"><span class="c1">The following sections describe the contents of ADR.</span></p><p class="c0"><span class="c1">Alert Log</span></p><p class="c0"><span class="c1">Each database has an alert log, which is an XML file containing a chronological log of</span></p><p class="c0"><span class="c1">database messages and errors. The alert log contents include the following:</span></p><p class="c0"><span class="c1">&#9632; All internal errors (ORA-600), block corruption errors (ORA-1578), and deadlock</span></p><p class="c0"><span class="c1">errors (ORA-60)</span></p><p class="c0"><span class="c1">&#9632; Administrative operations such as DDL statements and the SQL*Plus commands</span></p><p class="c0"><span class="c1">STARTUP, SHUTDOWN, ARCHIVE LOG, and RECOVER</span></p><p class="c0"><span class="c1">&#9632; Several messages and errors relating to the functions of shared server and</span></p><p class="c0"><span class="c1">dispatcher processes</span></p><p class="c0"><span class="c1">&#9632; Errors during the automatic refresh of a materialized view</span></p><p class="c0"><span class="c1">Oracle Database uses the alert log as an alternative to displaying information in the</span></p><p class="c0"><span class="c1">Enterprise Manager GUI. If an administrative operation is successful, then Oracle</span></p><p class="c0"><span class="c1">Database writes a message to the alert log as &quot;completed&quot; along with a time stamp.Overview of Diagnostic Files</span></p><p class="c0"><span class="c1">Oracle Database Instance 13-21</span></p><p class="c0"><span class="c1">Oracle Database creates an alert log in the alert subdirectory shown in Figure 13&ndash;8</span></p><p class="c0"><span class="c1">when you first start a database instance, even if no database has been created yet. The</span></p><p class="c0"><span class="c1">following example shows a portion of a text-only alert log:</span></p><p class="c0"><span class="c1">Fri Jun 19 17:05:34 2011</span></p><p class="c0"><span class="c1">Starting ORACLE instance (normal)</span></p><p class="c0"><span class="c1">LICENSE_MAX_SESSION = 0</span></p><p class="c0"><span class="c1">LICENSE_SESSIONS_WARNING = 0</span></p><p class="c0"><span class="c1">Shared memory segment for instance monitoring created</span></p><p class="c0"><span class="c1">Picked latch-free SCN scheme 2</span></p><p class="c0"><span class="c1">Autotune of undo retention is turned on.</span></p><p class="c0"><span class="c1">IMODE=BR</span></p><p class="c0"><span class="c1">ILAT =12</span></p><p class="c0"><span class="c1">LICENSE_MAX_USERS = 0</span></p><p class="c0"><span class="c1">SYS auditing is disabled</span></p><p class="c0"><span class="c1">Starting up ORACLE RDBMS Version: 11.2.0.0.0.</span></p><p class="c0"><span class="c1">Using parameter settings in client-side pfile</span></p><p class="c0"><span class="c1">. . .</span></p><p class="c0"><span class="c1">System parameters with nondefault values:</span></p><p class="c0"><span class="c1">db_name = &quot;my_test&quot;</span></p><p class="c0"><span class="c1">Fri Jun 19 17:05:37 2011</span></p><p class="c0"><span class="c1">PMON started with pid=2, OS id=10329</span></p><p class="c0"><span class="c1">Fri Jun 19 17:05:37 2011</span></p><p class="c0"><span class="c1">VKTM started with pid=3, OS id=10331 at elevated priority</span></p><p class="c0"><span class="c1">VKTM running at (20)ms precision</span></p><p class="c0"><span class="c1">Fri Jun 19 17:05:37 2011</span></p><p class="c0"><span class="c1">DIAG started with pid=4, OS id=10335</span></p><p class="c0"><span class="c1">As shown in Example 13&ndash;1, query V$DIAG_INFO to locate the alert log.</span></p><p class="c0"><span class="c1">Trace Files</span></p><p class="c0"><span class="c1">A trace file is an administrative file that contain diagnostic data used to investigate</span></p><p class="c0"><span class="c1">problems. Also, trace files can provide guidance for tuning applications or an instance,</span></p><p class="c0"><span class="c1">as explained in &quot;Performance Diagnostics and Tuning&quot; on page 18-20.</span></p><p class="c0"><span class="c1">Types of Trace Files</span></p><p class="c0"><span class="c1">Each server and background process can periodically write to an associated trace file.</span></p><p class="c0"><span class="c1">The files information on the process environment, status, activities, and errors.</span></p><p class="c0"><span class="c1">The SQL trace facility also creates trace files, which provide performance information</span></p><p class="c0"><span class="c1">on individual SQL statements. To enable tracing for a client identifier, service, module,</span></p><p class="c0"><span class="c1">action, session, instance, or database, you must execute the appropriate procedures in</span></p><p class="c0"><span class="c1">the DBMS_MONITOR package or use Oracle Enterprise Manager.</span></p><p class="c0"><span class="c1">A dump is a special type of trace file. Whereas a trace tends to be continuous output of</span></p><p class="c0"><span class="c1">diagnostic data, a dump is typically a one-time output of diagnostic data in response</span></p><p class="c0"><span class="c1">to an event (such as an incident). When an incident occurs, the database writes one or</span></p><p class="c0"><span class="c1">more dumps to the incident directory created for the incident. Incident dumps also</span></p><p class="c0"><span class="c1">contain the incident number in the file name.Overview of Diagnostic Files</span></p><p class="c0"><span class="c1">13-22 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Locations of Trace Files</span></p><p class="c0"><span class="c1">ADR stores trace files in the trace subdirectory, as shown in Figure 13&ndash;8. Trace file</span></p><p class="c0"><span class="c1">names are platform-dependent and use the extension .trc.</span></p><p class="c0"><span class="c1">Typically, database background process trace file names contain the Oracle SID, the</span></p><p class="c0"><span class="c1">background process name, and the operating system process number. An example of a</span></p><p class="c0"><span class="c1">trace file for the RECO process is mytest_reco_10355.trc.</span></p><p class="c0"><span class="c1">Server process trace file names contain the Oracle SID, the string ora, and the</span></p><p class="c0"><span class="c1">operating system process number. An example of a server process trace file name is</span></p><p class="c0"><span class="c1">mytest_ora_10304.trc.</span></p><p class="c0"><span class="c1">Sometimes trace files have corresponding trace map (.trm) files. These files contain</span></p><p class="c0"><span class="c1">structural information about trace files and are used for searching and navigation.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Session Control Statements&quot; on page 7-8</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn about trace files,</span></p><p class="c0"><span class="c1">dumps, and core files</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Performance Tuning Guide to learn about</span></p><p class="c0"><span class="c1">application tracing</span></p><p class="c0"><span class="c1">See Also: Oracle Database Administrator&#39;s Guide to learn how to find</span></p><p class="c0"><span class="c1">trace files14</span></p><p class="c0"><span class="c1">Memory Architecture 14-1</span></p><p class="c0"><span class="c1">Memory Architecture 4 1</span></p><p class="c0"><span class="c1">This chapter discusses the memory architecture of an Oracle Database instance.</span></p><p class="c0"><span class="c1">This chapter contains the following sections:</span></p><p class="c0"><span class="c1">&#9632; Introduction to Oracle Database Memory Structures</span></p><p class="c0"><span class="c1">&#9632; Overview of the User Global Area</span></p><p class="c0"><span class="c1">&#9632; Overview of the Program Global Area</span></p><p class="c0"><span class="c1">&#9632; Overview of the System Global Area</span></p><p class="c0"><span class="c1">&#9632; Overview of Software Code Areas</span></p><p class="c0"><span class="c1">Introduction to Oracle Database Memory Structures</span></p><p class="c0"><span class="c1">When an instance is started, Oracle Database allocates a memory area and starts</span></p><p class="c0"><span class="c1">background processes. The memory area stores information such as the following:</span></p><p class="c0"><span class="c1">&#9632; Program code</span></p><p class="c0"><span class="c1">&#9632; Information about each connected session, even if it is not currently active</span></p><p class="c0"><span class="c1">&#9632; Information needed during program execution, for example, the current state of a</span></p><p class="c0"><span class="c1">query from which rows are being fetched</span></p><p class="c0"><span class="c1">&#9632; Information such as lock data that is shared and communicated among processes</span></p><p class="c0"><span class="c1">&#9632; Cached data, such as data blocks and redo records, that also exists on disk</span></p><p class="c0"><span class="c1">Basic Memory Structures</span></p><p class="c0"><span class="c1">The basic memory structures associated with Oracle Database include:</span></p><p class="c0"><span class="c1">&#9632; System global area (SGA)</span></p><p class="c0"><span class="c1">The SGA is a group of shared memory structures, known as SGA components,</span></p><p class="c0"><span class="c1">that contain data and control information for one Oracle Database instance. The</span></p><p class="c0"><span class="c1">SGA is shared by all server and background processes. Examples of data stored in</span></p><p class="c0"><span class="c1">the SGA include cached data blocks and shared SQL areas.</span></p><p class="c0"><span class="c1">&#9632; Program global area (PGA)</span></p><p class="c0"><span class="c1">See Also: Oracle Database Administrator&#39;s Guide for instructions for</span></p><p class="c0"><span class="c1">configuring and managing memory</span></p><p class="c0"><span class="c1">See Also: Chapter 15, &quot;Process Architecture&quot;Introduction to Oracle Database Memory Structures</span></p><p class="c0"><span class="c1">14-2 Oracle Database Concepts</span></p><p class="c0"><span class="c1">A PGA is a nonshared memory region that contains data and control information</span></p><p class="c0"><span class="c1">exclusively for use by an Oracle process. The PGA is created by Oracle Database</span></p><p class="c0"><span class="c1">when an Oracle process is started.</span></p><p class="c0"><span class="c1">One PGA exists for each server process and background process. The collection of</span></p><p class="c0"><span class="c1">individual PGAs is the total instance PGA, or instance PGA. Database</span></p><p class="c0"><span class="c1">initialization parameters set the size of the instance PGA, not individual PGAs.</span></p><p class="c0"><span class="c1">&#9632; User Global Area (UGA)</span></p><p class="c0"><span class="c1">The UGA is memory associated with a user session.</span></p><p class="c0"><span class="c1">&#9632; Software code areas</span></p><p class="c0"><span class="c1">Software code areas are portions of memory used to store code that is being run or</span></p><p class="c0"><span class="c1">can be run. Oracle Database code is stored in a software area that is typically at a</span></p><p class="c0"><span class="c1">different location from user programs&mdash;a more exclusive or protected location.</span></p><p class="c0"><span class="c1">Figure 14&ndash;1 illustrates the relationships among these memory structures.</span></p><p class="c0"><span class="c1">Figure 14&ndash;1 Oracle Database Memory Structures</span></p><p class="c0"><span class="c1">System Global Area (SGA)</span></p><p class="c0"><span class="c1">Large Pool</span></p><p class="c0"><span class="c1">Client</span></p><p class="c0"><span class="c1">Process</span></p><p class="c0"><span class="c1">Instance</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">Buffer Cache Redo</span></p><p class="c0"><span class="c1">Log</span></p><p class="c0"><span class="c1">Buffer</span></p><p class="c0"><span class="c1">Java</span></p><p class="c0"><span class="c1">Pool</span></p><p class="c0"><span class="c1">Streams</span></p><p class="c0"><span class="c1">Pool</span></p><p class="c0"><span class="c1">Fixed</span></p><p class="c0"><span class="c1">SGA</span></p><p class="c0"><span class="c1">Server</span></p><p class="c0"><span class="c1">Process</span></p><p class="c0"><span class="c1">PGA</span></p><p class="c0"><span class="c1">Session Memory Private SQL Area</span></p><p class="c0"><span class="c1">SQL Work Areas</span></p><p class="c0"><span class="c1">UGA</span></p><p class="c0"><span class="c1">I/O Buffer Area</span></p><p class="c0"><span class="c1">Free Memory</span></p><p class="c0"><span class="c1">Large Pool</span></p><p class="c0"><span class="c1">Response</span></p><p class="c0"><span class="c1">Queue</span></p><p class="c0"><span class="c1">Request</span></p><p class="c0"><span class="c1">Queue</span></p><p class="c0"><span class="c1">Shared Pool</span></p><p class="c0"><span class="c1">Private</span></p><p class="c0"><span class="c1">SQL Area</span></p><p class="c0"><span class="c1">(Shared</span></p><p class="c0"><span class="c1">Server Only)</span></p><p class="c0"><span class="c1">Shared SQL Area</span></p><p class="c0"><span class="c1">Library Cache</span></p><p class="c0"><span class="c1">Data</span></p><p class="c0"><span class="c1">Dictionary</span></p><p class="c0"><span class="c1">Cache</span></p><p class="c0"><span class="c1">Server</span></p><p class="c0"><span class="c1">Result</span></p><p class="c0"><span class="c1">Cache</span></p><p class="c0"><span class="c1">Other Reserved</span></p><p class="c0"><span class="c1">Pool</span></p><p class="c0"><span class="c1">SELECT * FROM</span></p><p class="c0"><span class="c1">employeesOverview of the User Global Area</span></p><p class="c0"><span class="c1">Memory Architecture 14-3</span></p><p class="c0"><span class="c1">Oracle Database Memory Management</span></p><p class="c0"><span class="c1">Memory management involves maintaining optimal sizes for the Oracle instance</span></p><p class="c0"><span class="c1">memory structures as demands on the database change. Oracle Database manages</span></p><p class="c0"><span class="c1">memory based on the settings of memory-related initialization parameters. The basic</span></p><p class="c0"><span class="c1">options for memory management are as follows:</span></p><p class="c0"><span class="c1">&#9632; Automatic memory management</span></p><p class="c0"><span class="c1">You specify the target size for instance memory. The database instance</span></p><p class="c0"><span class="c1">automatically tunes to the target memory size, redistributing memory as needed</span></p><p class="c0"><span class="c1">between the SGA and the instance PGA.</span></p><p class="c0"><span class="c1">&#9632; Automatic shared memory management</span></p><p class="c0"><span class="c1">This management mode is partially automated. You set a target size for the SGA</span></p><p class="c0"><span class="c1">and then have the option of setting an aggregate target size for the PGA or</span></p><p class="c0"><span class="c1">managing PGA work areas individually.</span></p><p class="c0"><span class="c1">&#9632; Manual memory management</span></p><p class="c0"><span class="c1">Instead of setting the total memory size, you set many initialization parameters to</span></p><p class="c0"><span class="c1">manage components of the SGA and instance PGA individually.</span></p><p class="c0"><span class="c1">If you create a database with Database Configuration Assistant (DBCA) and choose</span></p><p class="c0"><span class="c1">the basic installation option, then automatic memory management is the default.</span></p><p class="c0"><span class="c1">Overview of the User Global Area</span></p><p class="c0"><span class="c1">The UGA is session memory, which is memory allocated for session variables, such as</span></p><p class="c0"><span class="c1">logon information, and other information required by a database session. Essentially,</span></p><p class="c0"><span class="c1">the UGA stores the session state. Figure 14&ndash;2 depicts the UGA.</span></p><p class="c0"><span class="c1">Figure 14&ndash;2 User Global Area (UGA)</span></p><p class="c0"><span class="c1">If a session loads a PL/SQL package into memory, then the UGA contains the package</span></p><p class="c0"><span class="c1">state, which is the set of values stored in all the package variables at a specific time</span></p><p class="c0"><span class="c1">(see &quot;PL/SQL Packages&quot; on page 8-6). The package state changes when a package</span></p><p class="c0"><span class="c1">subprogram changes the variables. By default, the package variables are unique to and</span></p><p class="c0"><span class="c1">persist for the life of the session.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Memory Management&quot; on page 18-15 for more information about</span></p><p class="c0"><span class="c1">memory management options for DBAs</span></p><p class="c0"><span class="c1">&#9632; &quot;Tools for Database Installation and Configuration&quot; to learn about</span></p><p class="c0"><span class="c1">DBCA</span></p><p class="c0"><span class="c1">&#9632; Oracle Database 2 Day DBA and Oracle Database Administrator&#39;s</span></p><p class="c0"><span class="c1">Guide to learn about memory management options</span></p><p class="c0"><span class="c1">Session Variables</span></p><p class="c0"><span class="c1">UGA</span></p><p class="c0"><span class="c1">OLAP PoolOverview of the Program Global Area</span></p><p class="c0"><span class="c1">14-4 Oracle Database Concepts</span></p><p class="c0"><span class="c1">The OLAP page pool is also stored in the UGA. This pool manages OLAP data pages,</span></p><p class="c0"><span class="c1">which are equivalent to data blocks. The page pool is allocated at the start of an OLAP</span></p><p class="c0"><span class="c1">session and released at the end of the session. An OLAP session opens automatically</span></p><p class="c0"><span class="c1">whenever a user queries a dimensional object such as a cube.</span></p><p class="c0"><span class="c1">The UGA must be available to a database session for the life of the session. For this</span></p><p class="c0"><span class="c1">reason, the UGA cannot be stored in the PGA when using a shared server connection</span></p><p class="c0"><span class="c1">because the PGA is specific to a single process. Therefore, the UGA is stored in the</span></p><p class="c0"><span class="c1">SGA when using shared server connections, enabling any shared server process access</span></p><p class="c0"><span class="c1">to it. When using a dedicated server connection, the UGA is stored in the PGA.</span></p><p class="c0"><span class="c1">Overview of the Program Global Area</span></p><p class="c0"><span class="c1">The PGA is memory specific to an operating process or thread that is not shared by</span></p><p class="c0"><span class="c1">other processes or threads on the system. Because the PGA is process-specific, it is</span></p><p class="c0"><span class="c1">never allocated in the SGA.</span></p><p class="c0"><span class="c1">The PGA is a memory heap that contains session-dependent variables required by a</span></p><p class="c0"><span class="c1">dedicated or shared server process. The server process allocates memory structures</span></p><p class="c0"><span class="c1">that it requires in the PGA.</span></p><p class="c0"><span class="c1">An analogy for a PGA is a temporary countertop workspace used by a file clerk. In this</span></p><p class="c0"><span class="c1">analogy, the file clerk is the server process doing work on behalf of the customer (client</span></p><p class="c0"><span class="c1">process). The clerk clears a section of the countertop, uses the workspace to store</span></p><p class="c0"><span class="c1">details about the customer request and to sort the folders requested by the customer,</span></p><p class="c0"><span class="c1">and then gives up the space when the work is done.</span></p><p class="c0"><span class="c1">Figure 14&ndash;3 shows an instance PGA (collection of all PGAs) for an instance that is not</span></p><p class="c0"><span class="c1">configured for shared servers. You can use an initialization parameter to set a target</span></p><p class="c0"><span class="c1">maximum size of the instance PGA (see &quot;Summary of Memory Management Methods&quot;</span></p><p class="c0"><span class="c1">on page 18-17). Individual PGAs can grow as needed up to this target size.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Connections and Sessions&quot; on page 15-4</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Net Services Administrator&#39;s Guide to learn about</span></p><p class="c0"><span class="c1">shared server connections</span></p><p class="c0"><span class="c1">&#9632; Oracle OLAP User&#39;s Guide for an overview of Oracle OLAPOverview of the Program Global Area</span></p><p class="c0"><span class="c1">Memory Architecture 14-5</span></p><p class="c0"><span class="c1">Figure 14&ndash;3 Instance PGA</span></p><p class="c0"><span class="c1">Contents of the PGA</span></p><p class="c0"><span class="c1">The PGA is subdivided into different areas, each with a different purpose. Figure 14&ndash;4</span></p><p class="c0"><span class="c1">shows the possible contents of the PGA for a dedicated server session. Not all of the</span></p><p class="c0"><span class="c1">PGA areas will exist in every case.</span></p><p class="c0"><span class="c1">Figure 14&ndash;4 PGA Contents</span></p><p class="c0"><span class="c1">Private SQL Area</span></p><p class="c0"><span class="c1">A private SQL area holds information about a parsed SQL statement and other</span></p><p class="c0"><span class="c1">session-specific information for processing. When a server process executes SQL or</span></p><p class="c0"><span class="c1">PL/SQL code, the process uses the private SQL area to store bind variable values,</span></p><p class="c0"><span class="c1">query execution state information, and query execution work areas.</span></p><p class="c0"><span class="c1">Do not confuse a private SQL area, which is in the UGA, with the shared SQL area,</span></p><p class="c0"><span class="c1">which stores execution plans in the SGA. Multiple private SQL areas in the same or</span></p><p class="c0"><span class="c1">different sessions can point to a single execution plan in the SGA. For example, 20</span></p><p class="c0"><span class="c1">executions of SELECT * FROM employees in one session and 10 executions of the same</span></p><p class="c0"><span class="c1">query in a different session can share the same plan. The private SQL areas for each</span></p><p class="c0"><span class="c1">execution are not shared and may contain different values and data.</span></p><p class="c0"><span class="c1">A cursor is a name or handle to a specific private SQL area. As shown in Figure 14&ndash;5,</span></p><p class="c0"><span class="c1">you can think of a cursor as a pointer on the client side and as a state on the server</span></p><p class="c0"><span class="c1">Note: Background processes also allocate their own PGAs. This</span></p><p class="c0"><span class="c1">discussion focuses on server process PGAs only.</span></p><p class="c0"><span class="c1">Instance PGA</span></p><p class="c0"><span class="c1">PGA</span></p><p class="c0"><span class="c1">SQL Work Areas</span></p><p class="c0"><span class="c1">SQL Work Areas</span></p><p class="c0"><span class="c1">SQL Work Areas</span></p><p class="c0"><span class="c1">PGA</span></p><p class="c0"><span class="c1">PGA</span></p><p class="c0"><span class="c1">Server</span></p><p class="c0"><span class="c1">Process</span></p><p class="c0"><span class="c1">Server</span></p><p class="c0"><span class="c1">Process</span></p><p class="c0"><span class="c1">Server</span></p><p class="c0"><span class="c1">Process</span></p><p class="c0"><span class="c1">Session Memory</span></p><p class="c0"><span class="c1">Session Memory</span></p><p class="c0"><span class="c1">Session Memory</span></p><p class="c0"><span class="c1">Private SQL Area</span></p><p class="c0"><span class="c1">Private SQL Area</span></p><p class="c0"><span class="c1">Private SQL Area</span></p><p class="c0"><span class="c1">Sort Area Hash Area</span></p><p class="c0"><span class="c1">PGA</span></p><p class="c0"><span class="c1">Bitmap Merge Area</span></p><p class="c0"><span class="c1">Session Memory Runtime Area</span></p><p class="c0"><span class="c1">Private SQL Area</span></p><p class="c0"><span class="c1">SQL Work Areas</span></p><p class="c0"><span class="c1">Persistent</span></p><p class="c0"><span class="c1">AreaOverview of the Program Global Area</span></p><p class="c0"><span class="c1">14-6 Oracle Database Concepts</span></p><p class="c0"><span class="c1">side. Because cursors are closely associated with private SQL areas, the terms are</span></p><p class="c0"><span class="c1">sometimes used interchangeably.</span></p><p class="c0"><span class="c1">Figure 14&ndash;5 Cursor</span></p><p class="c0"><span class="c1">A private SQL area is divided into the following areas:</span></p><p class="c0"><span class="c1">&#9632; The run-time area</span></p><p class="c0"><span class="c1">This area contains query execution state information. For example, the run-time</span></p><p class="c0"><span class="c1">area tracks the number of rows retrieved so far in a full table scan.</span></p><p class="c0"><span class="c1">Oracle Database creates the run-time area as the first step of an execute request.</span></p><p class="c0"><span class="c1">For DML statements, the run-time area is freed when the SQL statement is closed.</span></p><p class="c0"><span class="c1">&#9632; The persistent area</span></p><p class="c0"><span class="c1">This area contains bind variable values. A bind variable value is supplied to a</span></p><p class="c0"><span class="c1">SQL statement at run time when the statement is executed. The persistent area is</span></p><p class="c0"><span class="c1">freed only when the cursor is closed.</span></p><p class="c0"><span class="c1">The client process is responsible for managing private SQL areas. The allocation and</span></p><p class="c0"><span class="c1">deallocation of private SQL areas depends largely on the application, although the</span></p><p class="c0"><span class="c1">number of private SQL areas that a client process can allocate is limited by the</span></p><p class="c0"><span class="c1">initialization parameter OPEN_CURSORS.</span></p><p class="c0"><span class="c1">Although most users rely on the automatic cursor handling of database utilities, the</span></p><p class="c0"><span class="c1">Oracle Database programmatic interfaces offer developers more control over cursors.</span></p><p class="c0"><span class="c1">In general, applications should close all open cursors that will not be used again to free</span></p><p class="c0"><span class="c1">the persistent area and to minimize the memory required for application users.</span></p><p class="c0"><span class="c1">SQL Work Areas</span></p><p class="c0"><span class="c1">A work area is a private allocation of PGA memory used for memory-intensive</span></p><p class="c0"><span class="c1">operations. For example, a sort operator uses the sort area to sort a set of rows.</span></p><p class="c0"><span class="c1">Similarly, a hash join operator uses a hash area to build a hash table from its left</span></p><p class="c0"><span class="c1">input, whereas a bitmap merge uses the bitmap merge area to merge data retrieved</span></p><p class="c0"><span class="c1">from scans of multiple bitmap indexes.</span></p><p class="c0"><span class="c1">Example 14&ndash;1 shows a join of employees and departments with its query plan.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Shared SQL Areas&quot; on page 14-16</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Advanced Application Developer&#39;s Guide and Oracle</span></p><p class="c0"><span class="c1">Database PL/SQL Language Reference to learn how to use cursors</span></p><p class="c0"><span class="c1">PGA</span></p><p class="c0"><span class="c1">SQL Work Areas</span></p><p class="c0"><span class="c1">Cursor</span></p><p class="c0"><span class="c1">Data Area</span></p><p class="c0"><span class="c1">Server</span></p><p class="c0"><span class="c1">Process</span></p><p class="c0"><span class="c1">Client</span></p><p class="c0"><span class="c1">Process</span></p><p class="c0"><span class="c1">Session Memory Private SQL Area</span></p><p class="c0"><span class="c1">PointerOverview of the Program Global Area</span></p><p class="c0"><span class="c1">Memory Architecture 14-7</span></p><p class="c0"><span class="c1">Example 14&ndash;1 Query Plan for Table Join</span></p><p class="c0"><span class="c1">SQL&gt; SELECT *</span></p><p class="c0"><span class="c1">2 FROM employees e JOIN departments d</span></p><p class="c0"><span class="c1">3 ON e.department_id=d.department_id</span></p><p class="c0"><span class="c1">4 ORDER BY last_name;</span></p><p class="c0"><span class="c1">. . .</span></p><p class="c0"><span class="c1">----------------------------------------------------------------------------------</span></p><p class="c0"><span class="c1">| Id | Operation | Name | Rows | Bytes | Cost (%CPU)| Time |</span></p><p class="c0"><span class="c1">----------------------------------------------------------------------------------</span></p><p class="c0"><span class="c1">| 0 | SELECT STATEMENT | | 106 | 9328 | 7 (29)| 00:00:01 |</span></p><p class="c0"><span class="c1">| 1 | SORT ORDER BY | | 106 | 9328 | 7 (29)| 00:00:01 |</span></p><p class="c0"><span class="c1">|* 2 | HASH JOIN | | 106 | 9328 | 6 (17)| 00:00:01 |</span></p><p class="c0"><span class="c1">| 3 | TABLE ACCESS FULL| DEPARTMENTS | 27 | 540 | 2 (0)| 00:00:01 |</span></p><p class="c0"><span class="c1">| 4 | TABLE ACCESS FULL| EMPLOYEES | 107 | 7276 | 3 (0)| 00:00:01 |</span></p><p class="c0"><span class="c1">----------------------------------------------------------------------------------</span></p><p class="c0"><span class="c1">In Example 14&ndash;1, the run-time area tracks the progress of the full table scans. The</span></p><p class="c0"><span class="c1">session performs a hash join in the hash area to match rows from the two tables. The</span></p><p class="c0"><span class="c1">ORDER BY sort occurs in the sort area.</span></p><p class="c0"><span class="c1">If the amount of data to be processed by the operators does not fit into a work area,</span></p><p class="c0"><span class="c1">then Oracle Database divides the input data into smaller pieces. In this way, the</span></p><p class="c0"><span class="c1">database processes some data pieces in memory while writing the rest to temporary</span></p><p class="c0"><span class="c1">disk storage for processing later.</span></p><p class="c0"><span class="c1">The database automatically tunes work area sizes when automatic PGA memory</span></p><p class="c0"><span class="c1">management is enabled. You can also manually control and tune the size of a work</span></p><p class="c0"><span class="c1">area. See &quot;Memory Management&quot; on page 18-15 for more information.</span></p><p class="c0"><span class="c1">Generally, larger work areas can significantly improve performance of an operator at</span></p><p class="c0"><span class="c1">the cost of higher memory consumption. Optimally, the size of a work area is sufficient</span></p><p class="c0"><span class="c1">to accommodate the input data and auxiliary memory structures allocated by its</span></p><p class="c0"><span class="c1">associated SQL operator. If not, response time increases because part of the input data</span></p><p class="c0"><span class="c1">must be cached on disk. In the extreme case, if the size of a work area is too small</span></p><p class="c0"><span class="c1">compared to input data size, then the database must perform multiple passes over the</span></p><p class="c0"><span class="c1">data pieces, dramatically increasing response time.</span></p><p class="c0"><span class="c1">PGA Usage in Dedicated and Shared Server Modes</span></p><p class="c0"><span class="c1">PGA memory allocation depends on whether the database uses dedicated or shared</span></p><p class="c0"><span class="c1">server connections. Table 14&ndash;1 shows the differences.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn how to use</span></p><p class="c0"><span class="c1">automatic PGA management</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Performance Tuning Guide to learn how to tune</span></p><p class="c0"><span class="c1">PGA memory</span></p><p class="c0"><span class="c1">Table 14&ndash;1 Differences in Memory Allocation Between Dedicated and Shared Servers</span></p><p class="c0"><span class="c1">Memory Area</span></p><p class="c0"><span class="c1">Dedicated</span></p><p class="c0"><span class="c1">Server</span></p><p class="c0"><span class="c1">Shared</span></p><p class="c0"><span class="c1">Server</span></p><p class="c0"><span class="c1">Nature of session memory Private Shared</span></p><p class="c0"><span class="c1">Location of the persistent area PGA SGA</span></p><p class="c0"><span class="c1">Location of the run-time area for DML/DDL statements PGA PGAOverview of the System Global Area</span></p><p class="c0"><span class="c1">14-8 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Overview of the System Global Area</span></p><p class="c0"><span class="c1">The SGA is a read/write memory area that, along with the Oracle background</span></p><p class="c0"><span class="c1">processes, make up a database instance. All server processes that execute on behalf of</span></p><p class="c0"><span class="c1">users can read information in the instance SGA. Several processes write to the SGA</span></p><p class="c0"><span class="c1">during database operation.</span></p><p class="c0"><span class="c1">Each database instance has its own SGA. Oracle Database automatically allocates</span></p><p class="c0"><span class="c1">memory for an SGA at instance startup and reclaims the memory at instance</span></p><p class="c0"><span class="c1">shutdown. When you start an instance with SQL*Plus or Oracle Enterprise Manager,</span></p><p class="c0"><span class="c1">the size of the SGA is shown as in the following example:</span></p><p class="c0"><span class="c1">SQL&gt; STARTUP</span></p><p class="c0"><span class="c1">ORACLE instance started.</span></p><p class="c0"><span class="c1">Total System Global Area 368283648 bytes</span></p><p class="c0"><span class="c1">Fixed Size 1300440 bytes</span></p><p class="c0"><span class="c1">Variable Size 343935016 bytes</span></p><p class="c0"><span class="c1">Database Buffers 16777216 bytes</span></p><p class="c0"><span class="c1">Redo Buffers 6270976 bytes</span></p><p class="c0"><span class="c1">Database mounted.</span></p><p class="c0"><span class="c1">Database opened.</span></p><p class="c0"><span class="c1">As shown in Figure 14&ndash;1, the SGA consists of several memory components, which are</span></p><p class="c0"><span class="c1">pools of memory used to satisfy a particular class of memory allocation requests. All</span></p><p class="c0"><span class="c1">SGA components except the redo log buffer allocate and deallocate space in units of</span></p><p class="c0"><span class="c1">contiguous memory called granules. Granule size is platform-specific and is</span></p><p class="c0"><span class="c1">determined by total SGA size.</span></p><p class="c0"><span class="c1">You can query the V$SGASTAT view for information about SGA components.</span></p><p class="c0"><span class="c1">The most important SGA components are the following:</span></p><p class="c0"><span class="c1">&#9632; Database Buffer Cache</span></p><p class="c0"><span class="c1">&#9632; Redo Log Buffer</span></p><p class="c0"><span class="c1">&#9632; Shared Pool</span></p><p class="c0"><span class="c1">&#9632; Large Pool</span></p><p class="c0"><span class="c1">&#9632; Java Pool</span></p><p class="c0"><span class="c1">&#9632; Streams Pool</span></p><p class="c0"><span class="c1">&#9632; Fixed SGA</span></p><p class="c0"><span class="c1">See Also: Oracle Database Net Services Administrator&#39;s Guide to learn</span></p><p class="c0"><span class="c1">how to configure a database for shared server</span></p><p class="c0"><span class="c1">Note: The server and background processes do not reside within the</span></p><p class="c0"><span class="c1">SGA, but exist in a separate memory space.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Introduction to the Oracle Database Instance&quot; on page 13-1</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Performance Tuning Guide to learn more about</span></p><p class="c0"><span class="c1">granule sizingOverview of the System Global Area</span></p><p class="c0"><span class="c1">Memory Architecture 14-9</span></p><p class="c0"><span class="c1">Database Buffer Cache</span></p><p class="c0"><span class="c1">The database buffer cache, also called the buffer cache, is the memory area that stores</span></p><p class="c0"><span class="c1">copies of data blocks read from data files. A buffer is a main memory address in which</span></p><p class="c0"><span class="c1">the buffer manager temporarily caches a currently or recently used data block. All</span></p><p class="c0"><span class="c1">users concurrently connected to a database instance share access to the buffer cache.</span></p><p class="c0"><span class="c1">Oracle Database uses the buffer cache to achieve the following goals:</span></p><p class="c0"><span class="c1">&#9632; Optimize physical I/O</span></p><p class="c0"><span class="c1">The database updates data blocks in the cache and stores metadata about the</span></p><p class="c0"><span class="c1">changes in the redo log buffer. After a COMMIT, the database writes the redo buffers</span></p><p class="c0"><span class="c1">to disk but does not immediately write data blocks to disk. Instead, database</span></p><p class="c0"><span class="c1">writer (DBW) performs lazy writes in the background.</span></p><p class="c0"><span class="c1">&#9632; Keep frequently accessed blocks in the buffer cache and write infrequently</span></p><p class="c0"><span class="c1">accessed blocks to disk</span></p><p class="c0"><span class="c1">When Database Smart Flash Cache (flash cache) is enabled, part of the buffer</span></p><p class="c0"><span class="c1">cache can reside in the flash cache. This buffer cache extension is stored on a flash</span></p><p class="c0"><span class="c1">disk device, which is a solid state storage device that uses flash memory. The</span></p><p class="c0"><span class="c1">database can improve performance by caching buffers in flash memory instead of</span></p><p class="c0"><span class="c1">reading from magnetic disk.</span></p><p class="c0"><span class="c1">Buffer States</span></p><p class="c0"><span class="c1">The database uses internal algorithms to manage buffers in the cache. A buffer can be</span></p><p class="c0"><span class="c1">in any of the following mutually exclusive states:</span></p><p class="c0"><span class="c1">&#9632; Unused</span></p><p class="c0"><span class="c1">The buffer is available for use because it has never been used or is currently</span></p><p class="c0"><span class="c1">unused. This type of buffer is the easiest for the database to use.</span></p><p class="c0"><span class="c1">&#9632; Clean</span></p><p class="c0"><span class="c1">This buffer was used earlier and now contains a read-consistent version of a block</span></p><p class="c0"><span class="c1">as of a point in time. The block contains data but is &quot;clean&quot; so it does not need to be</span></p><p class="c0"><span class="c1">checkpointed. The database can pin the block and reuse it.</span></p><p class="c0"><span class="c1">&#9632; Dirty</span></p><p class="c0"><span class="c1">The buffer contain modified data that has not yet been written to disk. The</span></p><p class="c0"><span class="c1">database must checkpoint the block before reusing it.</span></p><p class="c0"><span class="c1">Every buffer has an access mode: pinned or free (unpinned). A buffer is &quot;pinned&quot; in</span></p><p class="c0"><span class="c1">the cache so that it does not age out of memory while a user session accesses it.</span></p><p class="c0"><span class="c1">Multiple sessions cannot modify a pinned buffer at the same time.</span></p><p class="c0"><span class="c1">The database uses a sophisticated algorithm to make buffer access efficient. Pointers to</span></p><p class="c0"><span class="c1">dirty and nondirty buffers exist on the same least recently used (LRU) list, which has</span></p><p class="c0"><span class="c1">a hot end and cold end. A cold buffer is one that has not been recently used. A hot</span></p><p class="c0"><span class="c1">buffer is frequently accessed and has been recently used.</span></p><p class="c0"><span class="c1">Note: Database Smart Flash Cache is available only in Solaris and</span></p><p class="c0"><span class="c1">Oracle Enterprise Linux.</span></p><p class="c0"><span class="c1">Note: Conceptually, there is only one LRU, but for concurrency the</span></p><p class="c0"><span class="c1">database actually uses several LRUs.Overview of the System Global Area</span></p><p class="c0"><span class="c1">14-10 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Buffer Modes</span></p><p class="c0"><span class="c1">When a client requests data, Oracle Database retrieves buffers from the database buffer</span></p><p class="c0"><span class="c1">cache in either of the following modes:</span></p><p class="c0"><span class="c1">&#9632; Current mode</span></p><p class="c0"><span class="c1">A current mode get, also called a db block get, is a retrieval of a block as it</span></p><p class="c0"><span class="c1">currently appears in the buffer cache. For example, if an uncommitted transaction</span></p><p class="c0"><span class="c1">has updated two rows in a block, then a current mode get retrieves the block with</span></p><p class="c0"><span class="c1">these uncommitted rows. The database uses db block gets most frequently during</span></p><p class="c0"><span class="c1">modification statements, which must update only the current version of the block.</span></p><p class="c0"><span class="c1">&#9632; Consistent mode</span></p><p class="c0"><span class="c1">A consistent read get is a retrieval of a read-consistent version of a block. This</span></p><p class="c0"><span class="c1">retrieval may use undo data. For example, if an uncommitted transaction has</span></p><p class="c0"><span class="c1">updated two rows in a block, and if a query in a separate session requests the</span></p><p class="c0"><span class="c1">block, then the database uses undo data to create a read-consistent version of this</span></p><p class="c0"><span class="c1">block (called a consistent read clone) that does not include the uncommitted</span></p><p class="c0"><span class="c1">updates. Typically, a query retrieves blocks in consistent mode.</span></p><p class="c0"><span class="c1">Buffer I/O</span></p><p class="c0"><span class="c1">A logical I/O, also known as a buffer I/O, refers to reads and writes of buffers in the</span></p><p class="c0"><span class="c1">buffer cache. When a requested buffer is not found in memory, the database performs</span></p><p class="c0"><span class="c1">a physical I/O to copy the buffer from either the flash cache or disk into memory, and</span></p><p class="c0"><span class="c1">then a logical I/O to read the cached buffer.</span></p><p class="c0"><span class="c1">Buffer Writes The database writer (DBW) process periodically writes cold, dirty buffers</span></p><p class="c0"><span class="c1">to disk. DBWn writes buffers in the following circumstances:</span></p><p class="c0"><span class="c1">&#9632; A server process cannot find clean buffers for reading new blocks into the</span></p><p class="c0"><span class="c1">database buffer cache.</span></p><p class="c0"><span class="c1">As buffers are dirtied, the number of free buffers decreases. If the number drops</span></p><p class="c0"><span class="c1">below an internal threshold, and if clean buffers are required, then server</span></p><p class="c0"><span class="c1">processes signal DBWn to write.</span></p><p class="c0"><span class="c1">The database uses the LRU to determine which dirty buffers to write. When dirty</span></p><p class="c0"><span class="c1">buffers reach the cold end of the LRU, the database moves them off the LRU to a</span></p><p class="c0"><span class="c1">write queue. DBWn writes buffers in the queue to disk, using multiblock writes if</span></p><p class="c0"><span class="c1">possible. This mechanism prevents the end of the LRU from becoming clogged</span></p><p class="c0"><span class="c1">with dirty buffers and allows clean buffers to be found for reuse.</span></p><p class="c0"><span class="c1">&#9632; The database must advance the checkpoint, which is the position in the redo</span></p><p class="c0"><span class="c1">thread from which instance recovery must begin.</span></p><p class="c0"><span class="c1">&#9632; Tablespaces are changed to read-only status or taken offline.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Read Consistency and Undo Segments&quot; on page 9-3</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Reference for descriptions of database statistics</span></p><p class="c0"><span class="c1">such as db block get and consistent read get</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Database Writer Process (DBWn)&quot; on page 15-8</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Performance Tuning Guide to learn how to diagnose</span></p><p class="c0"><span class="c1">and tune buffer write issuesOverview of the System Global Area</span></p><p class="c0"><span class="c1">Memory Architecture 14-11</span></p><p class="c0"><span class="c1">Buffer Reads When the number of clean or unused buffers is low, the database must</span></p><p class="c0"><span class="c1">remove buffers from the buffer cache. The algorithm depends on whether the flash</span></p><p class="c0"><span class="c1">cache is enabled:</span></p><p class="c0"><span class="c1">&#9632; Flash cache disabled</span></p><p class="c0"><span class="c1">The database re-uses each clean buffer as needed, overwriting it. If the overwritten</span></p><p class="c0"><span class="c1">buffer is needed later, then the database must read it from magnetic disk.</span></p><p class="c0"><span class="c1">&#9632; Flash cache enabled</span></p><p class="c0"><span class="c1">DBWn can write the body of a clean buffer to the flash cache, enabling reuse of its</span></p><p class="c0"><span class="c1">in-memory buffer. The database keeps the buffer header in an LRU list in main</span></p><p class="c0"><span class="c1">memory to track the state and location of the buffer body in the flash cache. If this</span></p><p class="c0"><span class="c1">buffer is needed later, then the database can read it from the flash cache instead of</span></p><p class="c0"><span class="c1">from magnetic disk.</span></p><p class="c0"><span class="c1">When a client process requests a buffer, the server process searches the buffer cache for</span></p><p class="c0"><span class="c1">the buffer. A cache hit occurs if the database finds the buffer in memory. The search</span></p><p class="c0"><span class="c1">order is as follows:</span></p><p class="c0"><span class="c1">1. The server process searches for the whole buffer in the buffer cache.</span></p><p class="c0"><span class="c1">If the process finds the whole buffer, then the database performs a logical read of</span></p><p class="c0"><span class="c1">this buffer.</span></p><p class="c0"><span class="c1">2. The server process searches for the buffer header in the flash cache LRU list.</span></p><p class="c0"><span class="c1">If the process finds the buffer header, then the database performs an optimized</span></p><p class="c0"><span class="c1">physical read of the buffer body from the flash cache into the in-memory cache.</span></p><p class="c0"><span class="c1">3. If the process does not find the buffer in memory (a cache miss), then the server</span></p><p class="c0"><span class="c1">process performs the following steps:</span></p><p class="c0"><span class="c1">a. Copies the block from a data file into memory (a physical read)</span></p><p class="c0"><span class="c1">b. Performs a logical read of the buffer that was read into memory</span></p><p class="c0"><span class="c1">Figure 14&ndash;6 illustrates the buffer search order. The extended buffer cache includes both</span></p><p class="c0"><span class="c1">the in-memory buffer cache, which contains whole buffers, and the flash cache, which</span></p><p class="c0"><span class="c1">contains buffer bodies. In the figure, the database searches for a buffer in the buffer</span></p><p class="c0"><span class="c1">cache and, not finding the buffer, reads it into memory from magnetic disk.Overview of the System Global Area</span></p><p class="c0"><span class="c1">14-12 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Figure 14&ndash;6 Buffer Search</span></p><p class="c0"><span class="c1">In general, accessing data through a cache hit is faster than through a cache miss. The</span></p><p class="c0"><span class="c1">buffer cache hit ratio measures how often the database found a requested block in the</span></p><p class="c0"><span class="c1">buffer cache without needing to read it from disk.</span></p><p class="c0"><span class="c1">The database can perform physical reads from either a data file or a temp file. Reads</span></p><p class="c0"><span class="c1">from a data file are followed by logical I/Os. Reads from a temp file occur when</span></p><p class="c0"><span class="c1">insufficient memory forces the database write data to a temporary table and read it</span></p><p class="c0"><span class="c1">back later. These physical reads bypass the buffer cache and do not incur a logical I/O.</span></p><p class="c0"><span class="c1">Buffer Touch Counts The database measures the frequency of access of buffers on the</span></p><p class="c0"><span class="c1">LRU list using a touch count. This mechanism enables the database to increment a</span></p><p class="c0"><span class="c1">counter when a buffer is pinned instead of constantly shuffling buffers on the LRU list.</span></p><p class="c0"><span class="c1">When a buffer is pinned, the database determines when its touch count was last</span></p><p class="c0"><span class="c1">incremented. If the count was incremented over three seconds ago, then the count is</span></p><p class="c0"><span class="c1">incremented; otherwise, the count stays the same. The three-second rule prevents a</span></p><p class="c0"><span class="c1">burst of pins on a buffer counting as many touches. For example, a session may insert</span></p><p class="c0"><span class="c1">several rows in a data block, but the database considers these inserts as one touch.</span></p><p class="c0"><span class="c1">If a buffer is on the cold end of the LRU, but its touch count is high, then the buffer</span></p><p class="c0"><span class="c1">moves to the hot end. If the touch count is low, then the buffer ages out of the cache.</span></p><p class="c0"><span class="c1">See Also: Oracle Database Performance Tuning Guide to learn how to</span></p><p class="c0"><span class="c1">calculate the buffer cache hit ratio</span></p><p class="c0"><span class="c1">Note: The database does not physically move blocks in memory. The</span></p><p class="c0"><span class="c1">movement is the change in location of a pointer on a list.</span></p><p class="c0"><span class="c1">In-Memory Buffer Cache Flash Cache</span></p><p class="c0"><span class="c1">Server</span></p><p class="c0"><span class="c1">Process</span></p><p class="c0"><span class="c1">Extended Database Buffer Cache</span></p><p class="c0"><span class="c1">1</span></p><p class="c0"><span class="c1">2</span></p><p class="c0"><span class="c1">Magnetic</span></p><p class="c0"><span class="c1">Disk</span></p><p class="c0"><span class="c1">3Overview of the System Global Area</span></p><p class="c0"><span class="c1">Memory Architecture 14-13</span></p><p class="c0"><span class="c1">Buffers and Full Table Scans When buffers must be read from disk, the database inserts</span></p><p class="c0"><span class="c1">the buffers into the middle of the LRU list. In this way, hot blocks can remain in the</span></p><p class="c0"><span class="c1">cache so that they do not need to be read from disk again.</span></p><p class="c0"><span class="c1">A problem is posed by a full table scan, which sequentially reads all rows under the</span></p><p class="c0"><span class="c1">table high water mark (see &quot;Segment Space and the High Water Mark&quot; on page 12-27).</span></p><p class="c0"><span class="c1">Suppose that the total size of the blocks in a table segment is greater than the size of</span></p><p class="c0"><span class="c1">the buffer cache. A full scan of this table could clean out the buffer cache, preventing</span></p><p class="c0"><span class="c1">the database from maintaining a cache of frequently accessed blocks.</span></p><p class="c0"><span class="c1">Blocks read into the database cache as the result of a full scan of a large table are</span></p><p class="c0"><span class="c1">treated differently from other types of reads. The blocks are immediately available for</span></p><p class="c0"><span class="c1">reuse to prevent the scan from effectively cleaning out the buffer cache.</span></p><p class="c0"><span class="c1">In the rare case where the default behavior is not desired, you can change the CACHE</span></p><p class="c0"><span class="c1">attribute of the table. In this case, the database does not force or pin the blocks in the</span></p><p class="c0"><span class="c1">buffer cache, but ages them out of the cache in the same way as any other block. Use</span></p><p class="c0"><span class="c1">care when exercising this option because a full scan of a large table may clean most of</span></p><p class="c0"><span class="c1">the other blocks out of the cache.</span></p><p class="c0"><span class="c1">Buffer Pools</span></p><p class="c0"><span class="c1">A buffer pool is a collection of buffers. The database buffer cache is divided into one</span></p><p class="c0"><span class="c1">or more buffer pools.</span></p><p class="c0"><span class="c1">You can manually configure separate buffer pools that either keep data in the buffer</span></p><p class="c0"><span class="c1">cache or make the buffers available for new data immediately after using the data</span></p><p class="c0"><span class="c1">blocks. You can then assign specific schema objects to the appropriate buffer pool to</span></p><p class="c0"><span class="c1">control how blocks age out of the cache.</span></p><p class="c0"><span class="c1">The possible buffer pools are as follows:</span></p><p class="c0"><span class="c1">&#9632; Default pool</span></p><p class="c0"><span class="c1">This pool is the location where blocks are normally cached. Unless you manually</span></p><p class="c0"><span class="c1">configure separate pools, the default pool is the only buffer pool.</span></p><p class="c0"><span class="c1">&#9632; Keep pool</span></p><p class="c0"><span class="c1">This pool is intended for blocks that were accessed frequently, but which aged out</span></p><p class="c0"><span class="c1">of the default pool because of lack of space. The goal of the keep buffer pool is to</span></p><p class="c0"><span class="c1">retain objects in memory, thus avoiding I/O operations.</span></p><p class="c0"><span class="c1">&#9632; Recycle pool</span></p><p class="c0"><span class="c1">This pool is intended for blocks that are used infrequently. A recycle pool prevent</span></p><p class="c0"><span class="c1">objects from consuming unnecessary space in the cache.</span></p><p class="c0"><span class="c1">A database has a standard block size (see &quot;Database Block Size&quot; on page 12-7). You can</span></p><p class="c0"><span class="c1">create a tablespace with a block size that differs from the standard size. Each</span></p><p class="c0"><span class="c1">nondefault block size has its own pool. Oracle Database manages the blocks in these</span></p><p class="c0"><span class="c1">pools in the same way as in the default pool.</span></p><p class="c0"><span class="c1">Figure 14&ndash;7 shows the structure of the buffer cache when multiple pools are used. The</span></p><p class="c0"><span class="c1">cache contains default, keep, and recycle pools. The default block size is 8 KB. The</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database SQL Language Reference for information about</span></p><p class="c0"><span class="c1">the CACHE clause</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Performance Tuning Guide to learn how to</span></p><p class="c0"><span class="c1">interpret buffer cache advisory statisticsOverview of the System Global Area</span></p><p class="c0"><span class="c1">14-14 Oracle Database Concepts</span></p><p class="c0"><span class="c1">cache contains separate pools for tablespaces that use the nonstandard block sizes of 2</span></p><p class="c0"><span class="c1">KB, 4 KB, and 16 KB.</span></p><p class="c0"><span class="c1">Figure 14&ndash;7 Database Buffer Cache</span></p><p class="c0"><span class="c1">Redo Log Buffer</span></p><p class="c0"><span class="c1">The redo log buffer is a circular buffer in the SGA that stores redo entries describing</span></p><p class="c0"><span class="c1">changes made to the database. Redo entries contain the information necessary to</span></p><p class="c0"><span class="c1">reconstruct, or redo, changes made to the database by DML or DDL operations.</span></p><p class="c0"><span class="c1">Database recovery applies redo entries to data files to reconstruct lost changes.</span></p><p class="c0"><span class="c1">Oracle Database processes copy redo entries from the user memory space to the redo</span></p><p class="c0"><span class="c1">log buffer in the SGA. The redo entries take up continuous, sequential space in the</span></p><p class="c0"><span class="c1">buffer. The background process log writer (LGWR) writes the redo log buffer to the</span></p><p class="c0"><span class="c1">active online redo log group on disk. Figure 14&ndash;8 shows this redo buffer activity.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database 2 Day DBA and Oracle Database Administrator&#39;s</span></p><p class="c0"><span class="c1">Guide to learn more about buffer pools</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Performance Tuning Guide to learn how to use</span></p><p class="c0"><span class="c1">multiple buffer pools</span></p><p class="c0"><span class="c1">Database Buffer Cache</span></p><p class="c0"><span class="c1">Default 2K</span></p><p class="c0"><span class="c1">4K</span></p><p class="c0"><span class="c1">Keep Recycle 16KOverview of the System Global Area</span></p><p class="c0"><span class="c1">Memory Architecture 14-15</span></p><p class="c0"><span class="c1">Figure 14&ndash;8 Redo Log Buffer</span></p><p class="c0"><span class="c1">LGWR writes redo sequentially to disk while DBWn performs scattered writes of data</span></p><p class="c0"><span class="c1">blocks to disk. Scattered writes tend to be much slower than sequential writes. Because</span></p><p class="c0"><span class="c1">LGWR enable users to avoid waiting for DBWn to complete its slow writes, the</span></p><p class="c0"><span class="c1">database delivers better performance.</span></p><p class="c0"><span class="c1">The LOG_BUFFER initialization parameter specifies the amount of memory that Oracle</span></p><p class="c0"><span class="c1">Database uses when buffering redo entries. Unlike other SGA components, the redo</span></p><p class="c0"><span class="c1">log buffer and fixed SGA buffer do not divide memory into granules.</span></p><p class="c0"><span class="c1">Shared Pool</span></p><p class="c0"><span class="c1">The shared pool caches various types of program data. For example, the shared pool</span></p><p class="c0"><span class="c1">stores parsed SQL, PL/SQL code, system parameters, and data dictionary</span></p><p class="c0"><span class="c1">information. The shared pool is involved in almost every operation that occurs in the</span></p><p class="c0"><span class="c1">database. For example, if a user executes a SQL statement, then Oracle Database</span></p><p class="c0"><span class="c1">accesses the shared pool.</span></p><p class="c0"><span class="c1">The shared pool is divided into several subcomponents, the most important of which</span></p><p class="c0"><span class="c1">are shown in Figure 14&ndash;9.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Log Writer Process (LGWR)&quot; on page 15-9 and &quot;Importance of</span></p><p class="c0"><span class="c1">Checkpoints for Instance Recovery&quot; on page 13-13</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide for information about the</span></p><p class="c0"><span class="c1">online redo log</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">Buffer Cache Redo</span></p><p class="c0"><span class="c1">Log</span></p><p class="c0"><span class="c1">Buffer</span></p><p class="c0"><span class="c1">LGWR</span></p><p class="c0"><span class="c1">Online</span></p><p class="c0"><span class="c1">Redo Log</span></p><p class="c0"><span class="c1">Server</span></p><p class="c0"><span class="c1">Process</span></p><p class="c0"><span class="c1">PGA</span></p><p class="c0"><span class="c1">Session Memory Private SQL Area</span></p><p class="c0"><span class="c1">SQL Work AreasOverview of the System Global Area</span></p><p class="c0"><span class="c1">14-16 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Figure 14&ndash;9 Shared Pool</span></p><p class="c0"><span class="c1">This section includes the following topics:</span></p><p class="c0"><span class="c1">&#9632; Library Cache</span></p><p class="c0"><span class="c1">&#9632; Data Dictionary Cache</span></p><p class="c0"><span class="c1">&#9632; Server Result Cache</span></p><p class="c0"><span class="c1">&#9632; Reserved Pool</span></p><p class="c0"><span class="c1">Library Cache</span></p><p class="c0"><span class="c1">The library cache is a shared pool memory structure that stores executable SQL and</span></p><p class="c0"><span class="c1">PL/SQL code. This cache contains the shared SQL and PL/SQL areas and control</span></p><p class="c0"><span class="c1">structures such as locks and library cache handles. In a shared server architecture, the</span></p><p class="c0"><span class="c1">library cache also contains private SQL areas.</span></p><p class="c0"><span class="c1">When a SQL statement is executed, the database attempts to reuse previously executed</span></p><p class="c0"><span class="c1">code. If a parsed representation of a SQL statement exists in the library cache and can</span></p><p class="c0"><span class="c1">be shared, then the database reuses the code, known as a soft parse or a library cache</span></p><p class="c0"><span class="c1">hit. Otherwise, the database must build a new executable version of the application</span></p><p class="c0"><span class="c1">code, known as a hard parse or a library cache miss.</span></p><p class="c0"><span class="c1">Shared SQL Areas The database represents each SQL statement that it runs in the</span></p><p class="c0"><span class="c1">following SQL areas:</span></p><p class="c0"><span class="c1">&#9632; Shared SQL area</span></p><p class="c0"><span class="c1">The database uses the shared SQL area to process the first occurrence of a SQL</span></p><p class="c0"><span class="c1">statement. This area is accessible to all users and contains the statement parse tree</span></p><p class="c0"><span class="c1">and execution plan. Only one shared SQL area exists for a unique statement.</span></p><p class="c0"><span class="c1">&#9632; Private SQL area</span></p><p class="c0"><span class="c1">Each session issuing a SQL statement has a private SQL area in its PGA (see</span></p><p class="c0"><span class="c1">&quot;Private SQL Area&quot; on page 14-5). Each user that submits the same statement has a</span></p><p class="c0"><span class="c1">private SQL area pointing to the same shared SQL area. Thus, many private SQL</span></p><p class="c0"><span class="c1">areas in separate PGAs can be associated with the same shared SQL area.</span></p><p class="c0"><span class="c1">Shared Pool</span></p><p class="c0"><span class="c1">(Shared Server Only)</span></p><p class="c0"><span class="c1">Private SQL Area</span></p><p class="c0"><span class="c1">&middot; Parsed SQL Statements</span></p><p class="c0"><span class="c1">&middot; SQL Execution Plans</span></p><p class="c0"><span class="c1">&middot; Parsed and Compiled PL/SQL Program Units</span></p><p class="c0"><span class="c1">Shared SQL Area</span></p><p class="c0"><span class="c1">Library Cache</span></p><p class="c0"><span class="c1">Dictionary</span></p><p class="c0"><span class="c1">Data Stored</span></p><p class="c0"><span class="c1">in Rows</span></p><p class="c0"><span class="c1">Data Dictionary</span></p><p class="c0"><span class="c1">Cache</span></p><p class="c0"><span class="c1">SQL Query</span></p><p class="c0"><span class="c1">Result Cache</span></p><p class="c0"><span class="c1">PL/SQL Function</span></p><p class="c0"><span class="c1">Result Cache</span></p><p class="c0"><span class="c1">Server Result</span></p><p class="c0"><span class="c1">Cache</span></p><p class="c0"><span class="c1">Other Reserved</span></p><p class="c0"><span class="c1">PoolOverview of the System Global Area</span></p><p class="c0"><span class="c1">Memory Architecture 14-17</span></p><p class="c0"><span class="c1">The database automatically determines when applications submit similar SQL</span></p><p class="c0"><span class="c1">statements. The database considers both SQL statements issued directly by users and</span></p><p class="c0"><span class="c1">applications and recursive SQL statements issued internally by other statements.</span></p><p class="c0"><span class="c1">The database performs the following steps:</span></p><p class="c0"><span class="c1">1. Checks the shared pool to see if a shared SQL area exists for a syntactically and</span></p><p class="c0"><span class="c1">semantically identical statement:</span></p><p class="c0"><span class="c1">&#9632; If an identical statement exists, then the database uses the shared SQL area for</span></p><p class="c0"><span class="c1">the execution of the subsequent new instances of the statement, thereby</span></p><p class="c0"><span class="c1">reducing memory consumption.</span></p><p class="c0"><span class="c1">&#9632; If an identical statement does not exist, then the database allocates a new</span></p><p class="c0"><span class="c1">shared SQL area in the shared pool. A statement with the same syntax but</span></p><p class="c0"><span class="c1">different semantics uses a child cursor.</span></p><p class="c0"><span class="c1">In either case, the private SQL area for the user points to the shared SQL area that</span></p><p class="c0"><span class="c1">contains the statement and execution plan.</span></p><p class="c0"><span class="c1">2. Allocates a private SQL area on behalf of the session</span></p><p class="c0"><span class="c1">The location of the private SQL area depends on the connection established for the</span></p><p class="c0"><span class="c1">session. If a session is connected through a shared server, then part of the private</span></p><p class="c0"><span class="c1">SQL area is kept in the SGA.</span></p><p class="c0"><span class="c1">Figure 14&ndash;10 shows a dedicated server architecture in which two sessions keep a copy</span></p><p class="c0"><span class="c1">of the same SQL statement in their own PGAs. In a shared server, this copy is in the</span></p><p class="c0"><span class="c1">UGA, which is in the large pool or in the shared pool when no large pool exists.Overview of the System Global Area</span></p><p class="c0"><span class="c1">14-18 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Figure 14&ndash;10 Private SQL Areas and Shared SQL Area</span></p><p class="c0"><span class="c1">Program Units and the Library Cache The library cache holds executable forms of PL/SQL</span></p><p class="c0"><span class="c1">programs and Java classes. These items are collectively referred to as program units.</span></p><p class="c0"><span class="c1">The database processes program units similarly to SQL statements. For example, the</span></p><p class="c0"><span class="c1">database allocates a shared area to hold the parsed, compiled form of a PL/SQL</span></p><p class="c0"><span class="c1">program. The database allocates a private area to hold values specific to the session</span></p><p class="c0"><span class="c1">that runs the program, including local, global, and package variables, and buffers for</span></p><p class="c0"><span class="c1">executing SQL. If multiple users run the same program, then each user maintains a</span></p><p class="c0"><span class="c1">separate copy of his or her private SQL area, which holds session-specific values, and</span></p><p class="c0"><span class="c1">accesses a single shared SQL area.</span></p><p class="c0"><span class="c1">The database processes individual SQL statements within a PL/SQL program unit as</span></p><p class="c0"><span class="c1">previously described. Despite their origins within a PL/SQL program unit, these SQL</span></p><p class="c0"><span class="c1">statements use a shared area to hold their parsed representations and a private area for</span></p><p class="c0"><span class="c1">each session that runs the statement.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Performance Tuning Guide to learn more about</span></p><p class="c0"><span class="c1">managing the library cache</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Advanced Application Developer&#39;s Guide for more</span></p><p class="c0"><span class="c1">information about shared SQL</span></p><p class="c0"><span class="c1">System Global Area (SGA)</span></p><p class="c0"><span class="c1">Instance</span></p><p class="c0"><span class="c1">Shared Pool</span></p><p class="c0"><span class="c1">Private</span></p><p class="c0"><span class="c1">SQL Area</span></p><p class="c0"><span class="c1">(Shared</span></p><p class="c0"><span class="c1">Server Only)</span></p><p class="c0"><span class="c1">Shared SQL Area</span></p><p class="c0"><span class="c1">Library Cache</span></p><p class="c0"><span class="c1">Data</span></p><p class="c0"><span class="c1">Dictionary</span></p><p class="c0"><span class="c1">Cache</span></p><p class="c0"><span class="c1">Server</span></p><p class="c0"><span class="c1">Result</span></p><p class="c0"><span class="c1">Cache</span></p><p class="c0"><span class="c1">Other Reserved</span></p><p class="c0"><span class="c1">Pool</span></p><p class="c0"><span class="c1">SELECT * FROM employees</span></p><p class="c0"><span class="c1">Client</span></p><p class="c0"><span class="c1">Process</span></p><p class="c0"><span class="c1">Server</span></p><p class="c0"><span class="c1">Process</span></p><p class="c0"><span class="c1">PGA</span></p><p class="c0"><span class="c1">Session Memory Private SQL Area</span></p><p class="c0"><span class="c1">SQL Work Areas</span></p><p class="c0"><span class="c1">SELECT * FROM</span></p><p class="c0"><span class="c1">employees</span></p><p class="c0"><span class="c1">Client</span></p><p class="c0"><span class="c1">Process</span></p><p class="c0"><span class="c1">Server</span></p><p class="c0"><span class="c1">Process</span></p><p class="c0"><span class="c1">PGA</span></p><p class="c0"><span class="c1">Session Memory Private SQL Area</span></p><p class="c0"><span class="c1">SQL Work Areas</span></p><p class="c0"><span class="c1">SELECT * FROM employeesOverview of the System Global Area</span></p><p class="c0"><span class="c1">Memory Architecture 14-19</span></p><p class="c0"><span class="c1">Allocation and Reuse of Memory in the Shared Pool The database allocates shared pool</span></p><p class="c0"><span class="c1">memory when a new SQL statement is parsed. The memory size depends on the</span></p><p class="c0"><span class="c1">complexity of the statement.</span></p><p class="c0"><span class="c1">In general, an item in the shared pool stays until it is removed according to an LRU</span></p><p class="c0"><span class="c1">algorithm. The database allows shared pool items used by many sessions to remain in</span></p><p class="c0"><span class="c1">memory as long as they are useful, even if the process that created the item terminates.</span></p><p class="c0"><span class="c1">This mechanism minimizes the overhead and processing of SQL statements.</span></p><p class="c0"><span class="c1">If space is needed for new items, then the database frees memory for infrequently used</span></p><p class="c0"><span class="c1">items. A shared SQL area can be removed from the shared pool even if the shared SQL</span></p><p class="c0"><span class="c1">area corresponds to an open cursor that has not been used for some time. If the open</span></p><p class="c0"><span class="c1">cursor is subsequently used to run its statement, then Oracle Database reparses the</span></p><p class="c0"><span class="c1">statement and allocates a new shared SQL area.</span></p><p class="c0"><span class="c1">The database also removes a shared SQL area from the shared pool in the following</span></p><p class="c0"><span class="c1">circumstances:</span></p><p class="c0"><span class="c1">&#9632; If statistics are gathered for a table, table cluster, or index, then by default the</span></p><p class="c0"><span class="c1">database gradually removes all shared SQL areas that contain statements</span></p><p class="c0"><span class="c1">referencing the analyzed object after a period of time. The next time a removed</span></p><p class="c0"><span class="c1">statement is run, the database parses it in a new shared SQL area to reflect the new</span></p><p class="c0"><span class="c1">statistics for the schema object.</span></p><p class="c0"><span class="c1">&#9632; If a schema object is referenced in a SQL statement, and if this object is later</span></p><p class="c0"><span class="c1">modified by a DDL statement, then the database invalidates the shared SQL area.</span></p><p class="c0"><span class="c1">The optimizer must reparse the statement the next time it is run.</span></p><p class="c0"><span class="c1">&#9632; If you change the global database name, then the database removes all information</span></p><p class="c0"><span class="c1">from the shared pool.</span></p><p class="c0"><span class="c1">You can use the ALTER SYSTEM FLUSH SHARED_POOL statement to manually remove all</span></p><p class="c0"><span class="c1">information in the shared pool to assess the performance that can be expected after an</span></p><p class="c0"><span class="c1">instance restart.</span></p><p class="c0"><span class="c1">Data Dictionary Cache</span></p><p class="c0"><span class="c1">The data dictionary is a collection of database tables and views containing reference</span></p><p class="c0"><span class="c1">information about the database, its structures, and its users. Oracle Database accesses</span></p><p class="c0"><span class="c1">the data dictionary frequently during SQL statement parsing.</span></p><p class="c0"><span class="c1">The data dictionary is accessed so often by Oracle Database that the following special</span></p><p class="c0"><span class="c1">memory locations are designated to hold dictionary data:</span></p><p class="c0"><span class="c1">&#9632; Data dictionary cache</span></p><p class="c0"><span class="c1">This cache holds information about database objects. The cache is also known as</span></p><p class="c0"><span class="c1">the row cache because it holds data as rows instead of buffers.</span></p><p class="c0"><span class="c1">&#9632; Library cache</span></p><p class="c0"><span class="c1">All server processes share these caches for access to data dictionary information.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database SQL Language Reference for information about</span></p><p class="c0"><span class="c1">using ALTER SYSTEM FLUSH SHARED_POOL</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Reference for information about V$SQL and</span></p><p class="c0"><span class="c1">V$SQLAREA dynamic viewsOverview of the System Global Area</span></p><p class="c0"><span class="c1">14-20 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Server Result Cache</span></p><p class="c0"><span class="c1">Unlike the buffer pools, the server result cache holds result sets and not data blocks.</span></p><p class="c0"><span class="c1">The server result cache contains the SQL query result cache and PL/SQL function</span></p><p class="c0"><span class="c1">result cache, which share the same infrastructure.</span></p><p class="c0"><span class="c1">A client result cache differs from the server result cache. A client cache is configured</span></p><p class="c0"><span class="c1">at the application level and is located in client memory, not in database memory.</span></p><p class="c0"><span class="c1">SQL Query Result Cache The database can store the results of queries and query</span></p><p class="c0"><span class="c1">fragments in the SQL query result cache, using the cached results for future queries</span></p><p class="c0"><span class="c1">and query fragments. Most applications benefit from this performance improvement.</span></p><p class="c0"><span class="c1">For example, suppose an application runs the same SELECT statement repeatedly. If the</span></p><p class="c0"><span class="c1">results are cached, then the database returns them immediately. In this way, the</span></p><p class="c0"><span class="c1">database avoids the expensive operation of rereading blocks and recomputing results.</span></p><p class="c0"><span class="c1">The database automatically invalidates a cached result whenever a transaction</span></p><p class="c0"><span class="c1">modifies the data or metadata of database objects used to construct that cached result.</span></p><p class="c0"><span class="c1">Users can annotate a query or query fragment with a RESULT_CACHE hint to indicate</span></p><p class="c0"><span class="c1">that the database should store results in the SQL query result cache. The</span></p><p class="c0"><span class="c1">RESULT_CACHE_MODE initialization parameter determines whether the SQL query result</span></p><p class="c0"><span class="c1">cache is used for all queries (when possible) or only for annotated queries.</span></p><p class="c0"><span class="c1">PL/SQL Function Result Cache The PL/SQL function result cache stores function result</span></p><p class="c0"><span class="c1">sets. Without caching, 1000 calls of a function at 1 second per call would take 1000</span></p><p class="c0"><span class="c1">seconds. With caching, 1000 function calls with the same inputs could take 1 second</span></p><p class="c0"><span class="c1">total. Good candidates for result caching are frequently invoked functions that depend</span></p><p class="c0"><span class="c1">on relatively static data.</span></p><p class="c0"><span class="c1">PL/SQL function code can include a request to cache its results. Upon invocation of</span></p><p class="c0"><span class="c1">this function, the system checks the cache. If the cache contains the result from a</span></p><p class="c0"><span class="c1">previous function call with the same parameter values, then the system returns the</span></p><p class="c0"><span class="c1">cached result to the invoker and does not reexecute the function body. If the cache</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Chapter 6, &quot;Data Dictionary and Dynamic Performance Views&quot;</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Performance Tuning Guide to learn how to</span></p><p class="c0"><span class="c1">allocate additional memory to the data dictionary cache</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide for information about sizing</span></p><p class="c0"><span class="c1">the result cache</span></p><p class="c0"><span class="c1">&#9632; Oracle Database PL/SQL Packages and Types Reference for</span></p><p class="c0"><span class="c1">information about the DBMS_RESULT_CACHE package</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Performance Tuning Guide for more information</span></p><p class="c0"><span class="c1">about the client result cache</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Reference to learn more about the</span></p><p class="c0"><span class="c1">RESULT_CACHE_MODE initialization parameter</span></p><p class="c0"><span class="c1">&#9632; Oracle Database SQL Language Reference to learn about the</span></p><p class="c0"><span class="c1">RESULT_CACHE hintOverview of the System Global Area</span></p><p class="c0"><span class="c1">Memory Architecture 14-21</span></p><p class="c0"><span class="c1">does not contain the result, then the system executes the function body and adds the</span></p><p class="c0"><span class="c1">result (for these parameter values) to the cache before returning control to the invoker.</span></p><p class="c0"><span class="c1">The cache can accumulate many results&mdash;one result for every unique combination of</span></p><p class="c0"><span class="c1">parameter values with which each result-cached function was invoked. If the database</span></p><p class="c0"><span class="c1">needs more memory, then it ages out one or more cached results.</span></p><p class="c0"><span class="c1">Reserved Pool</span></p><p class="c0"><span class="c1">The reserved pool is a memory area in the shared pool that Oracle Database can use to</span></p><p class="c0"><span class="c1">allocate large contiguous chunks of memory.</span></p><p class="c0"><span class="c1">Allocation of memory from the shared pool is performed in chunks. Chunking allows</span></p><p class="c0"><span class="c1">large objects (over 5 KB) to be loaded into the cache without requiring a single</span></p><p class="c0"><span class="c1">contiguous area. In this way, the database reduces the possibility of running out of</span></p><p class="c0"><span class="c1">contiguous memory because of fragmentation.</span></p><p class="c0"><span class="c1">Infrequently, Java, PL/SQL, or SQL cursors may make allocations out of the shared</span></p><p class="c0"><span class="c1">pool that are larger than 5 KB. To allow these allocations to occur most efficiently, the</span></p><p class="c0"><span class="c1">database segregates a small amount of the shared pool for the reserved pool.</span></p><p class="c0"><span class="c1">Large Pool</span></p><p class="c0"><span class="c1">The large pool is an optional memory area intended for memory allocations that are</span></p><p class="c0"><span class="c1">larger than is appropriate for the shared pool. The large pool can provide large</span></p><p class="c0"><span class="c1">memory allocations for the following:</span></p><p class="c0"><span class="c1">&#9632; UGA for the shared server and the Oracle XA interface (used where transactions</span></p><p class="c0"><span class="c1">interact with multiple databases)</span></p><p class="c0"><span class="c1">&#9632; Message buffers used in the parallel execution of statements</span></p><p class="c0"><span class="c1">&#9632; Buffers for Recovery Manager (RMAN) I/O slaves</span></p><p class="c0"><span class="c1">By allocating session memory from the large pool for shared SQL, the database avoids</span></p><p class="c0"><span class="c1">performance overhead caused by shrinking the shared SQL cache. By allocating</span></p><p class="c0"><span class="c1">memory in large buffers for RMAN operations, I/O server processes, and parallel</span></p><p class="c0"><span class="c1">buffers, the large pool can satisfy large memory requests better than the shared pool.</span></p><p class="c0"><span class="c1">Figure 14&ndash;11 is a graphical depiction of the large pool.</span></p><p class="c0"><span class="c1">Note: You can specify the database objects that are used to compute</span></p><p class="c0"><span class="c1">a cached result so that if any of them are updated, the cached result</span></p><p class="c0"><span class="c1">becomes invalid and must be recomputed.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Advanced Application Developer&#39;s Guide to learn</span></p><p class="c0"><span class="c1">more about the PL/SQL function result cache</span></p><p class="c0"><span class="c1">&#9632; Oracle Database PL/SQL Language Reference to learn more about</span></p><p class="c0"><span class="c1">the PL/SQL function result cache</span></p><p class="c0"><span class="c1">See Also: Oracle Database Performance Tuning Guide to learn how to</span></p><p class="c0"><span class="c1">configure the reserved poolOverview of the System Global Area</span></p><p class="c0"><span class="c1">14-22 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Figure 14&ndash;11 Large Pool</span></p><p class="c0"><span class="c1">The large pool is different from reserved space in the shared pool, which uses the same</span></p><p class="c0"><span class="c1">LRU list as other memory allocated from the shared pool. The large pool does not have</span></p><p class="c0"><span class="c1">an LRU list. Pieces of memory are allocated and cannot be freed until they are done</span></p><p class="c0"><span class="c1">being used. As soon as a chunk of memory is freed, other processes can use it.</span></p><p class="c0"><span class="c1">Java Pool</span></p><p class="c0"><span class="c1">The Java pool is an area of memory that stores all session-specific Java code and data</span></p><p class="c0"><span class="c1">within the Java Virtual Machine (JVM). This memory includes Java objects that are</span></p><p class="c0"><span class="c1">migrated to the Java session space at end-of-call.</span></p><p class="c0"><span class="c1">For dedicated server connections, the Java pool includes the shared part of each Java</span></p><p class="c0"><span class="c1">class, including methods and read-only memory such as code vectors, but not the</span></p><p class="c0"><span class="c1">per-session Java state of each session. For shared server, the pool includes the shared</span></p><p class="c0"><span class="c1">part of each class and some UGA used for the state of each session. Each UGA grows</span></p><p class="c0"><span class="c1">and shrinks as necessary, but the total UGA size must fit in the Java pool space.</span></p><p class="c0"><span class="c1">The Java Pool Advisor statistics provide information about library cache memory used</span></p><p class="c0"><span class="c1">for Java and predict how changes in the size of the Java pool can affect the parse rate.</span></p><p class="c0"><span class="c1">The Java Pool Advisor is internally turned on when statistics_level is set to</span></p><p class="c0"><span class="c1">TYPICAL or higher. These statistics reset when the advisor is turned off.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Dispatcher Request and Response Queues&quot; on page 16-12 to learn</span></p><p class="c0"><span class="c1">about allocating session memory for shared server</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Advanced Application Developer&#39;s Guide to learn</span></p><p class="c0"><span class="c1">about Oracle XA</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Performance Tuning Guide for more information</span></p><p class="c0"><span class="c1">about the large pool</span></p><p class="c0"><span class="c1">&#9632; &quot;Parallel Execution&quot; on page 15-15 for information about</span></p><p class="c0"><span class="c1">allocating memory for parallel execution</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Java Developer&#39;s Guide</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Performance Tuning Guide to learn about views</span></p><p class="c0"><span class="c1">containing Java pool advisory statistics</span></p><p class="c0"><span class="c1">Response Queue</span></p><p class="c0"><span class="c1">Large Pool</span></p><p class="c0"><span class="c1">Request Queue UGA</span></p><p class="c0"><span class="c1">I/O Buffer Area</span></p><p class="c0"><span class="c1">Free MemoryOverview of Software Code Areas</span></p><p class="c0"><span class="c1">Memory Architecture 14-23</span></p><p class="c0"><span class="c1">Streams Pool</span></p><p class="c0"><span class="c1">The Streams pool stores buffered queue messages and provides memory for Oracle</span></p><p class="c0"><span class="c1">Streams capture processes and apply processes. The Streams pool is used exclusively</span></p><p class="c0"><span class="c1">by Oracle Streams.</span></p><p class="c0"><span class="c1">Unless you specifically configure it, the size of the Streams pool starts at zero. The pool</span></p><p class="c0"><span class="c1">size grows dynamically as required by Oracle Streams.</span></p><p class="c0"><span class="c1">Fixed SGA</span></p><p class="c0"><span class="c1">The fixed SGA is an internal housekeeping area. For example, the fixed SGA contains:</span></p><p class="c0"><span class="c1">&#9632; General information about the state of the database and the instance, which the</span></p><p class="c0"><span class="c1">background processes need to access</span></p><p class="c0"><span class="c1">&#9632; Information communicated between processes, such as information about locks</span></p><p class="c0"><span class="c1">(see &quot;Overview of Automatic Locks&quot; on page 9-17)</span></p><p class="c0"><span class="c1">The size of the fixed SGA is set by Oracle Database and cannot be altered manually.</span></p><p class="c0"><span class="c1">The fixed SGA size can change from release to release.</span></p><p class="c0"><span class="c1">Overview of Software Code Areas</span></p><p class="c0"><span class="c1">Software code areas are portions of memory that store code that is being run or can be</span></p><p class="c0"><span class="c1">run. Oracle Database code is stored in a software area that is typically more exclusive</span></p><p class="c0"><span class="c1">and protected than the location of user programs.</span></p><p class="c0"><span class="c1">Software areas are usually static in size, changing only when software is updated or</span></p><p class="c0"><span class="c1">reinstalled. The required size of these areas varies by operating system.</span></p><p class="c0"><span class="c1">Software areas are read-only and can be installed shared or nonshared. Some database</span></p><p class="c0"><span class="c1">tools and utilities, such as Oracle Forms and SQL*Plus, can be installed shared, but</span></p><p class="c0"><span class="c1">some cannot. When possible, database code is shared so that all users can access it</span></p><p class="c0"><span class="c1">without having multiple copies in memory, resulting in reduced main memory and</span></p><p class="c0"><span class="c1">overall improvement in performance. Multiple instances of a database can use the</span></p><p class="c0"><span class="c1">same database code area with different databases if running on the same computer.</span></p><p class="c0"><span class="c1">See Also: Oracle Database 2 Day + Data Replication and Integration</span></p><p class="c0"><span class="c1">Guide and Oracle Streams Replication Administrator&#39;s Guide</span></p><p class="c0"><span class="c1">Note: The option of installing software shared is not available for all</span></p><p class="c0"><span class="c1">operating systems, for example, on PCs operating Windows. See your</span></p><p class="c0"><span class="c1">operating system-specific documentation for more information.Overview of Software Code Areas</span></p><p class="c0"><span class="c1">14-24 Oracle Database Concepts15</span></p><p class="c0"><span class="c1">Process Architecture 15-1</span></p><p class="c0"><span class="c1">Process Architecture 5 1</span></p><p class="c0"><span class="c1">This chapter discusses the processes in an Oracle database.</span></p><p class="c0"><span class="c1">This chapter contains the following sections:</span></p><p class="c0"><span class="c1">&#9632; Introduction to Processes</span></p><p class="c0"><span class="c1">&#9632; Overview of Client Processes</span></p><p class="c0"><span class="c1">&#9632; Overview of Server Processes</span></p><p class="c0"><span class="c1">&#9632; Overview of Background Processes</span></p><p class="c0"><span class="c1">Introduction to Processes</span></p><p class="c0"><span class="c1">A process is a mechanism in an operating system that can run a series of steps. The</span></p><p class="c0"><span class="c1">mechanism depends on the operating system. For example, on Linux an Oracle</span></p><p class="c0"><span class="c1">background process is a Linux process. On Windows, an Oracle background process is</span></p><p class="c0"><span class="c1">a thread of execution within a process.</span></p><p class="c0"><span class="c1">Code modules are run by processes. All connected Oracle Database users must run the</span></p><p class="c0"><span class="c1">following modules to access a database instance:</span></p><p class="c0"><span class="c1">&#9632; Application or Oracle Database utility</span></p><p class="c0"><span class="c1">A database user runs a database application, such as a precompiler program or a</span></p><p class="c0"><span class="c1">database tool such as SQL*Plus, that issues SQL statements to a database.</span></p><p class="c0"><span class="c1">&#9632; Oracle database code</span></p><p class="c0"><span class="c1">Each user has Oracle database code executing on his or her behalf that interprets</span></p><p class="c0"><span class="c1">and processes the application&#39;s SQL statements.</span></p><p class="c0"><span class="c1">A process normally runs in its own private memory area. Most processes can</span></p><p class="c0"><span class="c1">periodically write to an associated trace file (see &quot;Trace Files&quot; on page 13-21).</span></p><p class="c0"><span class="c1">Multiple-Process Oracle Database Systems</span></p><p class="c0"><span class="c1">Multiple-process Oracle (also called multiuser Oracle) uses several processes to run</span></p><p class="c0"><span class="c1">different parts of the Oracle Database code and additional processes for the</span></p><p class="c0"><span class="c1">users&mdash;either one process for each connected user or one or more processes shared by</span></p><p class="c0"><span class="c1">multiple users. Most databases are multiuser because a primary advantages of a</span></p><p class="c0"><span class="c1">database is managing data needed by multiple users simultaneously.</span></p><p class="c0"><span class="c1">See Also: &quot;Tools for Database Administrators&quot; on page 18-2 and</span></p><p class="c0"><span class="c1">&quot;Tools for Database Developers&quot; on page 19-1Introduction to Processes</span></p><p class="c0"><span class="c1">15-2 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Each process in a database instance performs a specific job. By dividing the work of</span></p><p class="c0"><span class="c1">the database and applications into several processes, multiple users and applications</span></p><p class="c0"><span class="c1">can connect to an instance simultaneously while the system gives good performance.</span></p><p class="c0"><span class="c1">Types of Processes</span></p><p class="c0"><span class="c1">A database instance contains or interacts with the following types of processes:</span></p><p class="c0"><span class="c1">&#9632; Client processes run the application or Oracle tool code.</span></p><p class="c0"><span class="c1">&#9632; Oracle processes run the Oracle database code. Oracle processes including the</span></p><p class="c0"><span class="c1">following subtypes:</span></p><p class="c0"><span class="c1">&ndash; Background processes start with the database instance and perform</span></p><p class="c0"><span class="c1">maintenance tasks such as performing instance recovery, cleaning up</span></p><p class="c0"><span class="c1">processes, writing redo buffers to disk, and so on.</span></p><p class="c0"><span class="c1">&ndash; Server processes perform work based on a client request.</span></p><p class="c0"><span class="c1">For example, these processes parse SQL queries, place them in the shared</span></p><p class="c0"><span class="c1">pool, create and execute a query plan for each query, and read buffers from</span></p><p class="c0"><span class="c1">the database buffer cache or from disk.</span></p><p class="c0"><span class="c1">&ndash; Slave processes perform additional tasks for a background or server process.</span></p><p class="c0"><span class="c1">The process structure varies depending on the operating system and the choice of</span></p><p class="c0"><span class="c1">Oracle Database options. For example, the code for connected users can be configured</span></p><p class="c0"><span class="c1">for dedicated server or shared server connections. In a shared server architecture, each</span></p><p class="c0"><span class="c1">server process that runs database code can serve multiple client processes.</span></p><p class="c0"><span class="c1">Figure 15&ndash;1 shows a system global area (SGA) and background processes using</span></p><p class="c0"><span class="c1">dedicated server connections. For each user connection, the application is run by a</span></p><p class="c0"><span class="c1">client process that is different from the dedicated server process that runs the database</span></p><p class="c0"><span class="c1">code. Each client process is associated with its own server process, which has its own</span></p><p class="c0"><span class="c1">program global area (PGA).</span></p><p class="c0"><span class="c1">Note: Server processes, and the process memory allocated in these</span></p><p class="c0"><span class="c1">processes, run in the instance. The instance continues to function</span></p><p class="c0"><span class="c1">when server processes terminate.Overview of Client Processes</span></p><p class="c0"><span class="c1">Process Architecture 15-3</span></p><p class="c0"><span class="c1">Figure 15&ndash;1 Oracle Processes and the SGA</span></p><p class="c0"><span class="c1">Overview of Client Processes</span></p><p class="c0"><span class="c1">When a user runs an application such as a Pro*C program or SQL*Plus, the operating</span></p><p class="c0"><span class="c1">system creates a client process (sometimes called a user process) to run the user</span></p><p class="c0"><span class="c1">application. The client application has Oracle Database libraries linked into it that</span></p><p class="c0"><span class="c1">provide the APIs required to communicate with the database.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Dedicated Server Architecture&quot; on page 16-9 and &quot;Shared</span></p><p class="c0"><span class="c1">Server Architecture&quot; on page 16-11</span></p><p class="c0"><span class="c1">&#9632; Your Oracle Database operating system-specific documentation</span></p><p class="c0"><span class="c1">for more details on configuration choices</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Reference to learn about the V$PROCESS view</span></p><p class="c0"><span class="c1">System Global Area (SGA)</span></p><p class="c0"><span class="c1">Large Pool</span></p><p class="c0"><span class="c1">Instance</span></p><p class="c0"><span class="c1">UGA</span></p><p class="c0"><span class="c1">I/O Buffer Area</span></p><p class="c0"><span class="c1">Free Memory</span></p><p class="c0"><span class="c1">Large Pool</span></p><p class="c0"><span class="c1">Response</span></p><p class="c0"><span class="c1">Queue</span></p><p class="c0"><span class="c1">Request</span></p><p class="c0"><span class="c1">Queue</span></p><p class="c0"><span class="c1">Shared Pool</span></p><p class="c0"><span class="c1">Private</span></p><p class="c0"><span class="c1">SQL Area</span></p><p class="c0"><span class="c1">(Shared</span></p><p class="c0"><span class="c1">Server Only)</span></p><p class="c0"><span class="c1">Shared SQL Area</span></p><p class="c0"><span class="c1">Library Cache</span></p><p class="c0"><span class="c1">Data</span></p><p class="c0"><span class="c1">Dictionary</span></p><p class="c0"><span class="c1">Cache</span></p><p class="c0"><span class="c1">Server</span></p><p class="c0"><span class="c1">Result</span></p><p class="c0"><span class="c1">Cache</span></p><p class="c0"><span class="c1">Other Reserved</span></p><p class="c0"><span class="c1">Pool</span></p><p class="c0"><span class="c1">SELECT * FROM</span></p><p class="c0"><span class="c1">employees</span></p><p class="c0"><span class="c1">Background</span></p><p class="c0"><span class="c1">Processes</span></p><p class="c0"><span class="c1">Client</span></p><p class="c0"><span class="c1">Process</span></p><p class="c0"><span class="c1">PMON</span></p><p class="c0"><span class="c1">SMON</span></p><p class="c0"><span class="c1">RECO</span></p><p class="c0"><span class="c1">MMON</span></p><p class="c0"><span class="c1">MMNL</span></p><p class="c0"><span class="c1">Others</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">Buffer Cache Redo</span></p><p class="c0"><span class="c1">Log</span></p><p class="c0"><span class="c1">Buffer</span></p><p class="c0"><span class="c1">DBWn CKPT LGWR ARCn RVWR</span></p><p class="c0"><span class="c1">Java</span></p><p class="c0"><span class="c1">Pool</span></p><p class="c0"><span class="c1">Streams</span></p><p class="c0"><span class="c1">Pool</span></p><p class="c0"><span class="c1">Fixed</span></p><p class="c0"><span class="c1">SGA</span></p><p class="c0"><span class="c1">Server</span></p><p class="c0"><span class="c1">Process</span></p><p class="c0"><span class="c1">PGA</span></p><p class="c0"><span class="c1">Session Memory Private SQL Area</span></p><p class="c0"><span class="c1">SQL Work AreasOverview of Client Processes</span></p><p class="c0"><span class="c1">15-4 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Client and Server Processes</span></p><p class="c0"><span class="c1">Client processes differ in important ways from the Oracle processes interacting</span></p><p class="c0"><span class="c1">directly with the instance. The Oracle processes servicing the client process can read</span></p><p class="c0"><span class="c1">from and write to the SGA, whereas the client process cannot. A client process can run</span></p><p class="c0"><span class="c1">on a host other than the database host, whereas Oracle processes cannot.</span></p><p class="c0"><span class="c1">For example, assume that a user on a client host starts SQL*Plus and connects over the</span></p><p class="c0"><span class="c1">network to database sample on a different host (the database instance is not started):</span></p><p class="c0"><span class="c1">SQL&gt; CONNECT SYS@inst1 AS SYSDBA</span></p><p class="c0"><span class="c1">Enter password: *********</span></p><p class="c0"><span class="c1">Connected to an idle instance.</span></p><p class="c0"><span class="c1">On the client host, a search of the processes for either sqlplus or sample shows only</span></p><p class="c0"><span class="c1">the sqlplus client process:</span></p><p class="c0"><span class="c1">% ps -ef | grep -e sample -e sqlplus | grep -v grep</span></p><p class="c0"><span class="c1">clientuser 29437 29436 0 15:40 pts/1 00:00:00 sqlplus as sysdba</span></p><p class="c0"><span class="c1">On the database host, a search of the processes for either sqlplus or sample shows a</span></p><p class="c0"><span class="c1">server process with a nonlocal connection, but no client process:</span></p><p class="c0"><span class="c1">% ps -ef | grep -e sample -e sqlplus | grep -v grep</span></p><p class="c0"><span class="c1">serveruser 29441 1 0 15:40 ? 00:00:00 oraclesample (LOCAL=NO)</span></p><p class="c0"><span class="c1">Connections and Sessions</span></p><p class="c0"><span class="c1">A connection is a physical communication pathway between a client process and a</span></p><p class="c0"><span class="c1">database instance. A communication pathway is established using available</span></p><p class="c0"><span class="c1">interprocess communication mechanisms or network software. Typically, a connection</span></p><p class="c0"><span class="c1">occurs between a client process and a server process or dispatcher, but it can also occur</span></p><p class="c0"><span class="c1">between a client process and Oracle Connection Manager (CMAN).</span></p><p class="c0"><span class="c1">A session is a logical entity in the database instance memory that represents the state</span></p><p class="c0"><span class="c1">of a current user login to a database. For example, when a user is authenticated by the</span></p><p class="c0"><span class="c1">database with a password, a session is established for this user. A session lasts from</span></p><p class="c0"><span class="c1">the time the user is authenticated by the database until the time the user disconnects or</span></p><p class="c0"><span class="c1">exits the database application.</span></p><p class="c0"><span class="c1">A single connection can have 0, 1, or more sessions established on it. The sessions are</span></p><p class="c0"><span class="c1">independent: a commit in one session does not affect transactions in other sessions.</span></p><p class="c0"><span class="c1">Multiple sessions can exist concurrently for a single database user. As shown in</span></p><p class="c0"><span class="c1">Figure 15&ndash;2, user hr can have multiple connections to a database. In dedicated server</span></p><p class="c0"><span class="c1">connections, the database creates a server process on behalf of each connection. Only</span></p><p class="c0"><span class="c1">the client process that causes the dedicated server to be created uses it. In a shared</span></p><p class="c0"><span class="c1">server connection, many client processes access a single shared server process.</span></p><p class="c0"><span class="c1">Note: If Oracle Net connection pooling is configured, then it is</span></p><p class="c0"><span class="c1">possible for a connection to drop but leave the sessions intact.Overview of Client Processes</span></p><p class="c0"><span class="c1">Process Architecture 15-5</span></p><p class="c0"><span class="c1">Figure 15&ndash;2 One Session for Each Connection</span></p><p class="c0"><span class="c1">Figure 15&ndash;3 illustrates a case in which user hr has a single connection to a database,</span></p><p class="c0"><span class="c1">but this connection has two sessions.</span></p><p class="c0"><span class="c1">Figure 15&ndash;3 Two Sessions in One Connection</span></p><p class="c0"><span class="c1">Generating an autotrace report of SQL statement execution statistics re-creates the</span></p><p class="c0"><span class="c1">scenario in Figure 15&ndash;3. Example 15&ndash;2 connects SQL*Plus to the database as user</span></p><p class="c0"><span class="c1">SYSTEM and enables tracing, thus creating a new session (sample output included).</span></p><p class="c0"><span class="c1">Example 15&ndash;1 One Connection with Two Sessions</span></p><p class="c0"><span class="c1">SQL&gt; SELECT SID, SERIAL#, PADDR FROM V$SESSION WHERE USERNAME = USER;</span></p><p class="c0"><span class="c1">SID SERIAL# PADDR</span></p><p class="c0"><span class="c1">--- ------- --------</span></p><p class="c0"><span class="c1">90 91 3BE2E41C</span></p><p class="c0"><span class="c1">SQL&gt; SET AUTOTRACE ON STATISTICS;</span></p><p class="c0"><span class="c1">SQL&gt; SELECT SID, SERIAL#, PADDR FROM V$SESSION WHERE USERNAME = USER;</span></p><p class="c0"><span class="c1">SID SERIAL# PADDR</span></p><p class="c0"><span class="c1">--- ------- --------</span></p><p class="c0"><span class="c1">88 93 3BE2E41C</span></p><p class="c0"><span class="c1">90 91 3BE2E41C</span></p><p class="c0"><span class="c1">...</span></p><p class="c0"><span class="c1">SQL&gt; DISCONNECT</span></p><p class="c0"><span class="c1">Connection 1</span></p><p class="c0"><span class="c1">Connection 2</span></p><p class="c0"><span class="c1">User hr</span></p><p class="c0"><span class="c1">User hr</span></p><p class="c0"><span class="c1">Session</span></p><p class="c0"><span class="c1">Session</span></p><p class="c0"><span class="c1">Server</span></p><p class="c0"><span class="c1">Process</span></p><p class="c0"><span class="c1">Server</span></p><p class="c0"><span class="c1">Process</span></p><p class="c0"><span class="c1">Client</span></p><p class="c0"><span class="c1">Process</span></p><p class="c0"><span class="c1">Client</span></p><p class="c0"><span class="c1">Process</span></p><p class="c0"><span class="c1">Session</span></p><p class="c0"><span class="c1">Session</span></p><p class="c0"><span class="c1">Server</span></p><p class="c0"><span class="c1">Process</span></p><p class="c0"><span class="c1">Client</span></p><p class="c0"><span class="c1">Process</span></p><p class="c0"><span class="c1">Connection</span></p><p class="c0"><span class="c1">User hrOverview of Server Processes</span></p><p class="c0"><span class="c1">15-6 Oracle Database Concepts</span></p><p class="c0"><span class="c1">The DISCONNECT command in Example 15&ndash;1 actually ends the sessions, not the</span></p><p class="c0"><span class="c1">connection. Opening a new terminal and connecting to the instance as a different user,</span></p><p class="c0"><span class="c1">the query in Example 15&ndash;2 shows that the connection from Example 15&ndash;1 is still active.</span></p><p class="c0"><span class="c1">Example 15&ndash;2 Connection with No Sessions</span></p><p class="c0"><span class="c1">SQL&gt; CONNECT dba1@inst1</span></p><p class="c0"><span class="c1">Password: ********</span></p><p class="c0"><span class="c1">Connected.</span></p><p class="c0"><span class="c1">SQL&gt; SELECT PROGRAM FROM V$PROCESS WHERE ADDR = HEXTORAW(&#39;3BE2E41C&#39;);</span></p><p class="c0"><span class="c1">PROGRAM</span></p><p class="c0"><span class="c1">------------------------------------------------</span></p><p class="c0"><span class="c1">oracle@stbcs09-1 (TNS V1-V3)</span></p><p class="c0"><span class="c1">Overview of Server Processes</span></p><p class="c0"><span class="c1">Oracle Database creates server processes to handle the requests of client processes</span></p><p class="c0"><span class="c1">connected to the instance. A client process always communicates with a database</span></p><p class="c0"><span class="c1">through a separate server process.</span></p><p class="c0"><span class="c1">Server processes created on behalf of a database application can perform one or more</span></p><p class="c0"><span class="c1">of the following tasks:</span></p><p class="c0"><span class="c1">&#9632; Parse and run SQL statements issued through the application, including creating</span></p><p class="c0"><span class="c1">and executing the query plan (see &quot;Stages of SQL Processing&quot; on page 7-15)</span></p><p class="c0"><span class="c1">&#9632; Execute PL/SQL code</span></p><p class="c0"><span class="c1">&#9632; Read data blocks from data files into the database buffer cache (the DBWn</span></p><p class="c0"><span class="c1">background process has the task of writing modified blocks back to disk)</span></p><p class="c0"><span class="c1">&#9632; Return results in such a way that the application can process the information</span></p><p class="c0"><span class="c1">Dedicated Server Processes</span></p><p class="c0"><span class="c1">In dedicated server connections, the client connection is associated with one and only</span></p><p class="c0"><span class="c1">one server process (see &quot;Dedicated Server Architecture&quot; on page 16-9). On Linux, 20</span></p><p class="c0"><span class="c1">client processes connected to a database instance are serviced by 20 server processes.</span></p><p class="c0"><span class="c1">Each client process communicates directly with its server process. This server process</span></p><p class="c0"><span class="c1">is dedicated to its client process for the duration of the session. The server process</span></p><p class="c0"><span class="c1">stores process-specific information and the UGA in its PGA (see &quot;PGA Usage in</span></p><p class="c0"><span class="c1">Dedicated and Shared Server Modes&quot; on page 14-7).</span></p><p class="c0"><span class="c1">Shared Server Processes</span></p><p class="c0"><span class="c1">In shared server connections, client applications connect over a network to a</span></p><p class="c0"><span class="c1">dispatcher process, not a server process (see &quot;Shared Server Architecture&quot; on</span></p><p class="c0"><span class="c1">page 16-11). For example, 20 client processes can connect to a single dispatcher</span></p><p class="c0"><span class="c1">process.</span></p><p class="c0"><span class="c1">The dispatcher process receives requests from connected clients and puts them into a</span></p><p class="c0"><span class="c1">request queue in the large pool (see &quot;Large Pool&quot; on page 14-21). The first available</span></p><p class="c0"><span class="c1">shared server process takes the request from the queue and processes it. Afterward,</span></p><p class="c0"><span class="c1">the shared server place the result into the dispatcher response queue. The dispatcher</span></p><p class="c0"><span class="c1">process monitors this queue and transmits the result to the client.</span></p><p class="c0"><span class="c1">See Also: &quot;Shared Server Architecture&quot; on page 16-11Overview of Background Processes</span></p><p class="c0"><span class="c1">Process Architecture 15-7</span></p><p class="c0"><span class="c1">Like a dedicated server process, a shared server process has its own PGA. However,</span></p><p class="c0"><span class="c1">the UGA for a session is in the SGA so that any shared server can access session data.</span></p><p class="c0"><span class="c1">Overview of Background Processes</span></p><p class="c0"><span class="c1">A multiprocess Oracle database uses some additional processes called background</span></p><p class="c0"><span class="c1">processes. The background processes perform maintenance tasks required to operate</span></p><p class="c0"><span class="c1">the database and to maximize performance for multiple users.</span></p><p class="c0"><span class="c1">Each background process has a separate task, but works with the other processes. For</span></p><p class="c0"><span class="c1">example, the LGWR process writes data from the redo log buffer to the online redo</span></p><p class="c0"><span class="c1">log. When a filled log file is ready to be archived, LGWR signals another process to</span></p><p class="c0"><span class="c1">archive the file.</span></p><p class="c0"><span class="c1">Oracle Database creates background processes automatically when a database instance</span></p><p class="c0"><span class="c1">starts. An instance can have many background processes, not all of which always exist</span></p><p class="c0"><span class="c1">in every database configuration. The following query lists the background processes</span></p><p class="c0"><span class="c1">running on your database:</span></p><p class="c0"><span class="c1">SELECT PNAME</span></p><p class="c0"><span class="c1">FROM V$PROCESS</span></p><p class="c0"><span class="c1">WHERE PNAME IS NOT NULL</span></p><p class="c0"><span class="c1">ORDER BY PNAME;</span></p><p class="c0"><span class="c1">This section includes the following topics:</span></p><p class="c0"><span class="c1">&#9632; Mandatory Background Processes</span></p><p class="c0"><span class="c1">&#9632; Optional Background Processes</span></p><p class="c0"><span class="c1">&#9632; Slave Processes</span></p><p class="c0"><span class="c1">Mandatory Background Processes</span></p><p class="c0"><span class="c1">The mandatory background processes are present in all typical database</span></p><p class="c0"><span class="c1">configurations. These processes run by default in a database instance started with a</span></p><p class="c0"><span class="c1">minimally configured initialization parameter file (see Example 13&ndash;1 on page 13-20).</span></p><p class="c0"><span class="c1">This section describes the following mandatory background processes:</span></p><p class="c0"><span class="c1">&#9632; Process Monitor Process (PMON)</span></p><p class="c0"><span class="c1">&#9632; System Monitor Process (SMON)</span></p><p class="c0"><span class="c1">&#9632; Database Writer Process (DBWn)</span></p><p class="c0"><span class="c1">&#9632; Log Writer Process (LGWR)</span></p><p class="c0"><span class="c1">&#9632; Checkpoint Process (CKPT)</span></p><p class="c0"><span class="c1">&#9632; Manageability Monitor Processes (MMON and MMNL)</span></p><p class="c0"><span class="c1">&#9632; Recoverer Process (RECO)</span></p><p class="c0"><span class="c1">See Also: Oracle Database Reference for descriptions of all the</span></p><p class="c0"><span class="c1">background processesOverview of Background Processes</span></p><p class="c0"><span class="c1">15-8 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Process Monitor Process (PMON)</span></p><p class="c0"><span class="c1">The process monitor (PMON) monitors the other background processes and performs</span></p><p class="c0"><span class="c1">process recovery when a server or dispatcher process terminates abnormally. PMON is</span></p><p class="c0"><span class="c1">responsible for cleaning up the database buffer cache and freeing resources that the</span></p><p class="c0"><span class="c1">client process was using. For example, PMON resets the status of the active</span></p><p class="c0"><span class="c1">transaction table, releases locks that are no longer required, and removes the process</span></p><p class="c0"><span class="c1">ID from the list of active processes.</span></p><p class="c0"><span class="c1">PMON also registers information about the instance and dispatcher processes with the</span></p><p class="c0"><span class="c1">Oracle Net listener (see &quot;The Oracle Net Listener&quot; on page 16-6). When an instance</span></p><p class="c0"><span class="c1">starts, PMON polls the listener to determine whether it is running. If the listener is</span></p><p class="c0"><span class="c1">running, then PMON passes it relevant parameters. If it is not running, then PMON</span></p><p class="c0"><span class="c1">periodically attempts to contact it.</span></p><p class="c0"><span class="c1">System Monitor Process (SMON)</span></p><p class="c0"><span class="c1">The system monitor process (SMON) is in charge of a variety of system-level cleanup</span></p><p class="c0"><span class="c1">duties. The duties assigned to SMON include:</span></p><p class="c0"><span class="c1">&#9632; Performing instance recovery, if necessary, at instance startup. In an Oracle RAC</span></p><p class="c0"><span class="c1">database, the SMON process of one database instance can perform instance</span></p><p class="c0"><span class="c1">recovery for a failed instance.</span></p><p class="c0"><span class="c1">&#9632; Recovering terminated transactions that were skipped during instance recovery</span></p><p class="c0"><span class="c1">because of file-read or tablespace offline errors. SMON recovers the transactions</span></p><p class="c0"><span class="c1">when the tablespace or file is brought back online.</span></p><p class="c0"><span class="c1">&#9632; Cleaning up unused temporary segments. For example, Oracle Database allocates</span></p><p class="c0"><span class="c1">extents when creating an index. If the operation fails, then SMON cleans up the</span></p><p class="c0"><span class="c1">temporary space.</span></p><p class="c0"><span class="c1">&#9632; Coalescing contiguous free extents within dictionary-managed tablespaces.</span></p><p class="c0"><span class="c1">SMON checks regularly to see whether it is needed. Other processes can call SMON if</span></p><p class="c0"><span class="c1">they detect a need for it.</span></p><p class="c0"><span class="c1">Database Writer Process (DBWn)</span></p><p class="c0"><span class="c1">The database writer process (DBWn) writes the contents of database buffers to data</span></p><p class="c0"><span class="c1">files. DBWn processes write modified buffers in the database buffer cache to disk (see</span></p><p class="c0"><span class="c1">&quot;Database Buffer Cache&quot; on page 14-9).</span></p><p class="c0"><span class="c1">Although one database writer process (DBW0) is adequate for most systems, you can</span></p><p class="c0"><span class="c1">configure additional processes&mdash;DBW1 through DBW9 and DBWa through DBWj&mdash;to</span></p><p class="c0"><span class="c1">improve write performance if your system modifies data heavily. These additional</span></p><p class="c0"><span class="c1">DBWn processes are not useful on uniprocessor systems.</span></p><p class="c0"><span class="c1">The DBWn process writes dirty buffers to disk under the following conditions:</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Reference for descriptions of other mandatory</span></p><p class="c0"><span class="c1">processes, including MMAN, DIAG, VKTM, DBRM, and PSP0</span></p><p class="c0"><span class="c1">&#9632; Oracle Real Application Clusters Administration and Deployment</span></p><p class="c0"><span class="c1">Guide and Oracle Clusterware Administration and Deployment Guide</span></p><p class="c0"><span class="c1">for more information about background processes specific to</span></p><p class="c0"><span class="c1">Oracle RAC and Oracle ClusterwareOverview of Background Processes</span></p><p class="c0"><span class="c1">Process Architecture 15-9</span></p><p class="c0"><span class="c1">&#9632; When a server process cannot find a clean reusable buffer after scanning a</span></p><p class="c0"><span class="c1">threshold number of buffers, it signals DBWn to write. DBWn writes dirty buffers</span></p><p class="c0"><span class="c1">to disk asynchronously if possible while performing other processing.</span></p><p class="c0"><span class="c1">&#9632; DBWn periodically writes buffers to advance the checkpoint, which is the position</span></p><p class="c0"><span class="c1">in the redo thread from which instance recovery begins (see &quot;Overview of</span></p><p class="c0"><span class="c1">Checkpoints&quot; on page 13-11). The log position of the checkpoint is determined by</span></p><p class="c0"><span class="c1">the oldest dirty buffer in the buffer cache.</span></p><p class="c0"><span class="c1">In many cases the blocks that DBWn writes are scattered throughout the disk. Thus,</span></p><p class="c0"><span class="c1">the writes tend to be slower than the sequential writes performed by LGWR. DBWn</span></p><p class="c0"><span class="c1">performs multiblock writes when possible to improve efficiency. The number of blocks</span></p><p class="c0"><span class="c1">written in a multiblock write varies by operating system.</span></p><p class="c0"><span class="c1">Log Writer Process (LGWR)</span></p><p class="c0"><span class="c1">The log writer process (LGWR) manages the redo log buffer. LGWR writes one</span></p><p class="c0"><span class="c1">contiguous portion of the buffer to the online redo log. By separating the tasks of</span></p><p class="c0"><span class="c1">modifying database buffers, performing scattered writes of dirty buffers to disk, and</span></p><p class="c0"><span class="c1">performing fast sequential writes of redo to disk, the database improves performance.</span></p><p class="c0"><span class="c1">In the following circumstances, LGWR writes all redo entries that have been copied</span></p><p class="c0"><span class="c1">into the buffer since the last time it wrote:</span></p><p class="c0"><span class="c1">&#9632; A user commits a transaction (see &quot;Committing Transactions&quot; on page 10-10).</span></p><p class="c0"><span class="c1">&#9632; An online redo log switch occurs.</span></p><p class="c0"><span class="c1">&#9632; Three seconds have passed since LGWR last wrote.</span></p><p class="c0"><span class="c1">&#9632; The redo log buffer is one-third full or contains 1 MB of buffered data.</span></p><p class="c0"><span class="c1">&#9632; DBWn must write modified buffers to disk.</span></p><p class="c0"><span class="c1">Before DBWn can write a dirty buffer, redo records associated with changes to the</span></p><p class="c0"><span class="c1">buffer must be written to disk (the write-ahead protocol). If DBWn finds that</span></p><p class="c0"><span class="c1">some redo records have not been written, it signals LGWR to write the records to</span></p><p class="c0"><span class="c1">disk and waits for LGWR to complete before writing the data buffers to disk.</span></p><p class="c0"><span class="c1">LGWR and Commits Oracle Database uses a fast commit mechanism to improve</span></p><p class="c0"><span class="c1">performance for committed transactions. When a user issues a COMMIT statement, the</span></p><p class="c0"><span class="c1">transaction is assigned a system change number (SCN). LGWR puts a commit record</span></p><p class="c0"><span class="c1">in the redo log buffer and writes it to disk immediately, along with the commit SCN</span></p><p class="c0"><span class="c1">and transaction&#39;s redo entries.</span></p><p class="c0"><span class="c1">The redo log buffer is circular. When LGWR writes redo entries from the redo log</span></p><p class="c0"><span class="c1">buffer to an online redo log file, server processes can copy new entries over the entries</span></p><p class="c0"><span class="c1">in the redo log buffer that have been written to disk. LGWR normally writes fast</span></p><p class="c0"><span class="c1">enough to ensure that space is always available in the buffer for new entries, even</span></p><p class="c0"><span class="c1">when access to the online redo log is heavy.</span></p><p class="c0"><span class="c1">The atomic write of the redo entry containing the transaction&#39;s commit record is the</span></p><p class="c0"><span class="c1">single event that determines the transaction has committed. Oracle Database returns a</span></p><p class="c0"><span class="c1">success code to the committing transaction although the data buffers have not yet been</span></p><p class="c0"><span class="c1">written to disk. The corresponding changes to data blocks are deferred until it is</span></p><p class="c0"><span class="c1">efficient for DBWn to write them to the data files.</span></p><p class="c0"><span class="c1">See Also: Oracle Database Performance Tuning Guide for advice on</span></p><p class="c0"><span class="c1">configuring, monitoring, and tuning DBWnOverview of Background Processes</span></p><p class="c0"><span class="c1">15-10 Oracle Database Concepts</span></p><p class="c0"><span class="c1">When activity is high, LGWR can use group commits. For example, a user commits,</span></p><p class="c0"><span class="c1">causing LGWR to write the transaction&#39;s redo entries to disk. During this write other</span></p><p class="c0"><span class="c1">users commit. LGWR cannot write to disk to commit these transactions until its</span></p><p class="c0"><span class="c1">previous write completes. Upon completion, LGWR can write the list of redo entries of</span></p><p class="c0"><span class="c1">waiting transactions (not yet committed) in one operation. In this way, the database</span></p><p class="c0"><span class="c1">minimizes disk I/O and maximizes performance. If commits requests continue at a</span></p><p class="c0"><span class="c1">high rate, then every write by LGWR can contain multiple commit records.</span></p><p class="c0"><span class="c1">LGWR and Inaccessible Files LGWR writes synchronously to the active mirrored group</span></p><p class="c0"><span class="c1">of online redo log files. If a log file is inaccessible, then LGWR continues writing to</span></p><p class="c0"><span class="c1">other files in the group and writes an error to the LGWR trace file and the alert log. If</span></p><p class="c0"><span class="c1">all files in a group are damaged, or if the group is unavailable because it has not been</span></p><p class="c0"><span class="c1">archived, then LGWR cannot continue to function.</span></p><p class="c0"><span class="c1">Checkpoint Process (CKPT)</span></p><p class="c0"><span class="c1">The checkpoint process (CKPT) updates the control file and data file headers with</span></p><p class="c0"><span class="c1">checkpoint information and signals DBWn to write blocks to disk. Checkpoint</span></p><p class="c0"><span class="c1">information includes the checkpoint position, SCN, location in online redo log to begin</span></p><p class="c0"><span class="c1">recovery, and so on. As shown in Figure 15&ndash;4, CKPT does not write data blocks to data</span></p><p class="c0"><span class="c1">files or redo blocks to online redo log files.</span></p><p class="c0"><span class="c1">Note: LGWR can write redo log entries to disk before a transaction</span></p><p class="c0"><span class="c1">commits. The changes that are protected by the redo entries become</span></p><p class="c0"><span class="c1">permanent only if the transaction later commits.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;How Oracle Database Writes to the Online Redo Log&quot; on</span></p><p class="c0"><span class="c1">page 11-12 and &quot;Redo Log Buffer&quot; on page 14-14</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Performance Tuning Guide for information about</span></p><p class="c0"><span class="c1">how to monitor and tune the performance of LGWROverview of Background Processes</span></p><p class="c0"><span class="c1">Process Architecture 15-11</span></p><p class="c0"><span class="c1">Figure 15&ndash;4 Checkpoint Process</span></p><p class="c0"><span class="c1">Manageability Monitor Processes (MMON and MMNL)</span></p><p class="c0"><span class="c1">The manageability monitor process (MMON) performs many tasks related to the</span></p><p class="c0"><span class="c1">Automatic Workload Repository (AWR). For example, MMON writes when a metric</span></p><p class="c0"><span class="c1">violates its threshold value, taking snapshots, and capturing statistics value for</span></p><p class="c0"><span class="c1">recently modified SQL objects.</span></p><p class="c0"><span class="c1">The manageability monitor lite process (MMNL) writes statistics from the Active</span></p><p class="c0"><span class="c1">Session History (ASH) buffer in the SGA to disk. MMNL writes to disk when the ASH</span></p><p class="c0"><span class="c1">buffer is full.</span></p><p class="c0"><span class="c1">Recoverer Process (RECO)</span></p><p class="c0"><span class="c1">In a distributed database, the recoverer process (RECO) automatically resolves</span></p><p class="c0"><span class="c1">failures in distributed transactions. The RECO process of a node automatically</span></p><p class="c0"><span class="c1">connects to other databases involved in an in-doubt distributed transaction. When</span></p><p class="c0"><span class="c1">RECO reestablishes a connection between the databases, it automatically resolves all</span></p><p class="c0"><span class="c1">in-doubt transactions, removing from each database&#39;s pending transaction table any</span></p><p class="c0"><span class="c1">rows that correspond to the resolved transactions.</span></p><p class="c0"><span class="c1">Optional Background Processes</span></p><p class="c0"><span class="c1">An optional background process is any background process not defined as</span></p><p class="c0"><span class="c1">mandatory. Most optional background processes are specific to tasks or features. For</span></p><p class="c0"><span class="c1">example, background processes that support Oracle Streams Advanced Queuing (AQ)</span></p><p class="c0"><span class="c1">or Oracle Automatic Storage Management (Oracle ASM) are only available when</span></p><p class="c0"><span class="c1">See Also: &quot;Overview of Checkpoints&quot; on page 13-11</span></p><p class="c0"><span class="c1">See Also: &quot;Automatic Workload Repository (AWR)&quot; on page 18-21</span></p><p class="c0"><span class="c1">and &quot;Active Session History (ASH)&quot; on page 18-23</span></p><p class="c0"><span class="c1">See Also: Oracle Database Administrator&#39;s Guide for more information</span></p><p class="c0"><span class="c1">about transaction recovery in distributed systems</span></p><p class="c0"><span class="c1">Data File</span></p><p class="c0"><span class="c1">Body</span></p><p class="c0"><span class="c1">10101</span></p><p class="c0"><span class="c1">10101</span></p><p class="c0"><span class="c1">10101 10101</span></p><p class="c0"><span class="c1">Control</span></p><p class="c0"><span class="c1">Files</span></p><p class="c0"><span class="c1">1010110101</span></p><p class="c0"><span class="c1">Data File</span></p><p class="c0"><span class="c1">Header</span></p><p class="c0"><span class="c1">CKPT DBWn</span></p><p class="c0"><span class="c1">System Global Area</span></p><p class="c0"><span class="c1">(SGA)</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">Buffer CacheOverview of Background Processes</span></p><p class="c0"><span class="c1">15-12 Oracle Database Concepts</span></p><p class="c0"><span class="c1">these features are enabled.</span></p><p class="c0"><span class="c1">This section describes some common optional processes:</span></p><p class="c0"><span class="c1">&#9632; Archiver Processes (ARCn)</span></p><p class="c0"><span class="c1">&#9632; Job Queue Processes (CJQ0 and Jnnn)</span></p><p class="c0"><span class="c1">&#9632; Flashback Data Archiver Process (FBDA)</span></p><p class="c0"><span class="c1">&#9632; Space Management Coordinator Process (SMCO)</span></p><p class="c0"><span class="c1">Archiver Processes (ARCn)</span></p><p class="c0"><span class="c1">The archiver processes (ARCn) copy online redo log files to offline storage after a redo</span></p><p class="c0"><span class="c1">log switch occurs. These processes can also collect transaction redo data and transmit</span></p><p class="c0"><span class="c1">it to standby database destinations. ARCn processes exist only when the database is in</span></p><p class="c0"><span class="c1">ARCHIVELOG mode and automatic archiving is enabled.</span></p><p class="c0"><span class="c1">Job Queue Processes (CJQ0 and Jnnn)</span></p><p class="c0"><span class="c1">Oracle Database uses job queue processes to run user jobs, often in batch mode. A job</span></p><p class="c0"><span class="c1">is a user-defined task scheduled to run one or more times. For example, you can use a</span></p><p class="c0"><span class="c1">job queue to schedule a long-running update in the background. Given a start date</span></p><p class="c0"><span class="c1">and a time interval, the job queue processes attempt to run the job at the next</span></p><p class="c0"><span class="c1">occurrence of the interval.</span></p><p class="c0"><span class="c1">Oracle Database manages job queue processes dynamically, thereby enabling job</span></p><p class="c0"><span class="c1">queue clients to use more job queue processes when required. The database releases</span></p><p class="c0"><span class="c1">resources used by the new processes when they are idle.</span></p><p class="c0"><span class="c1">Dynamic job queue processes can run a large number of jobs concurrently at a given</span></p><p class="c0"><span class="c1">interval. The sequence of events is as follows:</span></p><p class="c0"><span class="c1">1. The job coordinator process (CJQ0) is automatically started and stopped as</span></p><p class="c0"><span class="c1">needed by Oracle Scheduler (see &quot;Oracle Scheduler&quot; on page 18-19). The</span></p><p class="c0"><span class="c1">coordinator process periodically selects jobs that need to be run from the system</span></p><p class="c0"><span class="c1">JOB$ table. New jobs selected are ordered by time.</span></p><p class="c0"><span class="c1">2. The coordinator process dynamically spawns job queue slave processes (Jnnn) to</span></p><p class="c0"><span class="c1">run the jobs.</span></p><p class="c0"><span class="c1">3. The job queue process runs one of the jobs that was selected by the CJQ0 process</span></p><p class="c0"><span class="c1">for execution. Each job queue process runs one job at a time to completion.</span></p><p class="c0"><span class="c1">4. After the process finishes execution of a single job, it polls for more jobs. If no jobs</span></p><p class="c0"><span class="c1">are scheduled for execution, then it enters a sleep state, from which it wakes up at</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Oracle Streams Advanced Queuing (AQ)&quot; on page 17-24</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Reference for descriptions of background processes</span></p><p class="c0"><span class="c1">specific to AQ and ASM</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Archived Redo Log Files&quot; on page 11-15</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn how to adjust the</span></p><p class="c0"><span class="c1">number of archiver processes</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Performance Tuning Guide to learn how to tune</span></p><p class="c0"><span class="c1">archiver performanceOverview of Background Processes</span></p><p class="c0"><span class="c1">Process Architecture 15-13</span></p><p class="c0"><span class="c1">periodic intervals and polls for more jobs. If the process does not find any new</span></p><p class="c0"><span class="c1">jobs, then it terminates after a preset interval.</span></p><p class="c0"><span class="c1">The initialization parameter JOB_QUEUE_PROCESSES represents the maximum number</span></p><p class="c0"><span class="c1">of job queue processes that can concurrently run on an instance. However, clients</span></p><p class="c0"><span class="c1">should not assume that all job queue processes are available for job execution.</span></p><p class="c0"><span class="c1">Flashback Data Archiver Process (FBDA)</span></p><p class="c0"><span class="c1">The flashback data archiver process (FBDA) archives historical rows of tracked tables</span></p><p class="c0"><span class="c1">into Flashback Data Archives. When a transaction containing DML on a tracked table</span></p><p class="c0"><span class="c1">commits, this process stores the pre-image of the rows into the Flashback Data</span></p><p class="c0"><span class="c1">Archive. It also keeps metadata on the current rows.</span></p><p class="c0"><span class="c1">FBDA automatically manages the flashback data archive for space, organization, and</span></p><p class="c0"><span class="c1">retention. Additionally, the process keeps track of how far the archiving of tracked</span></p><p class="c0"><span class="c1">transactions has occurred.</span></p><p class="c0"><span class="c1">Space Management Coordinator Process (SMCO)</span></p><p class="c0"><span class="c1">The SMCO process coordinates the execution of various space management related</span></p><p class="c0"><span class="c1">tasks, such as proactive space allocation and space reclamation. SMCO dynamically</span></p><p class="c0"><span class="c1">spawns slave processes (Wnnn) to implement the task.</span></p><p class="c0"><span class="c1">Slave Processes</span></p><p class="c0"><span class="c1">Slave processes are background processes that perform work on behalf of other</span></p><p class="c0"><span class="c1">processes. This section describes some slave processes used by Oracle Database.</span></p><p class="c0"><span class="c1">I/O Slave Processes</span></p><p class="c0"><span class="c1">I/O slave processes (Innn) simulate asynchronous I/O for systems and devices that</span></p><p class="c0"><span class="c1">do not support it. In asynchronous I/O, there is no timing requirement for</span></p><p class="c0"><span class="c1">transmission, enabling other processes to start before the transmission has finished.</span></p><p class="c0"><span class="c1">For example, assume that an application writes 1000 blocks to a disk on an operating</span></p><p class="c0"><span class="c1">system that does not support asynchronous I/O. Each write occurs sequentially and</span></p><p class="c0"><span class="c1">waits for a confirmation that the write was successful. With asynchronous disk, the</span></p><p class="c0"><span class="c1">application can write the blocks in bulk and perform other work while waiting for a</span></p><p class="c0"><span class="c1">response from the operating system that all blocks were written.</span></p><p class="c0"><span class="c1">Note: The coordinator process is not started if the initialization</span></p><p class="c0"><span class="c1">parameter JOB_QUEUE_PROCESSES is set to 0.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn about Oracle</span></p><p class="c0"><span class="c1">Scheduler jobs</span></p><p class="c0"><span class="c1">&#9632; Oracle Streams Advanced Queuing User&#39;s Guide to learn about AQ</span></p><p class="c0"><span class="c1">background processes</span></p><p class="c0"><span class="c1">See Also: Oracle Database Advanced Application Developer&#39;s Guide to</span></p><p class="c0"><span class="c1">learn about Flashback Data Archive</span></p><p class="c0"><span class="c1">See Also: Oracle Database Reference for descriptions of Oracle</span></p><p class="c0"><span class="c1">Database slave processesOverview of Background Processes</span></p><p class="c0"><span class="c1">15-14 Oracle Database Concepts</span></p><p class="c0"><span class="c1">To simulate asynchronous I/O, one process oversees several slave processes. The</span></p><p class="c0"><span class="c1">invoker process assigns work to each of the slave processes, who wait for each write</span></p><p class="c0"><span class="c1">to complete and report back to the invoker when done. In true asynchronous I/O the</span></p><p class="c0"><span class="c1">operating system waits for the I/O to complete and reports back to the process, while</span></p><p class="c0"><span class="c1">in simulated asynchronous I/O the slaves wait and report back to the invoker.</span></p><p class="c0"><span class="c1">The database supports different types of I/O slaves, including the following:</span></p><p class="c0"><span class="c1">&#9632; I/O slaves for Recovery Manager (RMAN)</span></p><p class="c0"><span class="c1">When using RMAN to back up or restore data, you can make use of I/O slaves for</span></p><p class="c0"><span class="c1">both disk and tape devices.</span></p><p class="c0"><span class="c1">&#9632; Database writer slaves</span></p><p class="c0"><span class="c1">If it is not practical to use multiple database writer processes, such as when the</span></p><p class="c0"><span class="c1">computer has one CPU, then the database can distribute I/O over multiple slave</span></p><p class="c0"><span class="c1">processes. DBWR is the only process that scans the buffer cache LRU list for blocks</span></p><p class="c0"><span class="c1">to be written to disk. However, I/O slaves perform the I/O for these blocks.</span></p><p class="c0"><span class="c1">Parallel Query Slaves</span></p><p class="c0"><span class="c1">In parallel execution or parallel processing, multiple processes work together</span></p><p class="c0"><span class="c1">simultaneously to run a single SQL statement. By dividing the work among multiple</span></p><p class="c0"><span class="c1">processes, Oracle Database can run the statement more quickly. For example, four</span></p><p class="c0"><span class="c1">processes handle four different quarters in a year instead of one process handling all</span></p><p class="c0"><span class="c1">four quarters by itself.</span></p><p class="c0"><span class="c1">Parallel execution reduces response time for data-intensive operations on large</span></p><p class="c0"><span class="c1">databases such as data warehouses. Symmetric multiprocessing (SMP) and clustered</span></p><p class="c0"><span class="c1">system gain the largest performance benefits from parallel execution because</span></p><p class="c0"><span class="c1">statement processing can be split up among multiple CPUs. Parallel execution can also</span></p><p class="c0"><span class="c1">benefit certain types of OLTP and hybrid systems.</span></p><p class="c0"><span class="c1">In Oracle RAC systems, the service placement of a particular service controls parallel</span></p><p class="c0"><span class="c1">execution. Specifically, parallel processes run on the nodes on which you have</span></p><p class="c0"><span class="c1">configured the service. By default, Oracle Database runs the parallel process only on</span></p><p class="c0"><span class="c1">the instance that offers the service used to connect to the database. This does not affect</span></p><p class="c0"><span class="c1">other parallel operations such as parallel recovery or the processing of GV$ queries.</span></p><p class="c0"><span class="c1">Serial Execution In serial execution, a single server process performs all necessary</span></p><p class="c0"><span class="c1">processing for the sequential execution of a SQL statement. For example, to perform a</span></p><p class="c0"><span class="c1">full table scan such as SELECT * FROM employees, one server process performs all of the</span></p><p class="c0"><span class="c1">work, as shown in Figure 15&ndash;5.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Backup and Recovery User&#39;s Guide to learn more</span></p><p class="c0"><span class="c1">about I/O slaves for backup and restore operations</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Performance Tuning Guide to learn more about</span></p><p class="c0"><span class="c1">database writer slaves</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Data Warehousing Guide and Oracle Database VLDB</span></p><p class="c0"><span class="c1">and Partitioning Guide to learn more about parallel execution</span></p><p class="c0"><span class="c1">&#9632; Oracle Real Application Clusters Administration and Deployment</span></p><p class="c0"><span class="c1">Guide for considerations regarding parallel execution in Oracle</span></p><p class="c0"><span class="c1">RAC environmentsOverview of Background Processes</span></p><p class="c0"><span class="c1">Process Architecture 15-15</span></p><p class="c0"><span class="c1">Figure 15&ndash;5 Serial Full Table Scan</span></p><p class="c0"><span class="c1">Parallel Execution In parallel execution, the server process acts as the parallel execution</span></p><p class="c0"><span class="c1">coordinator responsible for parsing the query, allocating and controlling the slave</span></p><p class="c0"><span class="c1">processes, and sending output to the user. Given a query plan for a SQL query, the</span></p><p class="c0"><span class="c1">coordinator breaks down each operator in a SQL query into parallel pieces, runs them</span></p><p class="c0"><span class="c1">in the order specified in the query, and integrates the partial results produced by the</span></p><p class="c0"><span class="c1">slave processes executing the operators.</span></p><p class="c0"><span class="c1">Figure 15&ndash;6 shows a parallel scan of the employees table. The table is divided</span></p><p class="c0"><span class="c1">dynamically (dynamic partitioning) into load units called granules. Each granule is a</span></p><p class="c0"><span class="c1">range of data blocks of the table read by a single slave process, called a parallel</span></p><p class="c0"><span class="c1">execution server, which uses Pnnn as a name format.</span></p><p class="c0"><span class="c1">Figure 15&ndash;6 Parallel Full Table Scan</span></p><p class="c0"><span class="c1">The database maps granules to execution servers at execution time. When an execution</span></p><p class="c0"><span class="c1">server finishes reading the rows corresponding to a granule, and when granules</span></p><p class="c0"><span class="c1">remain, it obtains another granule from the coordinator. This operation continues until</span></p><p class="c0"><span class="c1">the table has been read. The execution servers send results back to the coordinator,</span></p><p class="c0"><span class="c1">which assembles the pieces into the desired full table scan.</span></p><p class="c0"><span class="c1">The number of parallel execution servers assigned to a single operation is the degree</span></p><p class="c0"><span class="c1">of parallelism for an operation. Multiple operations within the same SQL statement all</span></p><p class="c0"><span class="c1">have the same degree of parallelism.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database VLDB and Partitioning Guide to learn how to use</span></p><p class="c0"><span class="c1">parallel execution</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Data Warehousing Guide to learn about</span></p><p class="c0"><span class="c1">recommended initialization parameters for parallelism</span></p><p class="c0"><span class="c1">SELECT COUNT(*)</span></p><p class="c0"><span class="c1">FROM employees</span></p><p class="c0"><span class="c1">WHERE phone_number LIKE &#39;650%&#39;;</span></p><p class="c0"><span class="c1">employees Table</span></p><p class="c0"><span class="c1">Serial Process</span></p><p class="c0"><span class="c1">Server</span></p><p class="c0"><span class="c1">Process</span></p><p class="c0"><span class="c1">SELECT COUNT(*)</span></p><p class="c0"><span class="c1">FROM employees</span></p><p class="c0"><span class="c1">WHERE phone_number LIKE &#39;650%&#39;;</span></p><p class="c0"><span class="c1">Parallel Execution</span></p><p class="c0"><span class="c1">Coordinator</span></p><p class="c0"><span class="c1">Parallel Execution</span></p><p class="c0"><span class="c1">Server Processes</span></p><p class="c0"><span class="c1">employees Table</span></p><p class="c0"><span class="c1">Granules</span></p><p class="c0"><span class="c1">Server</span></p><p class="c0"><span class="c1">Process</span></p><p class="c0"><span class="c1">Server</span></p><p class="c0"><span class="c1">Process</span></p><p class="c0"><span class="c1">Server</span></p><p class="c0"><span class="c1">Process</span></p><p class="c0"><span class="c1">Server</span></p><p class="c0"><span class="c1">ProcessOverview of Background Processes</span></p><p class="c0"><span class="c1">15-16 Oracle Database Concepts16</span></p><p class="c0"><span class="c1">Application and Networking Architecture 16-1</span></p><p class="c0"><span class="c1">Application and Networking Architecture 6 1</span></p><p class="c0"><span class="c1">This chapter defines application architecture and describes how an Oracle database</span></p><p class="c0"><span class="c1">and database applications work in a distributed processing environment. This material</span></p><p class="c0"><span class="c1">applies to almost every type of Oracle Database environment.</span></p><p class="c0"><span class="c1">This chapter contains the following sections:</span></p><p class="c0"><span class="c1">&#9632; Overview of Oracle Application Architecture</span></p><p class="c0"><span class="c1">&#9632; Overview of Oracle Networking Architecture</span></p><p class="c0"><span class="c1">&#9632; Overview of the Program Interface</span></p><p class="c0"><span class="c1">Overview of Oracle Application Architecture</span></p><p class="c0"><span class="c1">In the context of this chapter, application architecture refers to the computing</span></p><p class="c0"><span class="c1">environment in which a database application connects to an Oracle database.</span></p><p class="c0"><span class="c1">Overview of Client/Server Architecture</span></p><p class="c0"><span class="c1">In the Oracle Database environment, the database application and the database are</span></p><p class="c0"><span class="c1">separated into a client/server architecture:</span></p><p class="c0"><span class="c1">&#9632; The client runs the database application, for example, SQL*Plus or a Visual Basic</span></p><p class="c0"><span class="c1">data entry program, that accesses database information and interacts with a user.</span></p><p class="c0"><span class="c1">&#9632; The server runs the Oracle Database software and handles the functions required</span></p><p class="c0"><span class="c1">for concurrent, shared data access to an Oracle database.</span></p><p class="c0"><span class="c1">Although the client application and database can run on the same computer, greater</span></p><p class="c0"><span class="c1">efficiency is often achieved when the client portions and server portion are run by</span></p><p class="c0"><span class="c1">different computers connected through a network. The following sections discuss</span></p><p class="c0"><span class="c1">variations in the Oracle Database client/server architecture.</span></p><p class="c0"><span class="c1">Distributed Processing</span></p><p class="c0"><span class="c1">Using multiple hosts to process an individual task is known as distributed processing.</span></p><p class="c0"><span class="c1">Front-end and back-end processing occurs on different computers. In Figure 16&ndash;1, the</span></p><p class="c0"><span class="c1">client and server are located on different hosts connected through Oracle Net Services.Overview of Oracle Application Architecture</span></p><p class="c0"><span class="c1">16-2 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Figure 16&ndash;1 Client/Server Architecture and Distributed Processing</span></p><p class="c0"><span class="c1">Figure 16&ndash;2 is a variation that depicts a distributed database. In this example, a</span></p><p class="c0"><span class="c1">database on one host accesses data on a separate database located on a different host.</span></p><p class="c0"><span class="c1">Figure 16&ndash;2 Client/Server Architecture and Distributed Database</span></p><p class="c0"><span class="c1">Advantages of a Client/Server Architecture</span></p><p class="c0"><span class="c1">Oracle Database client/server architecture in a distributed processing environment</span></p><p class="c0"><span class="c1">provides the following benefits:</span></p><p class="c0"><span class="c1">&#9632; Client applications are not responsible for performing data processing. Rather,</span></p><p class="c0"><span class="c1">they request input from users, request data from the server, and then analyze and</span></p><p class="c0"><span class="c1">present this data using the display capabilities of the client workstation or the</span></p><p class="c0"><span class="c1">terminal (for example, using graphics or spreadsheets).</span></p><p class="c0"><span class="c1">Note: This rest of this chapter applies to environments with one</span></p><p class="c0"><span class="c1">database on one server.</span></p><p class="c0"><span class="c1">Network</span></p><p class="c0"><span class="c1">Database Server</span></p><p class="c0"><span class="c1">Client Client</span></p><p class="c0"><span class="c1">Network</span></p><p class="c0"><span class="c1">Client Client</span></p><p class="c0"><span class="c1">Network</span></p><p class="c0"><span class="c1">Database Server Database ServerOverview of Oracle Application Architecture</span></p><p class="c0"><span class="c1">Application and Networking Architecture 16-3</span></p><p class="c0"><span class="c1">&#9632; Client applications are not dependent on the physical location of the data. Even if</span></p><p class="c0"><span class="c1">the data is moved or distributed to other database servers, the application</span></p><p class="c0"><span class="c1">continues to function with little or no modification.</span></p><p class="c0"><span class="c1">&#9632; Oracle Database exploits the multitasking and shared-memory facilities of its</span></p><p class="c0"><span class="c1">underlying operating system. As a result, it delivers the highest possible degree of</span></p><p class="c0"><span class="c1">concurrency, data integrity, and performance to its client applications.</span></p><p class="c0"><span class="c1">&#9632; Client workstations or terminals can be optimized for the presentation of data (for</span></p><p class="c0"><span class="c1">example, by providing graphics and mouse support), while the server can be</span></p><p class="c0"><span class="c1">optimized for the processing and storage of data (for example, by having large</span></p><p class="c0"><span class="c1">amounts of memory and disk space).</span></p><p class="c0"><span class="c1">&#9632; In networked environments, you can use inexpensive client workstations to access</span></p><p class="c0"><span class="c1">the remote data of the server effectively.</span></p><p class="c0"><span class="c1">&#9632; The database can be scaled as your system grows. You can add multiple servers to</span></p><p class="c0"><span class="c1">distribute the database processing load throughout the network (horizontally</span></p><p class="c0"><span class="c1">scaled), or you can move the database to a minicomputer or mainframe to take</span></p><p class="c0"><span class="c1">advantage of a larger system&#39;s performance (vertically scaled). In either case, data</span></p><p class="c0"><span class="c1">and applications are maintained with little or no modification because Oracle</span></p><p class="c0"><span class="c1">Database is portable between systems.</span></p><p class="c0"><span class="c1">&#9632; In networked environments, shared data is stored on the servers rather than on all</span></p><p class="c0"><span class="c1">computers, making it easier and more efficient to manage concurrent access.</span></p><p class="c0"><span class="c1">&#9632; In networked environments, client applications submit database requests to the</span></p><p class="c0"><span class="c1">server using SQL statements. After it is received, each SQL statement is processed</span></p><p class="c0"><span class="c1">by the server, which returns results to the client. Network traffic is minimized</span></p><p class="c0"><span class="c1">because only the requests and the results are shipped over the network.</span></p><p class="c0"><span class="c1">Overview of Multitier Architecture</span></p><p class="c0"><span class="c1">In a traditional multitier architecture environment, an application server provides data</span></p><p class="c0"><span class="c1">for clients and serves as an interface between clients and database servers. This</span></p><p class="c0"><span class="c1">architecture enables use of an application server to:</span></p><p class="c0"><span class="c1">&#9632; Validate the credentials of a client, such as a Web browser</span></p><p class="c0"><span class="c1">&#9632; Connect to a database server</span></p><p class="c0"><span class="c1">&#9632; Perform the requested operation</span></p><p class="c0"><span class="c1">An example of a multitier architecture appears in Figure 16&ndash;3.</span></p><p class="c0"><span class="c1">See Also: Oracle Database Administrator&#39;s Guide to learn more about</span></p><p class="c0"><span class="c1">distributed databasesOverview of Oracle Application Architecture</span></p><p class="c0"><span class="c1">16-4 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Figure 16&ndash;3 A Multitier Architecture Environment</span></p><p class="c0"><span class="c1">Clients</span></p><p class="c0"><span class="c1">A client initiates a request for an operation to be performed on the database server.</span></p><p class="c0"><span class="c1">The client can be a Web browser or other end-user program. In a multitier architecture,</span></p><p class="c0"><span class="c1">the client connects to the database server through one or more application servers.</span></p><p class="c0"><span class="c1">Application Servers</span></p><p class="c0"><span class="c1">An application server provides access to the data for the client. It serves as an interface</span></p><p class="c0"><span class="c1">between the client and one or more database servers, and hosts the applications.</span></p><p class="c0"><span class="c1">An application server permits thin clients, which are clients equipped with minimal</span></p><p class="c0"><span class="c1">software configurations, to access applications without requiring ongoing maintenance</span></p><p class="c0"><span class="c1">of the client computers. The application server can also perform some data</span></p><p class="c0"><span class="c1">reformatting for the client, reducing the load on the client workstation.</span></p><p class="c0"><span class="c1">The application server assumes the identity of the client when it is performing</span></p><p class="c0"><span class="c1">operations on the database server for that client. The privileges of the application</span></p><p class="c0"><span class="c1">server should be restricted to prevent it from performing unneeded and unwanted</span></p><p class="c0"><span class="c1">operations during a client operation.</span></p><p class="c0"><span class="c1">Database Servers</span></p><p class="c0"><span class="c1">A database server provides the data requested by an application server on behalf of a</span></p><p class="c0"><span class="c1">client. The database performs all of the query processing.</span></p><p class="c0"><span class="c1">The database server can audit operations performed by the application server on</span></p><p class="c0"><span class="c1">behalf of clients and operations performed by the application server on its own behalf</span></p><p class="c0"><span class="c1">(see &quot;Monitoring&quot; on page 17-6). For example, a client operation can request</span></p><p class="c0"><span class="c1">information to display on the client, while an application server operation can request</span></p><p class="c0"><span class="c1">a connection to the database server.</span></p><p class="c0"><span class="c1">Database Server</span></p><p class="c0"><span class="c1">Database Server</span></p><p class="c0"><span class="c1">Thin Client</span></p><p class="c0"><span class="c1">Thin Client</span></p><p class="c0"><span class="c1">Thin Client</span></p><p class="c0"><span class="c1">Application</span></p><p class="c0"><span class="c1">Server 1</span></p><p class="c0"><span class="c1">Database Server</span></p><p class="c0"><span class="c1">Database Server</span></p><p class="c0"><span class="c1">Application</span></p><p class="c0"><span class="c1">Server n</span></p><p class="c0"><span class="c1">Database Server</span></p><p class="c0"><span class="c1">Database Server</span></p><p class="c0"><span class="c1">Application</span></p><p class="c0"><span class="c1">Server 2</span></p><p class="c0"><span class="c1">Request</span></p><p class="c0"><span class="c1">Query</span></p><p class="c0"><span class="c1">DataOverview of Oracle Networking Architecture</span></p><p class="c0"><span class="c1">Application and Networking Architecture 16-5</span></p><p class="c0"><span class="c1">Service Oriented Architecture (SOA)</span></p><p class="c0"><span class="c1">The database can serve as a Web service provider in traditional multitier or</span></p><p class="c0"><span class="c1">service-oriented architecture (SOA) environments. SOA is a multitier architecture</span></p><p class="c0"><span class="c1">relying on services that support computer-to-computer interaction over a network.</span></p><p class="c0"><span class="c1">The services can be dynamically discovered and queried on available functions and</span></p><p class="c0"><span class="c1">calling sequences.</span></p><p class="c0"><span class="c1">SOA services are usually implemented as Web services accessible through the HTTP</span></p><p class="c0"><span class="c1">protocol. They are based on XML standards such as WSDL and SOAP.</span></p><p class="c0"><span class="c1">The Oracle Database Web service capability, which is implemented as part of XML DB,</span></p><p class="c0"><span class="c1">must be specifically enabled by the DBA. Applications can then accomplish the</span></p><p class="c0"><span class="c1">following through database Web services:</span></p><p class="c0"><span class="c1">&#9632; Submit SQL or XQuery queries and receive results as XML</span></p><p class="c0"><span class="c1">&#9632; Invoke standalone PL/SQL functions and receive results (see &quot;PL/SQL</span></p><p class="c0"><span class="c1">Subprograms&quot; on page 8-3)</span></p><p class="c0"><span class="c1">&#9632; Invoke PL/SQL package functions and receive results</span></p><p class="c0"><span class="c1">Database Web services provide a simple way to add Web services to an application</span></p><p class="c0"><span class="c1">environment without the need for an application server. However, invoking Web</span></p><p class="c0"><span class="c1">services through application servers such as Oracle Fusion Middleware offers security,</span></p><p class="c0"><span class="c1">scalability, UDDI registration, and reliable messaging in an SOA environment.</span></p><p class="c0"><span class="c1">However, because database Web services integrate easily with Oracle Fusion</span></p><p class="c0"><span class="c1">Middleware, they may be appropriate for optimizing SOA solutions.</span></p><p class="c0"><span class="c1">Overview of Grid Architecture</span></p><p class="c0"><span class="c1">In an Oracle Database environment, grid computing is a computing architecture that</span></p><p class="c0"><span class="c1">effectively pools large numbers of servers and storage into a flexible, on-demand</span></p><p class="c0"><span class="c1">computing resource. Modular hardware and software components can be connected</span></p><p class="c0"><span class="c1">and rejoined on demand to meet the changing needs of businesses.</span></p><p class="c0"><span class="c1">Overview of Oracle Networking Architecture</span></p><p class="c0"><span class="c1">Oracle Net Services is a suite of networking components that provides</span></p><p class="c0"><span class="c1">enterprise-wide connectivity solutions in distributed, heterogeneous computing</span></p><p class="c0"><span class="c1">environments. Oracle Net Services enables a network session from an application to a</span></p><p class="c0"><span class="c1">database instance and a database instance to another database instance.</span></p><p class="c0"><span class="c1">Oracle Net Services provides location transparency, centralized configuration and</span></p><p class="c0"><span class="c1">management, and quick installation and configuration. It also lets you maximize</span></p><p class="c0"><span class="c1">system resources and improve performance. The Oracle Database shared server</span></p><p class="c0"><span class="c1">architecture increases the scalability of applications and the number of clients</span></p><p class="c0"><span class="c1">simultaneously connected to the database. The Virtual Interface (VI) protocol places</span></p><p class="c0"><span class="c1">most of the messaging burden on high-speed network hardware, freeing the CPU.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle XML DB Developer&#39;s Guide for information on enabling and</span></p><p class="c0"><span class="c1">using database Web services</span></p><p class="c0"><span class="c1">&#9632; Oracle Fusion Middleware documentation for more information</span></p><p class="c0"><span class="c1">on SOA and Web services</span></p><p class="c0"><span class="c1">See Also: &quot;Overview of Grid Computing&quot; on page 17-12 for more</span></p><p class="c0"><span class="c1">detailed information about server and storage gridsOverview of Oracle Networking Architecture</span></p><p class="c0"><span class="c1">16-6 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Oracle Net Services uses the communication protocols or application programmatic</span></p><p class="c0"><span class="c1">interfaces (APIs) supported by a wide range of networks to provide distributed</span></p><p class="c0"><span class="c1">database and distributed processing. After a network session is established, Oracle Net</span></p><p class="c0"><span class="c1">Services acts as a data courier for the client application and the database server,</span></p><p class="c0"><span class="c1">establishing and maintaining a connection and exchanging messages. Oracle Net</span></p><p class="c0"><span class="c1">Services can perform these tasks because it exists on each computer in the network.</span></p><p class="c0"><span class="c1">How Oracle Net Services Works</span></p><p class="c0"><span class="c1">Oracle Database protocols take SQL statements from the interface of the Oracle</span></p><p class="c0"><span class="c1">applications and package them for transmission to Oracle Database through a</span></p><p class="c0"><span class="c1">supported industry-standard higher level protocol or API. Replies from Oracle</span></p><p class="c0"><span class="c1">Database are packaged through the same higher level communications mechanism.</span></p><p class="c0"><span class="c1">This work occurs independently of the network operating system.</span></p><p class="c0"><span class="c1">Depending on the operating system that runs Oracle Database, the Oracle Net Services</span></p><p class="c0"><span class="c1">software of the database server could include the driver software and start an</span></p><p class="c0"><span class="c1">additional background process.</span></p><p class="c0"><span class="c1">The Oracle Net Listener</span></p><p class="c0"><span class="c1">The Oracle Net Listener, also called the listener, is a server-side process that listens</span></p><p class="c0"><span class="c1">for incoming client connection requests and manages traffic to the database. When a</span></p><p class="c0"><span class="c1">database instance starts, and at various times during its life, the instance contacts a</span></p><p class="c0"><span class="c1">listener and establishes a communication pathway to this instance.</span></p><p class="c0"><span class="c1">Service registration enables the listener to determine whether a database service and</span></p><p class="c0"><span class="c1">its service handlers are available. A service handler is a dedicated server process or</span></p><p class="c0"><span class="c1">dispatcher that acts as a connection point to a database. During registration, the</span></p><p class="c0"><span class="c1">PMON process provides the listener with the instance name, database service names,</span></p><p class="c0"><span class="c1">and the type and addresses of service handlers. This information enables the listener to</span></p><p class="c0"><span class="c1">start a service handler when a client request arrives.</span></p><p class="c0"><span class="c1">Figure 16&ndash;4 shows two databases, each on a separate host. The database environment</span></p><p class="c0"><span class="c1">is serviced by two listeners, each on a separate host. The PMON process running in</span></p><p class="c0"><span class="c1">each database instance communicates with both listeners to register the database.</span></p><p class="c0"><span class="c1">See Also: Oracle Database Net Services Administrator&#39;s Guide for an</span></p><p class="c0"><span class="c1">overview of Oracle Net architecture</span></p><p class="c0"><span class="c1">See Also: Oracle Database Net Services Administrator&#39;s Guide for</span></p><p class="c0"><span class="c1">more information about how Oracle Net Services worksOverview of Oracle Networking Architecture</span></p><p class="c0"><span class="c1">Application and Networking Architecture 16-7</span></p><p class="c0"><span class="c1">Figure 16&ndash;4 shows a browser making an HTTP connection and a client making a</span></p><p class="c0"><span class="c1">database connection through a listener. The listener does not need to reside on the</span></p><p class="c0"><span class="c1">database host.</span></p><p class="c0"><span class="c1">Figure 16&ndash;4 Listener Architecture</span></p><p class="c0"><span class="c1">The basic steps by which a client establishes a connection through a listener are:</span></p><p class="c0"><span class="c1">1. A client process or another database requests a connection.</span></p><p class="c0"><span class="c1">2. The listener selects an appropriate service handler to service the client request and</span></p><p class="c0"><span class="c1">forwards the request to the handler.</span></p><p class="c0"><span class="c1">3. The client process connects directly to the service handler. The listener is no longer</span></p><p class="c0"><span class="c1">involved in the communication.</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">Server</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">Server</span></p><p class="c0"><span class="c1">Database Instance</span></p><p class="c0"><span class="c1">Database Instance</span></p><p class="c0"><span class="c1">Service names, instance names,</span></p><p class="c0"><span class="c1">network addresses</span></p><p class="c0"><span class="c1">Listener</span></p><p class="c0"><span class="c1">Listener</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">PMON</span></p><p class="c0"><span class="c1">PMON</span></p><p class="c0"><span class="c1">Client</span></p><p class="c0"><span class="c1">2</span></p><p class="c0"><span class="c1">1</span></p><p class="c0"><span class="c1">3 3</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">Client</span></p><p class="c0"><span class="c1">Web</span></p><p class="c0"><span class="c1">Browser</span></p><p class="c0"><span class="c1">HTTP(S)</span></p><p class="c0"><span class="c1">Presentation</span></p><p class="c0"><span class="c1">over TCP/IP</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">Connection</span></p><p class="c0"><span class="c1">over TCP/IP</span></p><p class="c0"><span class="c1">ListenerOverview of Oracle Networking Architecture</span></p><p class="c0"><span class="c1">16-8 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Service Names</span></p><p class="c0"><span class="c1">In the context of net services, a service is a set of one or more database instances. A</span></p><p class="c0"><span class="c1">service name is a logical representation of a service used for client connections.</span></p><p class="c0"><span class="c1">When a client connects to a listener, it requests a connection to a service. When a</span></p><p class="c0"><span class="c1">database instance starts, it registers itself with a listener as providing one or more</span></p><p class="c0"><span class="c1">services by name. Thus, the listener acts as a mediator between the client and instances</span></p><p class="c0"><span class="c1">and routes the connection request to the right place.</span></p><p class="c0"><span class="c1">A single service, as known by a listener, can identify one or more database instances.</span></p><p class="c0"><span class="c1">Also, a single database instance can register one or more services with a listener.</span></p><p class="c0"><span class="c1">Clients connecting to a service need not specify which instance they require.</span></p><p class="c0"><span class="c1">Figure 16&ndash;5 shows one single-instance database associated with two services,</span></p><p class="c0"><span class="c1">book.example.com and soft.example.com. The services enable the same database to</span></p><p class="c0"><span class="c1">be identified differently by different clients. A database administrator can limit or</span></p><p class="c0"><span class="c1">reserve system resources, permitting better resource allocation to clients requesting</span></p><p class="c0"><span class="c1">one of these services.</span></p><p class="c0"><span class="c1">Figure 16&ndash;5 Multiple Services Associated with One Database</span></p><p class="c0"><span class="c1">Service Registration</span></p><p class="c0"><span class="c1">Service registration is a feature by which the PMON process dynamically registers</span></p><p class="c0"><span class="c1">instance information with a listener, which enables the listener to forward client</span></p><p class="c0"><span class="c1">connection requests to the appropriate service handler. PMON provides the listener</span></p><p class="c0"><span class="c1">with information about the following:</span></p><p class="c0"><span class="c1">See Also: &quot;Overview of Client Processes&quot; on page 15-3 and</span></p><p class="c0"><span class="c1">&quot;Overview of Server Processes&quot; on page 15-6</span></p><p class="c0"><span class="c1">See Also: Oracle Database Net Services Administrator&#39;s Guide to learn</span></p><p class="c0"><span class="c1">more about naming methods</span></p><p class="c0"><span class="c1">book.example.com</span></p><p class="c0"><span class="c1">soft.example.com</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">Host</span></p><p class="c0"><span class="c1">HTTPS</span></p><p class="c0"><span class="c1">HTTPS</span></p><p class="c0"><span class="c1">HTTPS</span></p><p class="c0"><span class="c1">Client</span></p><p class="c0"><span class="c1">Client</span></p><p class="c0"><span class="c1">Client</span></p><p class="c0"><span class="c1">DatabaseOverview of Oracle Networking Architecture</span></p><p class="c0"><span class="c1">Application and Networking Architecture 16-9</span></p><p class="c0"><span class="c1">&#9632; Names of the database services provided by the database</span></p><p class="c0"><span class="c1">&#9632; Name of the database instance associated with the services and its current and</span></p><p class="c0"><span class="c1">maximum load</span></p><p class="c0"><span class="c1">&#9632; Service handlers (dispatchers and dedicated servers) available for the instance,</span></p><p class="c0"><span class="c1">including their type, protocol addresses, and current and maximum load</span></p><p class="c0"><span class="c1">Service registration is dynamic and does not require configuration in the listener.ora</span></p><p class="c0"><span class="c1">file. Dynamic registration reduces administrative overhead for multiple databases or</span></p><p class="c0"><span class="c1">instances.</span></p><p class="c0"><span class="c1">The initialization parameter SERVICE_NAMES lists the services an instance belongs to.</span></p><p class="c0"><span class="c1">On startup, each instance registers with the listeners of other instances belonging to</span></p><p class="c0"><span class="c1">the same services. During database operations, the instances of each service pass</span></p><p class="c0"><span class="c1">information about CPU use and current connection counts to all listeners in the same</span></p><p class="c0"><span class="c1">services. This communication enables dynamic load balancing and connection failover.</span></p><p class="c0"><span class="c1">Dedicated Server Architecture</span></p><p class="c0"><span class="c1">In a dedicated server architecture, the server process created on behalf of each client</span></p><p class="c0"><span class="c1">process is called a dedicated server process (or shadow process). This server process is</span></p><p class="c0"><span class="c1">separate from the client process and acts only on its behalf, as shown in Figure 16&ndash;6.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Process Monitor Process (PMON)&quot; on page 15-8</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Net Services Administrator&#39;s Guide to learn more</span></p><p class="c0"><span class="c1">about service registration</span></p><p class="c0"><span class="c1">&#9632; Oracle Real Application Clusters Administration and Deployment</span></p><p class="c0"><span class="c1">Guide to learn about instance registration and client/service</span></p><p class="c0"><span class="c1">connections in Oracle RACOverview of Oracle Networking Architecture</span></p><p class="c0"><span class="c1">16-10 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Figure 16&ndash;6 Oracle Database Using Dedicated Server Processes</span></p><p class="c0"><span class="c1">A one-to-one ratio exists between the client processes and server processes. Even when</span></p><p class="c0"><span class="c1">the user is not actively making a database request, the dedicated server process</span></p><p class="c0"><span class="c1">remains&mdash;although it is inactive and can be paged out on some operating systems.</span></p><p class="c0"><span class="c1">Figure 16&ndash;6 shows user and server processes running on networked computers.</span></p><p class="c0"><span class="c1">However, the dedicated server architecture is also used if the same computer runs</span></p><p class="c0"><span class="c1">both the client application and the database code but the host operating system could</span></p><p class="c0"><span class="c1">not maintain the separation of the two programs if they were run in a single process.</span></p><p class="c0"><span class="c1">Linux is an example of such an operating system.</span></p><p class="c0"><span class="c1">In the dedicated server architecture, the user and server processes communicate using</span></p><p class="c0"><span class="c1">different mechanisms:</span></p><p class="c0"><span class="c1">&#9632; If the client process and the dedicated server process run on the same computer,</span></p><p class="c0"><span class="c1">then the program interface uses the host operating system&#39;s interprocess</span></p><p class="c0"><span class="c1">communication mechanism to perform its job.</span></p><p class="c0"><span class="c1">&#9632; If the client process and the dedicated server process run on different computers,</span></p><p class="c0"><span class="c1">then the program interface provides the communication mechanisms (such as the</span></p><p class="c0"><span class="c1">network software and Oracle Net Services) between the programs.</span></p><p class="c0"><span class="c1">Underutilized dedicated servers sometimes result in inefficient use of operating</span></p><p class="c0"><span class="c1">system resources. Consider an order entry system with dedicated server processes. A</span></p><p class="c0"><span class="c1">customer places an order as a clerk enters the order into the database. For most of the</span></p><p class="c0"><span class="c1">transaction, the clerk is talking to the customer while the server process dedicated to</span></p><p class="c0"><span class="c1">the clerk&#39;s client process is idle. The server process is not needed during most of the</span></p><p class="c0"><span class="c1">System Global Area (SGA)</span></p><p class="c0"><span class="c1">Instance</span></p><p class="c0"><span class="c1">Shared Pool</span></p><p class="c0"><span class="c1">Private</span></p><p class="c0"><span class="c1">SQL Area</span></p><p class="c0"><span class="c1">(Shared</span></p><p class="c0"><span class="c1">Server Only)</span></p><p class="c0"><span class="c1">Shared SQL Area</span></p><p class="c0"><span class="c1">Library Cache</span></p><p class="c0"><span class="c1">Data</span></p><p class="c0"><span class="c1">Dictionary</span></p><p class="c0"><span class="c1">Cache</span></p><p class="c0"><span class="c1">Server</span></p><p class="c0"><span class="c1">Result</span></p><p class="c0"><span class="c1">Cache</span></p><p class="c0"><span class="c1">Other Reserved</span></p><p class="c0"><span class="c1">Pool</span></p><p class="c0"><span class="c1">Client</span></p><p class="c0"><span class="c1">Process</span></p><p class="c0"><span class="c1">Dedicated Server</span></p><p class="c0"><span class="c1">Process</span></p><p class="c0"><span class="c1">Dedicated Server</span></p><p class="c0"><span class="c1">Process</span></p><p class="c0"><span class="c1">PGA</span></p><p class="c0"><span class="c1">Session Memory Private SQL Area</span></p><p class="c0"><span class="c1">SQL Work Areas</span></p><p class="c0"><span class="c1">Client</span></p><p class="c0"><span class="c1">Process</span></p><p class="c0"><span class="c1">PGA</span></p><p class="c0"><span class="c1">Session Memory Private SQL Area</span></p><p class="c0"><span class="c1">SQL Work Areas</span></p><p class="c0"><span class="c1">TCP/IP Connection TCP/IP ConnectionOverview of Oracle Networking Architecture</span></p><p class="c0"><span class="c1">Application and Networking Architecture 16-11</span></p><p class="c0"><span class="c1">transaction, and the system may be slower for other clerks entering orders if the</span></p><p class="c0"><span class="c1">system is managing too many processes. For applications of this type, the shared</span></p><p class="c0"><span class="c1">server architecture may be preferable.</span></p><p class="c0"><span class="c1">Shared Server Architecture</span></p><p class="c0"><span class="c1">In a shared server architecture, a dispatcher directs multiple incoming network</span></p><p class="c0"><span class="c1">session requests to a pool of shared server processes, eliminating the need for a</span></p><p class="c0"><span class="c1">dedicated server process for each connection. An idle shared server process from the</span></p><p class="c0"><span class="c1">pool picks up a request from a common queue.</span></p><p class="c0"><span class="c1">The potential benefits of shared server are as follows:</span></p><p class="c0"><span class="c1">&#9632; Reduces the number of processes on the operating system</span></p><p class="c0"><span class="c1">A small number of shared servers can perform the same amount of processing as</span></p><p class="c0"><span class="c1">many dedicated servers.</span></p><p class="c0"><span class="c1">&#9632; Reduces instance PGA memory</span></p><p class="c0"><span class="c1">Every dedicated or shared server has a PGA. Fewer server processes means fewer</span></p><p class="c0"><span class="c1">PGAs and less process management.</span></p><p class="c0"><span class="c1">&#9632; Increases application scalability and the number of clients that can simultaneously</span></p><p class="c0"><span class="c1">connect to the database</span></p><p class="c0"><span class="c1">&#9632; May be faster than dedicated server when the rate of client connections and</span></p><p class="c0"><span class="c1">disconnections is high</span></p><p class="c0"><span class="c1">Shared server has several disadvantages, including slower response time in some</span></p><p class="c0"><span class="c1">cases, incomplete feature support, and increased complexity for setup and tuning. As a</span></p><p class="c0"><span class="c1">general guideline, only use shared server when you have more concurrent connections</span></p><p class="c0"><span class="c1">to the database than the operating system can handle.</span></p><p class="c0"><span class="c1">The following processes are needed in a shared server architecture:</span></p><p class="c0"><span class="c1">&#9632; A network listener that connects the client processes to dispatchers or dedicated</span></p><p class="c0"><span class="c1">servers (the listener is part of Oracle Net Services, not Oracle Database)</span></p><p class="c0"><span class="c1">&#9632; One or more dispatcher process (Dnnn)</span></p><p class="c0"><span class="c1">&#9632; One or more shared server processes</span></p><p class="c0"><span class="c1">Note that a database can support both shared server and dedicated server connections</span></p><p class="c0"><span class="c1">simultaneously. For example, one client can connect using a dedicated server while a</span></p><p class="c0"><span class="c1">different client connects to the same database using a shared server.</span></p><p class="c0"><span class="c1">See Also: Oracle Database Net Services Administrator&#39;s Guide to learn</span></p><p class="c0"><span class="c1">more about dedicated server processes</span></p><p class="c0"><span class="c1">Note: To use shared servers, a client process must connect through</span></p><p class="c0"><span class="c1">Oracle Net Services, even if the process runs on the same computer as</span></p><p class="c0"><span class="c1">the Oracle Database instance.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Net Services Administrator&#39;s Guide for more</span></p><p class="c0"><span class="c1">information about the shared server architecture</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn how to configure</span></p><p class="c0"><span class="c1">a database for shared serverOverview of Oracle Networking Architecture</span></p><p class="c0"><span class="c1">16-12 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Dispatcher Request and Response Queues</span></p><p class="c0"><span class="c1">A request from a user is a single API call that is part of the user&#39;s SQL statement. When</span></p><p class="c0"><span class="c1">a user makes a call, the following actions occur:</span></p><p class="c0"><span class="c1">1. The dispatcher places the request on the request queue, where it is picked up by</span></p><p class="c0"><span class="c1">the next available shared server process.</span></p><p class="c0"><span class="c1">The request queue is in the SGA and is common to all dispatcher processes of an</span></p><p class="c0"><span class="c1">instance (see &quot;Large Pool&quot; on page 14-21).</span></p><p class="c0"><span class="c1">2. The shared server processes check the common request queue for new requests,</span></p><p class="c0"><span class="c1">picking up new requests on a first-in-first-out basis.</span></p><p class="c0"><span class="c1">3. One shared server process picks up one request in the queue and makes all</span></p><p class="c0"><span class="c1">necessary calls to the database to complete this request.</span></p><p class="c0"><span class="c1">A different server process can handle each database call. Therefore, requests to</span></p><p class="c0"><span class="c1">parse a query, fetch the first row, fetch the next row, and close the result set may</span></p><p class="c0"><span class="c1">each be processed by a different shared server.</span></p><p class="c0"><span class="c1">4. When the server process completes the request, it places the response on the</span></p><p class="c0"><span class="c1">calling dispatcher&#39;s response queue. Each dispatcher has its own response queue.</span></p><p class="c0"><span class="c1">5. The dispatcher returns the completed request to the appropriate client process.</span></p><p class="c0"><span class="c1">For example, in an order entry system, each clerk&#39;s client process connects to a</span></p><p class="c0"><span class="c1">dispatcher. Each request made by the clerk is sent to this dispatcher, which places the</span></p><p class="c0"><span class="c1">request in the queue. The next available shared server picks up the request, services it,</span></p><p class="c0"><span class="c1">and puts the response in the response queue. When a request is completed, the clerk</span></p><p class="c0"><span class="c1">remains connected to the dispatcher, but the shared server that processed the request is</span></p><p class="c0"><span class="c1">released and available for other requests. While one clerk talks to a customer, another</span></p><p class="c0"><span class="c1">clerk can use the same shared server process.</span></p><p class="c0"><span class="c1">Figure 16&ndash;7 shows how client processes communicate with the dispatcher across the</span></p><p class="c0"><span class="c1">API and how the dispatcher communicates user requests to shared server processes.Overview of Oracle Networking Architecture</span></p><p class="c0"><span class="c1">Application and Networking Architecture 16-13</span></p><p class="c0"><span class="c1">Figure 16&ndash;7 The Shared Server Configuration and Processes</span></p><p class="c0"><span class="c1">Dispatcher Processes (Dnnn) The dispatcher processes enable client processes to share a</span></p><p class="c0"><span class="c1">limited number of server processes. You can create multiple dispatcher processes for a</span></p><p class="c0"><span class="c1">single database instance. The optimum number of dispatcher processes depending on</span></p><p class="c0"><span class="c1">the operating system limitation and the number of connections for each process.</span></p><p class="c0"><span class="c1">Dispatcher processes establish communication as follows:</span></p><p class="c0"><span class="c1">1. When an instance starts, the network listener process opens and establishes a</span></p><p class="c0"><span class="c1">communication pathway through which users connect to Oracle Database.</span></p><p class="c0"><span class="c1">2. Each dispatcher process gives the listener process an address at which the</span></p><p class="c0"><span class="c1">dispatcher listens for connection requests.</span></p><p class="c0"><span class="c1">At least one dispatcher process must be configured and started for each network</span></p><p class="c0"><span class="c1">protocol that the database clients will use.</span></p><p class="c0"><span class="c1">3. When a client process makes a connection request, the listener determines whether</span></p><p class="c0"><span class="c1">the client process should use a shared server process:</span></p><p class="c0"><span class="c1">&#9632; If the listener determines that a shared server process is required, then the</span></p><p class="c0"><span class="c1">listener returns the address of the dispatcher process that has the lightest load,</span></p><p class="c0"><span class="c1">and the client process connects to the dispatcher directly.</span></p><p class="c0"><span class="c1">&#9632; If the process cannot communicate with the dispatcher, or if the client process</span></p><p class="c0"><span class="c1">requests a dedicated server, then the listener creates a dedicated server and</span></p><p class="c0"><span class="c1">establishes an appropriate connection.</span></p><p class="c0"><span class="c1">Note: Each client process that connects to a dispatcher must use</span></p><p class="c0"><span class="c1">Oracle Net Services, even if both processes run on the same host.</span></p><p class="c0"><span class="c1">Instance</span></p><p class="c0"><span class="c1">System Global Area (SGA)</span></p><p class="c0"><span class="c1">Large Pool</span></p><p class="c0"><span class="c1">Large Pool</span></p><p class="c0"><span class="c1">Request</span></p><p class="c0"><span class="c1">Queue</span></p><p class="c0"><span class="c1">10101</span></p><p class="c0"><span class="c1">10101</span></p><p class="c0"><span class="c1">10101 10101</span></p><p class="c0"><span class="c1">Data</span></p><p class="c0"><span class="c1">Files</span></p><p class="c0"><span class="c1">Response</span></p><p class="c0"><span class="c1">Queue</span></p><p class="c0"><span class="c1">Shared</span></p><p class="c0"><span class="c1">Server</span></p><p class="c0"><span class="c1">Processes</span></p><p class="c0"><span class="c1">Dispatcher</span></p><p class="c0"><span class="c1">Client Server</span></p><p class="c0"><span class="c1">ClientOverview of Oracle Networking Architecture</span></p><p class="c0"><span class="c1">16-14 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Shared Server Processes (Snnn) Each shared server process serves multiple client</span></p><p class="c0"><span class="c1">requests in the shared server configuration. Shared and dedicated server processes</span></p><p class="c0"><span class="c1">provide the same functionality, except shared server processes are not associated with</span></p><p class="c0"><span class="c1">a specific client process. Instead, a shared server process serves any client request in</span></p><p class="c0"><span class="c1">the shared server configuration.</span></p><p class="c0"><span class="c1">The PGA of a shared server process does not contain UGA data, which must be</span></p><p class="c0"><span class="c1">accessible to all shared server processes (see &quot;Overview of the Program Global Area&quot;</span></p><p class="c0"><span class="c1">on page 14-4). The shared server PGA contains only process-specific data.</span></p><p class="c0"><span class="c1">All session-related information is contained in the SGA. Each shared server process</span></p><p class="c0"><span class="c1">must be able to access all sessions&#39; data spaces so that any server can handle requests</span></p><p class="c0"><span class="c1">from any session. Space is allocated in the SGA for each session&#39;s data space.</span></p><p class="c0"><span class="c1">Restricted Operations of the Shared Server</span></p><p class="c0"><span class="c1">Certain administrative activities cannot be performed while connected to a dispatcher</span></p><p class="c0"><span class="c1">process, including shutting down or starting an instance and media recovery. These</span></p><p class="c0"><span class="c1">activities are typically performed when connected with administrator privileges. To</span></p><p class="c0"><span class="c1">connect with administrator privileges in a system configured with shared servers, you</span></p><p class="c0"><span class="c1">must specify that you want to use a dedicated server process.</span></p><p class="c0"><span class="c1">Database Resident Connection Pooling</span></p><p class="c0"><span class="c1">Database Resident Connection Pooling (DRCP) provides a connection pool of</span></p><p class="c0"><span class="c1">dedicated servers for typical Web application scenarios. A Web application typically</span></p><p class="c0"><span class="c1">makes a database connection, uses the connection briefly, and then releases it. Through</span></p><p class="c0"><span class="c1">DRCP, the database can scale to tens of thousands of simultaneous connections.</span></p><p class="c0"><span class="c1">DRCP provides the following advantages:</span></p><p class="c0"><span class="c1">&#9632; Complements middle-tier connection pools that share connections between</span></p><p class="c0"><span class="c1">threads in a middle-tier process.</span></p><p class="c0"><span class="c1">&#9632; Enables database connections to be shared across multiple middle-tier processes.</span></p><p class="c0"><span class="c1">These middle-tier processes may belong to the same or different middle-tier host.</span></p><p class="c0"><span class="c1">&#9632; Enables a significant reduction in key database resources required to support</span></p><p class="c0"><span class="c1">many client connections. For example, DRCP reduces the memory required for the</span></p><p class="c0"><span class="c1">database and boosts the scalability of the database and middle tier. The pool of</span></p><p class="c0"><span class="c1">available servers also reduces the cost of re-creating client connections.</span></p><p class="c0"><span class="c1">&#9632; Provides pooling for architectures with multi-process, single-threaded application</span></p><p class="c0"><span class="c1">servers, such as PHP and Apache, that cannot do middle-tier connection pooling.</span></p><p class="c0"><span class="c1">DRCP uses a pooled server, which is the equivalent of a dedicated server process (not</span></p><p class="c0"><span class="c1">a shared server process) and a database session combined. The pooled server model</span></p><p class="c0"><span class="c1">avoids the overhead of dedicating a server for every connection that requires the</span></p><p class="c0"><span class="c1">server for a short period.</span></p><p class="c0"><span class="c1">Clients obtaining connections from the database resident connection pool connect to</span></p><p class="c0"><span class="c1">an Oracle background process known as the connection broker. The connection</span></p><p class="c0"><span class="c1">broker implements the pool functionality and multiplexes pooled servers among</span></p><p class="c0"><span class="c1">inbound connections from client processes.</span></p><p class="c0"><span class="c1">See Also: Oracle Database Net Services Administrator&#39;s Guide to</span></p><p class="c0"><span class="c1">learn how to configure dispatchers</span></p><p class="c0"><span class="c1">See Also: Oracle Database Net Services Administrator&#39;s Guide for the</span></p><p class="c0"><span class="c1">proper connect string syntaxOverview of the Program Interface</span></p><p class="c0"><span class="c1">Application and Networking Architecture 16-15</span></p><p class="c0"><span class="c1">As shown in Figure 16&ndash;8, when a client requires database access, the connection broker</span></p><p class="c0"><span class="c1">picks up a server process from the pool and hands it off to the client. The client is</span></p><p class="c0"><span class="c1">directly connected to the server process until the request is served. After the server has</span></p><p class="c0"><span class="c1">finished, the server process is released into the pool. The connection from the client is</span></p><p class="c0"><span class="c1">restored to the broker.</span></p><p class="c0"><span class="c1">Figure 16&ndash;8 DRCP</span></p><p class="c0"><span class="c1">In DRCP, releasing resources leaves the session intact, but no longer associated with a</span></p><p class="c0"><span class="c1">connection (server process). Unlike in shared server, this session stores its UGA in the</span></p><p class="c0"><span class="c1">PGA, not in the SGA. A client can reestablish a connection transparently upon</span></p><p class="c0"><span class="c1">detecting activity.</span></p><p class="c0"><span class="c1">Overview of the Program Interface</span></p><p class="c0"><span class="c1">The program interface is the software layer between a database application and Oracle</span></p><p class="c0"><span class="c1">Database. The program interface performs the following functions:</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Connections and Sessions&quot; on page 15-4</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide and Oracle Call Interface</span></p><p class="c0"><span class="c1">Programmer&#39;s Guide to learn more about DRCP</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">Instance</span></p><p class="c0"><span class="c1">Middle</span></p><p class="c0"><span class="c1">Tier</span></p><p class="c0"><span class="c1">Connection</span></p><p class="c0"><span class="c1">Broker</span></p><p class="c0"><span class="c1">Server</span></p><p class="c0"><span class="c1">Process</span></p><p class="c0"><span class="c1">Server</span></p><p class="c0"><span class="c1">Process</span></p><p class="c0"><span class="c1">handoff</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">Server</span></p><p class="c0"><span class="c1">Middle Tier</span></p><p class="c0"><span class="c1">Client</span></p><p class="c0"><span class="c1">Middle-Tier</span></p><p class="c0"><span class="c1">Process</span></p><p class="c0"><span class="c1">Persistent connections to</span></p><p class="c0"><span class="c1">Connection Broker</span></p><p class="c0"><span class="c1">After Handoff-Direct</span></p><p class="c0"><span class="c1">connection</span></p><p class="c0"><span class="c1">Middle-Tier</span></p><p class="c0"><span class="c1">ProcessOverview of the Program Interface</span></p><p class="c0"><span class="c1">16-16 Oracle Database Concepts</span></p><p class="c0"><span class="c1">&#9632; Provides a security barrier, preventing destructive access to the SGA by client</span></p><p class="c0"><span class="c1">client processes</span></p><p class="c0"><span class="c1">&#9632; Acts as a communication mechanism, formatting information requests, passing</span></p><p class="c0"><span class="c1">data, and trapping and returning errors</span></p><p class="c0"><span class="c1">&#9632; Converts and translates data, particularly between different types of computers or</span></p><p class="c0"><span class="c1">to external user program data types</span></p><p class="c0"><span class="c1">The Oracle code acts as a server, performing database tasks on behalf of an</span></p><p class="c0"><span class="c1">application (a client), such as fetching rows from data blocks. The program interface</span></p><p class="c0"><span class="c1">consists of several parts, provided by both Oracle Database software and operating</span></p><p class="c0"><span class="c1">system-specific software.</span></p><p class="c0"><span class="c1">Program Interface Structure</span></p><p class="c0"><span class="c1">The program interface consists of the following pieces:</span></p><p class="c0"><span class="c1">&#9632; Oracle call interface (OCI) or the Oracle run-time library (SQLLIB)</span></p><p class="c0"><span class="c1">&#9632; The client or user side of the program interface</span></p><p class="c0"><span class="c1">&#9632; Various Oracle Net Services drivers (protocol-specific communications software)</span></p><p class="c0"><span class="c1">&#9632; Operating system communications software</span></p><p class="c0"><span class="c1">&#9632; The server or Oracle Database side of the program interface (also called the OPI)</span></p><p class="c0"><span class="c1">The user and Oracle Database sides of the program interface run Oracle software, as</span></p><p class="c0"><span class="c1">do the drivers.</span></p><p class="c0"><span class="c1">Program Interface Drivers</span></p><p class="c0"><span class="c1">Drivers are pieces of software that transport data, usually across a network. They</span></p><p class="c0"><span class="c1">perform operations such as connect, disconnect, signal errors, and test for errors.</span></p><p class="c0"><span class="c1">Drivers are specific to a communications protocol.</span></p><p class="c0"><span class="c1">There is always a default driver. You can install multiple drivers, such as the</span></p><p class="c0"><span class="c1">asynchronous or DECnet drivers, and select one as the default driver, but allow a user</span></p><p class="c0"><span class="c1">to use other drivers by specifying a driver when connecting.</span></p><p class="c0"><span class="c1">Different processes can use different drivers. A process can have concurrent</span></p><p class="c0"><span class="c1">connections to a single database or to multiple databases using different Oracle Net</span></p><p class="c0"><span class="c1">Services drivers.</span></p><p class="c0"><span class="c1">Communications Software for the Operating System</span></p><p class="c0"><span class="c1">The lowest-level software connecting the user side to the Oracle Database side of the</span></p><p class="c0"><span class="c1">program interface is the communications software, which is provided by the host</span></p><p class="c0"><span class="c1">operating system. DECnet, TCP/IP, LU6.2, and ASYNC are examples. The</span></p><p class="c0"><span class="c1">communication software can be supplied by Oracle, but it is usually purchased</span></p><p class="c0"><span class="c1">separately from the hardware vendor or a third-party software supplier.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Your system installation and configuration guide for details about</span></p><p class="c0"><span class="c1">choosing, installing, and adding drivers</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Net Services Administrator&#39;s Guide to learn about</span></p><p class="c0"><span class="c1">JDBC driversPart VI</span></p><p class="c0"><span class="c1">Part VIOracle Database Administration and</span></p><p class="c0"><span class="c1">Development</span></p><p class="c0"><span class="c1">This part describes summarizes topics that are essential for database administrators</span></p><p class="c0"><span class="c1">and developers.</span></p><p class="c0"><span class="c1">This part contains the following chapters:</span></p><p class="c0"><span class="c1">&#9632; Chapter 17, &quot;Topics for Database Administrators and Developers&quot;</span></p><p class="c0"><span class="c1">&#9632; Chapter 18, &quot;Concepts for Database Administrators&quot;</span></p><p class="c0"><span class="c1">&#9632; Chapter 19, &quot;Concepts for Database Developers&quot;17</span></p><p class="c0"><span class="c1">Topics for Database Administrators and Developers 17-1</span></p><p class="c0"><span class="c1">Topics for Database Administrators and 7 1</span></p><p class="c0"><span class="c1">Developers</span></p><p class="c0"><span class="c1">The previous parts of this manual described the basic architecture of Oracle Database.</span></p><p class="c0"><span class="c1">This chapter summarizes common database topics that are important for both</span></p><p class="c0"><span class="c1">database administrators and developers, and provides pointers to other manuals, not</span></p><p class="c0"><span class="c1">an exhaustive account of database features.</span></p><p class="c0"><span class="c1">This chapter contains the following sections:</span></p><p class="c0"><span class="c1">&#9632; Overview of Database Security</span></p><p class="c0"><span class="c1">&#9632; Overview of High Availability</span></p><p class="c0"><span class="c1">&#9632; Overview of Grid Computing</span></p><p class="c0"><span class="c1">&#9632; Overview of Data Warehousing and Business Intelligence</span></p><p class="c0"><span class="c1">&#9632; Overview of Oracle Information Integration</span></p><p class="c0"><span class="c1">Overview of Database Security</span></p><p class="c0"><span class="c1">In general, database security involves user authentication, encryption, access control,</span></p><p class="c0"><span class="c1">and monitoring.</span></p><p class="c0"><span class="c1">User Accounts</span></p><p class="c0"><span class="c1">Each Oracle database has a list of valid database users. The database contains several</span></p><p class="c0"><span class="c1">default accounts, including the default administrative account SYSTEM (see &quot;SYS and</span></p><p class="c0"><span class="c1">SYSTEM Schemas&quot; on page 2-5). You can create user accounts as needed.</span></p><p class="c0"><span class="c1">To access a database, a user must provide a valid user name and authentication</span></p><p class="c0"><span class="c1">credential. The credential may be a password, Kerberos ticket, or public key</span></p><p class="c0"><span class="c1">infrastructure (PKI) certificate. You can configure database security to lock accounts</span></p><p class="c0"><span class="c1">based on failed login attempts.</span></p><p class="c0"><span class="c1">Privilege and Role Authorization</span></p><p class="c0"><span class="c1">In general, database access control involves restricting data access and database</span></p><p class="c0"><span class="c1">activities. For example, you can restrict users from querying specified tables or</span></p><p class="c0"><span class="c1">executing specified database commands.</span></p><p class="c0"><span class="c1">See Also: Chapter 18, &quot;Concepts for Database Administrators&quot;</span></p><p class="c0"><span class="c1">discusses topics specific to DBAs. Chapter 19, &quot;Concepts for Database</span></p><p class="c0"><span class="c1">Developers&quot; discusses topics for developers.Overview of Database Security</span></p><p class="c0"><span class="c1">17-2 Oracle Database Concepts</span></p><p class="c0"><span class="c1">A user privilege is the right to run specific SQL statements. Privileges can be divided</span></p><p class="c0"><span class="c1">into the following categories:</span></p><p class="c0"><span class="c1">&#9632; System privilege</span></p><p class="c0"><span class="c1">This is the right to perform a specific action in the database, or perform an action</span></p><p class="c0"><span class="c1">on any objects of a specific type. For example, CREATE USER and CREATE SESSION</span></p><p class="c0"><span class="c1">are system privileges.</span></p><p class="c0"><span class="c1">&#9632; Object privilege</span></p><p class="c0"><span class="c1">This is the right to perform a specific action on an object, for example, query the</span></p><p class="c0"><span class="c1">employees table. Privilege types are defined by the database.</span></p><p class="c0"><span class="c1">Privileges are granted to users at the discretion of other users. Administrators should</span></p><p class="c0"><span class="c1">grant privileges to users so they can accomplish tasks required for their jobs. Good</span></p><p class="c0"><span class="c1">security practice involves granting a privilege only to a user who requires that</span></p><p class="c0"><span class="c1">privilege to accomplish the necessary work.</span></p><p class="c0"><span class="c1">A role is a named group of related privileges that you grant to users or other roles. A</span></p><p class="c0"><span class="c1">role helps manage privileges for a database application or user group.</span></p><p class="c0"><span class="c1">Figure 17&ndash;1 depicts a common use for roles. The roles PAY_CLERK, MANAGER, and</span></p><p class="c0"><span class="c1">REC_CLERK are assigned to different users. The application role ACCTS_PAY, which</span></p><p class="c0"><span class="c1">includes the privilege to execute the ACCTS_PAY application, is assigned to users with</span></p><p class="c0"><span class="c1">the PAY_CLERK and MANAGER role. The application role ACCTS_REC, which includes the</span></p><p class="c0"><span class="c1">privilege to execute the ACCTS_REC application, is assigned to users with the REC_CLERK</span></p><p class="c0"><span class="c1">and MANAGER role.</span></p><p class="c0"><span class="c1">Figure 17&ndash;1 Common Uses for Roles</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database 2 Day + Security Guide and Oracle Database Security</span></p><p class="c0"><span class="c1">Guide to learn how to manage privileges</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Security Guide to learn about using roles for</span></p><p class="c0"><span class="c1">security</span></p><p class="c0"><span class="c1">&#9632; Oracle Database 2 Day DBA and Oracle Database Administrator&#39;s</span></p><p class="c0"><span class="c1">Guide to learn how to administer roles</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Reference to learn about the SESSION_PRIVS view</span></p><p class="c0"><span class="c1">PAY_CLERK Role MANAGER Role REC_CLERK Role</span></p><p class="c0"><span class="c1">ACCTS_PAY Role ACCTS_REC Role</span></p><p class="c0"><span class="c1">User Roles</span></p><p class="c0"><span class="c1">Application Roles</span></p><p class="c0"><span class="c1">Application Privileges</span></p><p class="c0"><span class="c1">Privileges to</span></p><p class="c0"><span class="c1">execute the</span></p><p class="c0"><span class="c1">ACCTS_PAY</span></p><p class="c0"><span class="c1">application</span></p><p class="c0"><span class="c1">Privileges to</span></p><p class="c0"><span class="c1">execute the</span></p><p class="c0"><span class="c1">ACCTS_REC</span></p><p class="c0"><span class="c1">application</span></p><p class="c0"><span class="c1">UsersOverview of Database Security</span></p><p class="c0"><span class="c1">Topics for Database Administrators and Developers 17-3</span></p><p class="c0"><span class="c1">Profiles</span></p><p class="c0"><span class="c1">In the context of system resources, a user profile is a named set of resource limits and</span></p><p class="c0"><span class="c1">password parameters that restrict database usage and instance resources for a user.</span></p><p class="c0"><span class="c1">Profiles can limit the number of concurrent sessions for a user, CPU processing time</span></p><p class="c0"><span class="c1">available for each session, and amount of logical I/O available (see &quot;Buffer I/O&quot; on</span></p><p class="c0"><span class="c1">page 14-10). For example, the clerk profile could limit a user to system resources</span></p><p class="c0"><span class="c1">required for clerical tasks.</span></p><p class="c0"><span class="c1">Profiles provide a single point of reference for users that share a set of attributes. You</span></p><p class="c0"><span class="c1">can assign a profile to one set of users, and a default profile to all others. Each user has</span></p><p class="c0"><span class="c1">at most one profile assigned at any point in time.</span></p><p class="c0"><span class="c1">Authentication</span></p><p class="c0"><span class="c1">In Oracle Database, database authentication is the process by which a user presents</span></p><p class="c0"><span class="c1">credentials to the database, which verifies the credentials and allows access to the</span></p><p class="c0"><span class="c1">database. Validating the identity establishes a trust relationship for further</span></p><p class="c0"><span class="c1">interactions. Authentication also enables accountability by making it possible to link</span></p><p class="c0"><span class="c1">access and actions to specific identities.</span></p><p class="c0"><span class="c1">Oracle Database provides different authentication methods, including the following:</span></p><p class="c0"><span class="c1">&#9632; Authentication by the database</span></p><p class="c0"><span class="c1">Oracle database can authenticate users using a password, Kerberos ticket, or PKI</span></p><p class="c0"><span class="c1">certificate. Oracle also supports RADIUS-compliant devices for other forms of</span></p><p class="c0"><span class="c1">authentication, including biometrics. The type of authentication must be specified</span></p><p class="c0"><span class="c1">when a user is created in the Oracle database.</span></p><p class="c0"><span class="c1">&#9632; Authentication by the operating system</span></p><p class="c0"><span class="c1">Some operating systems permit Oracle Database to use information they maintain</span></p><p class="c0"><span class="c1">to authenticate users. After being authenticated by the operating system, users can</span></p><p class="c0"><span class="c1">connect to a database without specifying a user name or password.</span></p><p class="c0"><span class="c1">Database operations such as shutting down or starting up the database should not be</span></p><p class="c0"><span class="c1">performed by non-administrative database users. These operations require SYSDBA or</span></p><p class="c0"><span class="c1">SYSOPER privileges (see &quot;Connection with Administrator Privileges&quot; on page 13-6).</span></p><p class="c0"><span class="c1">Note: It is preferable to use Database Resource Manager to limit</span></p><p class="c0"><span class="c1">resources and to use profiles to manage passwords.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Security Guide to learn how to manage resources</span></p><p class="c0"><span class="c1">with profiles</span></p><p class="c0"><span class="c1">&#9632; Oracle Database SQL Language Reference for CREATE PROFILE syntax</span></p><p class="c0"><span class="c1">and semantics</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Security Guide and Oracle Database Advanced</span></p><p class="c0"><span class="c1">Security Administrator&#39;s Guide for more information about</span></p><p class="c0"><span class="c1">authentication methods</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn about administrative</span></p><p class="c0"><span class="c1">authenticationOverview of Database Security</span></p><p class="c0"><span class="c1">17-4 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Encryption</span></p><p class="c0"><span class="c1">In general, encryption is the process of transforming data into an unreadable format</span></p><p class="c0"><span class="c1">using a secret key and an encryption algorithm. Encryption is often used to meet</span></p><p class="c0"><span class="c1">regulatory compliance requirements, such as those associated with the Payment Card</span></p><p class="c0"><span class="c1">Industry Data Security Standard (PCI-DSS) or breach notification laws. For example,</span></p><p class="c0"><span class="c1">credit card numbers, social security numbers, or patient health information must be</span></p><p class="c0"><span class="c1">encrypted.</span></p><p class="c0"><span class="c1">Network Encryption</span></p><p class="c0"><span class="c1">Encrypting data as it travels across a network between a client and server is known as</span></p><p class="c0"><span class="c1">network encryption. An intruder can use a network packet sniffer to capture</span></p><p class="c0"><span class="c1">information as it travels on the network, and then spool it to a file for malicious use.</span></p><p class="c0"><span class="c1">Encrypting data on the network prevents this sort of activity.</span></p><p class="c0"><span class="c1">Transparent Data Encryption</span></p><p class="c0"><span class="c1">Oracle Advanced Security Transparent Data Encryption enables you to encrypt</span></p><p class="c0"><span class="c1">individual table columns or a tablespace. When a user inserts data into an encrypted</span></p><p class="c0"><span class="c1">column, the database automatically encrypts the data. When users select the column,</span></p><p class="c0"><span class="c1">the data is decrypted. This form of encryption is transparent, provides high</span></p><p class="c0"><span class="c1">performance, and is easy to implement.</span></p><p class="c0"><span class="c1">Transparent data encryption includes industry-standard encryption algorithms such as</span></p><p class="c0"><span class="c1">the Advanced Encryption Standard (AES) and built-in key management.</span></p><p class="c0"><span class="c1">Oracle Data Redaction</span></p><p class="c0"><span class="c1">Starting in Oracle Database 11g Release 2 (11.2.0.4), Oracle Data Redaction enables</span></p><p class="c0"><span class="c1">you to mask (redact) data that is queried by low-privileged users or applications. The</span></p><p class="c0"><span class="c1">redaction occurs in real time when users query the data. Oracle Data Redaction is a</span></p><p class="c0"><span class="c1">part of Oracle Advanced Security.</span></p><p class="c0"><span class="c1">Data redaction supports the following redaction function types:</span></p><p class="c0"><span class="c1">&#9632; Full data redaction</span></p><p class="c0"><span class="c1">In this case, the database redacts the entire contents of the specified columns in a</span></p><p class="c0"><span class="c1">table or view. For example, a VARCHAR2 column for a last name displays a single</span></p><p class="c0"><span class="c1">space.</span></p><p class="c0"><span class="c1">&#9632; Partial data redaction</span></p><p class="c0"><span class="c1">In this case, the database redacts portions of the displayed output. For example, an</span></p><p class="c0"><span class="c1">application can present a credit card number ending in 1234 as</span></p><p class="c0"><span class="c1">xxxx-xxxx-xxxx-1234. You can use regular expressions for both full and partial</span></p><p class="c0"><span class="c1">redaction. A regular expression can redact data based on a search pattern. For</span></p><p class="c0"><span class="c1">example, you can use regular expressions to redact specific phone numbers or</span></p><p class="c0"><span class="c1">email addresses.</span></p><p class="c0"><span class="c1">&#9632; Random data redaction</span></p><p class="c0"><span class="c1">In this case, the database displays the data as randomly generated values,</span></p><p class="c0"><span class="c1">depending on the data type of the column. For example, the number 1234567 can</span></p><p class="c0"><span class="c1">appear as 83933895.</span></p><p class="c0"><span class="c1">See Also: Oracle Database 2 Day + Security Guide and Oracle Database</span></p><p class="c0"><span class="c1">Advanced Security Administrator&#39;s GuideOverview of Database Security</span></p><p class="c0"><span class="c1">Topics for Database Administrators and Developers 17-5</span></p><p class="c0"><span class="c1">Data redaction is not a comprehensive security solution. For example, it does not</span></p><p class="c0"><span class="c1">prevent directly connected, privileged users from performing inference attacks on</span></p><p class="c0"><span class="c1">redacted data. Such attacks identify redacted columns and, by process of elimination,</span></p><p class="c0"><span class="c1">try to back into actual data by repeating SQL queries that guess at stored values. To</span></p><p class="c0"><span class="c1">detect and prevent inference and other attacks originating from privileged users,</span></p><p class="c0"><span class="c1">Oracle recommends pairing Oracle Data Redaction with related database security</span></p><p class="c0"><span class="c1">products such as Oracle Audit Vault and Database Firewall, and Oracle Database</span></p><p class="c0"><span class="c1">Vault.</span></p><p class="c0"><span class="c1">Data redaction works as follows:</span></p><p class="c0"><span class="c1">&#9632; Use the DBMS_REDACT package to create a redaction policy for a specified table.</span></p><p class="c0"><span class="c1">&#9632; In the policy, specify a predefined redaction function.</span></p><p class="c0"><span class="c1">&#9632; Whether the database shows the actual or redacted value of a column depends on</span></p><p class="c0"><span class="c1">the policy. If the data is redacted, then the redaction occurs at the top-level select</span></p><p class="c0"><span class="c1">list immediately before display to the user.</span></p><p class="c0"><span class="c1">The following example adds a full data redaction policy to redact the employee_id</span></p><p class="c0"><span class="c1">column of the hr.employees table:</span></p><p class="c0"><span class="c1">BEGIN</span></p><p class="c0"><span class="c1">DBMS_REDACT.ADD_POLICY(</span></p><p class="c0"><span class="c1">object_schema =&gt; &#39;hr&#39;</span></p><p class="c0"><span class="c1">, object_name =&gt; &#39;employees&#39;</span></p><p class="c0"><span class="c1">, column_name =&gt; &#39;employee_id&#39;</span></p><p class="c0"><span class="c1">, policy_name =&gt; &#39;mask_emp_ids&#39;</span></p><p class="c0"><span class="c1">, function_type =&gt; DBMS_REDACT.FULL</span></p><p class="c0"><span class="c1">, expression =&gt; &#39;1=1&#39;</span></p><p class="c0"><span class="c1">);</span></p><p class="c0"><span class="c1">END;</span></p><p class="c0"><span class="c1">/</span></p><p class="c0"><span class="c1">In the preceding example, the expression setting, which evaluates to true, applies the</span></p><p class="c0"><span class="c1">redaction to users who are not granted the EXEMPT REDACTION POLICY privilege.</span></p><p class="c0"><span class="c1">Access Control</span></p><p class="c0"><span class="c1">Oracle Database provides many techniques to control access to data. This section</span></p><p class="c0"><span class="c1">summarizes some of these techniques.</span></p><p class="c0"><span class="c1">Oracle Database Vault</span></p><p class="c0"><span class="c1">Oracle Database Vault is a security option that restricts privileged user access to</span></p><p class="c0"><span class="c1">application data. You can use Oracle Database Vault to control when, where, and how</span></p><p class="c0"><span class="c1">the databases, data, and applications are accessed. Thus, you can address common</span></p><p class="c0"><span class="c1">security problems such as protecting against insider threats, complying with</span></p><p class="c0"><span class="c1">regulatory requirements, and enforcing separation of duty.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Advanced Security Administrator&#39;s Guide to learn</span></p><p class="c0"><span class="c1">about data redaction</span></p><p class="c0"><span class="c1">&#9632; Oracle Database PL/SQL Packages and Types Reference to learn about</span></p><p class="c0"><span class="c1">DBMS_REDACT</span></p><p class="c0"><span class="c1">See Also: Oracle Database 2 Day + Security Guide and Oracle Database</span></p><p class="c0"><span class="c1">Vault Administrator&#39;s GuideOverview of Database Security</span></p><p class="c0"><span class="c1">17-6 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Virtual Private Database (VPD)</span></p><p class="c0"><span class="c1">Oracle Virtual Private Database (VPD) enables you to enforce security at the row and</span></p><p class="c0"><span class="c1">column level. A security policy establishes methods for protecting a database from</span></p><p class="c0"><span class="c1">accidental or malicious destruction of data or damage to the database infrastructure.</span></p><p class="c0"><span class="c1">VPD is useful when security protections such as privileges and roles are not</span></p><p class="c0"><span class="c1">sufficiently fine-grained. For example, you can allow all users to access the employees</span></p><p class="c0"><span class="c1">table, but create security policies to restrict access to employees in the same</span></p><p class="c0"><span class="c1">department as the user.</span></p><p class="c0"><span class="c1">Essentially, the database adds a dynamic WHERE clause to a SQL statement issued</span></p><p class="c0"><span class="c1">against the table, view, or synonym to which an Oracle VPD security policy was</span></p><p class="c0"><span class="c1">applied. The WHERE clause allows only users whose credentials pass the security policy</span></p><p class="c0"><span class="c1">to access the protected data.</span></p><p class="c0"><span class="c1">Oracle Label Security (OLS)</span></p><p class="c0"><span class="c1">Oracle Label Security (OLS) is a security option that enables you to assign data</span></p><p class="c0"><span class="c1">classification and control access using security labels. You can assign a label to both</span></p><p class="c0"><span class="c1">data and users.</span></p><p class="c0"><span class="c1">When assigned to data, the label can be attached as a hidden column to existing tables,</span></p><p class="c0"><span class="c1">providing transparency to existing SQL. For example, rows that contain highly</span></p><p class="c0"><span class="c1">sensitive data can be labeled HIGHLY SENSITIVE, while rows that are less sensitive can</span></p><p class="c0"><span class="c1">be labeled SENSITIVE, and so on. When a user attempts to access data, OLS compares</span></p><p class="c0"><span class="c1">the user label with the data label and determines whether access should be granted.</span></p><p class="c0"><span class="c1">Unlike VPD, OLS provides an out-of-the-box security policy and the metadata</span></p><p class="c0"><span class="c1">repository for defining and storing labels.</span></p><p class="c0"><span class="c1">Monitoring</span></p><p class="c0"><span class="c1">Oracle Database provides multiple tools and techniques for monitoring user activity.</span></p><p class="c0"><span class="c1">Database Auditing</span></p><p class="c0"><span class="c1">Database auditing is the monitoring and recording of selected user database actions.</span></p><p class="c0"><span class="c1">You can use standard auditing to audit SQL statements, privileges, schemas, objects,</span></p><p class="c0"><span class="c1">and network and multitier activity. Alternatively, you can use fine-grained auditing to</span></p><p class="c0"><span class="c1">monitor specific database activities, such as actions on a database table or times that</span></p><p class="c0"><span class="c1">activities occur. For example, you can audit a table accessed after 9:00 p.m.</span></p><p class="c0"><span class="c1">Reasons for using auditing include:</span></p><p class="c0"><span class="c1">&#9632; Enabling future accountability for current actions</span></p><p class="c0"><span class="c1">&#9632; Deterring users (or others, such as intruders) from inappropriate actions based on</span></p><p class="c0"><span class="c1">their accountability</span></p><p class="c0"><span class="c1">&#9632; Investigating, monitoring, and recording suspicious activity</span></p><p class="c0"><span class="c1">&#9632; Addressing auditing requirements for compliance</span></p><p class="c0"><span class="c1">See Also: Oracle Database 2 Day + Security Guide and Oracle Database</span></p><p class="c0"><span class="c1">Security Guide</span></p><p class="c0"><span class="c1">See Also: Oracle Database 2 Day + Security Guide and Oracle Label</span></p><p class="c0"><span class="c1">Security Administrator&#39;s GuideOverview of High Availability</span></p><p class="c0"><span class="c1">Topics for Database Administrators and Developers 17-7</span></p><p class="c0"><span class="c1">Oracle Audit Vault and Database Firewall</span></p><p class="c0"><span class="c1">Oracle Audit Vault and Database Firewall (Oracle AVDF) provide a first line of defense</span></p><p class="c0"><span class="c1">for databases and consolidate audit data from databases, operating systems, and</span></p><p class="c0"><span class="c1">directories. A SQL grammar-based engine monitors and blocks unauthorized SQL</span></p><p class="c0"><span class="c1">traffic before it reaches the database. For compliance reporting and alerting, Oracle</span></p><p class="c0"><span class="c1">AVDF combines database activity data from the network with detailed audit data. You</span></p><p class="c0"><span class="c1">can tailor auditing and monitoring controls to meet enterprise security requirements.</span></p><p class="c0"><span class="c1">Enterprise Manager Auditing Support</span></p><p class="c0"><span class="c1">Oracle Enterprise Manager (Enterprise Manager) enables you to view and configure</span></p><p class="c0"><span class="c1">audit-related initialization parameters. Also, you can administer objects when auditing</span></p><p class="c0"><span class="c1">statements and schema objects. For example, Enterprise Manager enables you to</span></p><p class="c0"><span class="c1">display and search for the properties of current audited statements, privileges, and</span></p><p class="c0"><span class="c1">objects. You can enable and disable auditing as needed.</span></p><p class="c0"><span class="c1">Overview of High Availability</span></p><p class="c0"><span class="c1">Availability is the degree to which an application, service, or functionality is available</span></p><p class="c0"><span class="c1">on demand. For example, an OLTP database used by an online bookseller is available</span></p><p class="c0"><span class="c1">to the extent that it is accessible by customers making purchases. Reliability,</span></p><p class="c0"><span class="c1">recoverability, timely error detection, and continuous operations are the primary</span></p><p class="c0"><span class="c1">characteristics of high availability.</span></p><p class="c0"><span class="c1">The importance of high availability in a database environment is tied to the cost of</span></p><p class="c0"><span class="c1">downtime, which is the time that a resource is unavailable. Downtime can be</span></p><p class="c0"><span class="c1">categorized as either planned or unplanned. The main challenge when designing a</span></p><p class="c0"><span class="c1">highly available environment is examining all possible causes of downtime and</span></p><p class="c0"><span class="c1">developing a plan to deal with them.</span></p><p class="c0"><span class="c1">High Availability and Unplanned Downtime</span></p><p class="c0"><span class="c1">Oracle Database provides high availability solutions to prevent, tolerate, and reduce</span></p><p class="c0"><span class="c1">downtime for all types of unplanned failures. Unplanned downtime can be</span></p><p class="c0"><span class="c1">categorized by its causes:</span></p><p class="c0"><span class="c1">&#9632; Site Failures</span></p><p class="c0"><span class="c1">&#9632; Computer Failures</span></p><p class="c0"><span class="c1">&#9632; Storage Failures</span></p><p class="c0"><span class="c1">&#9632; Data Corruption</span></p><p class="c0"><span class="c1">&#9632; Human Errors</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database 2 Day + Security Guide and Oracle Database</span></p><p class="c0"><span class="c1">Security Guide to learn how to enable and disable auditing</span></p><p class="c0"><span class="c1">&#9632; Oracle Label Security Administrator&#39;s Guide to learn about Oracle</span></p><p class="c0"><span class="c1">Label Security auditing, which supplements standard auditing</span></p><p class="c0"><span class="c1">See Also: Oracle Audit Vault and Database Firewall Administrator&#39;s</span></p><p class="c0"><span class="c1">Guide</span></p><p class="c0"><span class="c1">See Also: Oracle Database High Availability Overview for an</span></p><p class="c0"><span class="c1">introduction to high availabilityOverview of High Availability</span></p><p class="c0"><span class="c1">17-8 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Site Failures</span></p><p class="c0"><span class="c1">A site failure occurs when an event causes all or a significant portion of an application</span></p><p class="c0"><span class="c1">to stop processing or slow to an unusable service level. A site failure may affect all</span></p><p class="c0"><span class="c1">processing at a data center, or a subset of applications supported by a data center.</span></p><p class="c0"><span class="c1">Examples include an extended site-wide power or network failure, a natural disaster</span></p><p class="c0"><span class="c1">making a data center inoperable, or a malicious attack on operations or the site.</span></p><p class="c0"><span class="c1">The simplest form of protection against site failures is to create database backups using</span></p><p class="c0"><span class="c1">RMAN and store them offsite. You can restore the database to another host. However,</span></p><p class="c0"><span class="c1">this technique can be time-consuming, and the backup may not be current.</span></p><p class="c0"><span class="c1">Maintaining one or more standby databases in a Data Guard environment enables you</span></p><p class="c0"><span class="c1">to provide continuous database service if the production site fails.</span></p><p class="c0"><span class="c1">Computer Failures</span></p><p class="c0"><span class="c1">A computer failure outage occurs when the system running the database becomes</span></p><p class="c0"><span class="c1">unavailable because it has shut down or is no longer accessible. Examples of</span></p><p class="c0"><span class="c1">computers failures include hardware and operating system failures.</span></p><p class="c0"><span class="c1">The following Oracle features protect against or help respond to computer failures:</span></p><p class="c0"><span class="c1">&#9632; Enterprise Grids</span></p><p class="c0"><span class="c1">In an Oracle Real Applications Cluster (Oracle RAC) environment, Oracle</span></p><p class="c0"><span class="c1">Database runs on two or more systems in a cluster while concurrently accessing a</span></p><p class="c0"><span class="c1">single shared database. A single database system spans multiple hardware</span></p><p class="c0"><span class="c1">systems yet appears to the application as a single database. See &quot;Overview of Grid</span></p><p class="c0"><span class="c1">Computing&quot; on page 17-12.</span></p><p class="c0"><span class="c1">&#9632; Oracle Data Guard</span></p><p class="c0"><span class="c1">Data Guard enables you to maintain a copy of a production database, called a</span></p><p class="c0"><span class="c1">standby database, that can reside on a different continent or in the same data</span></p><p class="c0"><span class="c1">center. If the primary database is unavailable because of an outage, then Data</span></p><p class="c0"><span class="c1">Guard can switch any standby database to the primary role, minimizing</span></p><p class="c0"><span class="c1">downtime. See Oracle Data Guard Concepts and Administration.</span></p><p class="c0"><span class="c1">&#9632; Oracle Restart</span></p><p class="c0"><span class="c1">Components in the Oracle Database software stack, including the database</span></p><p class="c0"><span class="c1">instance, listener, and Oracle ASM instance, can restart automatically after a</span></p><p class="c0"><span class="c1">component failure or whenever the database host computer restarts. Oracle</span></p><p class="c0"><span class="c1">Restart ensures that Oracle components are started in the proper order, in</span></p><p class="c0"><span class="c1">accordance with component dependencies. See Oracle Database Administrator&#39;s</span></p><p class="c0"><span class="c1">Guide to learn how to configure Oracle Restart.</span></p><p class="c0"><span class="c1">&#9632; Fast Start Fault Recovery</span></p><p class="c0"><span class="c1">See Also: Oracle Database High Availability Overview to learn about</span></p><p class="c0"><span class="c1">protecting against unplanned downtime</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database High Availability Overview to learn about site</span></p><p class="c0"><span class="c1">failures</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Backup and Recovery User&#39;s Guide for information</span></p><p class="c0"><span class="c1">on RMAN and backup and recovery solutions</span></p><p class="c0"><span class="c1">&#9632; Oracle Data Guard Concepts and Administration for an introduction</span></p><p class="c0"><span class="c1">to standby databasesOverview of High Availability</span></p><p class="c0"><span class="c1">Topics for Database Administrators and Developers 17-9</span></p><p class="c0"><span class="c1">A common cause of unplanned downtime is a system fault or crash. The fast start</span></p><p class="c0"><span class="c1">fault recovery technology in Oracle Database automatically bounds database</span></p><p class="c0"><span class="c1">instance recovery time. See Oracle Database Performance Tuning Guide for</span></p><p class="c0"><span class="c1">information on fast start fault recovery.</span></p><p class="c0"><span class="c1">Storage Failures</span></p><p class="c0"><span class="c1">A storage failure outage occurs when the storage holding some or all of the database</span></p><p class="c0"><span class="c1">contents becomes unavailable because it has shut down or is no longer accessible.</span></p><p class="c0"><span class="c1">Examples of storage failures include the failure of a disk drive or storage array.</span></p><p class="c0"><span class="c1">In addition to Oracle Data Guard, solutions for storage failures include the following:</span></p><p class="c0"><span class="c1">&#9632; Oracle Automatic Storage Management (Oracle ASM)</span></p><p class="c0"><span class="c1">Oracle ASM is a vertically integrated file system and volume manager in the</span></p><p class="c0"><span class="c1">database kernel (see &quot;Oracle Automatic Storage Management (Oracle ASM)&quot; on</span></p><p class="c0"><span class="c1">page 11-3). Oracle ASM eliminates the complexity associated with managing data</span></p><p class="c0"><span class="c1">and disks, and simplifies mirroring and the process of adding and removing disks.</span></p><p class="c0"><span class="c1">&#9632; Backup and recovery</span></p><p class="c0"><span class="c1">The Recovery Manager (RMAN) utility can back up data, restore data from a</span></p><p class="c0"><span class="c1">previous backup, and recover changes to that data up to the time before the failure</span></p><p class="c0"><span class="c1">occurred (see &quot;Backup and Recovery&quot; on page 18-9).</span></p><p class="c0"><span class="c1">Data Corruption</span></p><p class="c0"><span class="c1">A data corruption occurs when a hardware, software or network component causes</span></p><p class="c0"><span class="c1">corrupt data to be read or written. For example, a volume manager error causes bad</span></p><p class="c0"><span class="c1">disk read or writes. Data corruptions are rare but can have a catastrophic effect on a</span></p><p class="c0"><span class="c1">database, and therefore a business.</span></p><p class="c0"><span class="c1">In addition to Data Guard and Recovery Manager, Oracle Database supports the</span></p><p class="c0"><span class="c1">following forms of protection against data corruption:</span></p><p class="c0"><span class="c1">&#9632; Lost write protection</span></p><p class="c0"><span class="c1">A data block lost write occurs when an I/O subsystem acknowledges the</span></p><p class="c0"><span class="c1">completion of the block write when the write did not occur. You can configure the</span></p><p class="c0"><span class="c1">database so that it records buffer cache block reads in the redo log. Lost write</span></p><p class="c0"><span class="c1">detection is most effective when used with Data Guard.</span></p><p class="c0"><span class="c1">&#9632; Data block corruption detection</span></p><p class="c0"><span class="c1">A block corruption is a data block that is not in a recognized Oracle format, or</span></p><p class="c0"><span class="c1">whose contents are not internally consistent. Several database components and</span></p><p class="c0"><span class="c1">utilities, including RMAN, can detect a corrupt block and record it in</span></p><p class="c0"><span class="c1">V$DATABASE_BLOCK_CORRUPTION. If the environment uses a real-time standby</span></p><p class="c0"><span class="c1">database, then RMAN can automatically repair corrupt blocks.</span></p><p class="c0"><span class="c1">See Also: Oracle Database High Availability Best Practices to learn how</span></p><p class="c0"><span class="c1">to use High Availability for processes and applications that run in a</span></p><p class="c0"><span class="c1">single-instance database</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database 2 Day DBA to learn how to administer Oracle</span></p><p class="c0"><span class="c1">ASM disks with Oracle Enterprise Manager (Enterprise</span></p><p class="c0"><span class="c1">Manager)</span></p><p class="c0"><span class="c1">&#9632; Oracle Automatic Storage Management Administrator&#39;s Guide to</span></p><p class="c0"><span class="c1">learn more about Oracle ASMOverview of High Availability</span></p><p class="c0"><span class="c1">17-10 Oracle Database Concepts</span></p><p class="c0"><span class="c1">&#9632; Data Recovery Advisor</span></p><p class="c0"><span class="c1">Data Recovery Advisor is an Oracle tool that automatically diagnoses data</span></p><p class="c0"><span class="c1">failures, determines and presents appropriate repair options, and executes repairs</span></p><p class="c0"><span class="c1">at the user&#39;s request.</span></p><p class="c0"><span class="c1">Human Errors</span></p><p class="c0"><span class="c1">A human error outage occurs when unintentional or malicious actions are committed</span></p><p class="c0"><span class="c1">that cause data in the database to become logically corrupt or unusable. The service</span></p><p class="c0"><span class="c1">level impact of a human error outage can vary significantly depending on the amount</span></p><p class="c0"><span class="c1">and critical nature of the affected data.</span></p><p class="c0"><span class="c1">Much research cites human error as the largest cause of downtime. Oracle Database</span></p><p class="c0"><span class="c1">provides powerful tools to help administrators quickly diagnose and recover from</span></p><p class="c0"><span class="c1">these errors. It also includes features that enable end users to recover from problems</span></p><p class="c0"><span class="c1">without administrator involvement.</span></p><p class="c0"><span class="c1">Oracle Database recommends the following forms of protection against human error:</span></p><p class="c0"><span class="c1">&#9632; Restriction of user access</span></p><p class="c0"><span class="c1">The best way to prevent errors is to restrict user access to data and services. Oracle</span></p><p class="c0"><span class="c1">Database provides a wide range of security tools to control user access to</span></p><p class="c0"><span class="c1">application data by authenticating users and then allowing administrators to grant</span></p><p class="c0"><span class="c1">users only those privileges required to perform their duties (see &quot;Overview of</span></p><p class="c0"><span class="c1">Database Security&quot; on page 17-1).</span></p><p class="c0"><span class="c1">&#9632; Oracle Flashback Technology</span></p><p class="c0"><span class="c1">Oracle Flashback Technology is a family of human error correction features in</span></p><p class="c0"><span class="c1">Oracle Database. Oracle Flashback provides a SQL interface to quickly analyze</span></p><p class="c0"><span class="c1">and repair human errors. For example, you can perform:</span></p><p class="c0"><span class="c1">&ndash; Fine-grained surgical analysis and repair for localized damage</span></p><p class="c0"><span class="c1">&ndash; Rapid correction of more widespread damage</span></p><p class="c0"><span class="c1">&ndash; Recovery at the row, transaction, table, tablespace, and database level</span></p><p class="c0"><span class="c1">&#9632; Oracle LogMiner</span></p><p class="c0"><span class="c1">Oracle LogMiner is a relational tool that enables online redo log files to be read,</span></p><p class="c0"><span class="c1">analyzed, and interpreted using SQL (see &quot;Oracle LogMiner&quot; on page 18-8).</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database High Availability Best Practices to learn how to</span></p><p class="c0"><span class="c1">protect against data corruptions</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Backup and Recovery User&#39;s Guide for information</span></p><p class="c0"><span class="c1">on RMAN and backup and recovery solutions</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database High Availability Best Practices to learn how to</span></p><p class="c0"><span class="c1">recover from human errors</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Backup and Recovery User&#39;s Guide and Oracle</span></p><p class="c0"><span class="c1">Database Advanced Application Developer&#39;s Guide to learn more</span></p><p class="c0"><span class="c1">about Oracle Flashback features</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Utilities to learn more about Oracle LogMinerOverview of High Availability</span></p><p class="c0"><span class="c1">Topics for Database Administrators and Developers 17-11</span></p><p class="c0"><span class="c1">High Availability and Planned Downtime</span></p><p class="c0"><span class="c1">Planned downtime can be just as disruptive to operations, especially in global</span></p><p class="c0"><span class="c1">enterprises that support users in multiple time zones. In this case, it is important to</span></p><p class="c0"><span class="c1">design a system to minimize planned interruptions such as routine operations,</span></p><p class="c0"><span class="c1">periodic maintenance, and new deployments.</span></p><p class="c0"><span class="c1">Planned downtime can be categorized by its causes:</span></p><p class="c0"><span class="c1">&#9632; System and Database Changes</span></p><p class="c0"><span class="c1">&#9632; Data Changes</span></p><p class="c0"><span class="c1">&#9632; Application Changes</span></p><p class="c0"><span class="c1">System and Database Changes</span></p><p class="c0"><span class="c1">Planned system changes occur when you perform routine and periodic maintenance</span></p><p class="c0"><span class="c1">operations and new deployments, including scheduled changes to the operating</span></p><p class="c0"><span class="c1">environment that occur outside of the organizational data structure in the database.</span></p><p class="c0"><span class="c1">Examples include adding or removing CPUs and cluster nodes (a node is a computer</span></p><p class="c0"><span class="c1">on which a database instance resides), upgrading system hardware or software, and</span></p><p class="c0"><span class="c1">migrating the system platform.</span></p><p class="c0"><span class="c1">Oracle Database provides dynamic resource provisioning as a solution to planned</span></p><p class="c0"><span class="c1">system and database changes:</span></p><p class="c0"><span class="c1">&#9632; Dynamic reconfiguration of the database</span></p><p class="c0"><span class="c1">Oracle Database dynamically accommodates various changes to hardware and</span></p><p class="c0"><span class="c1">database configurations, including adding and removing processors from an SMP</span></p><p class="c0"><span class="c1">server and adding and remove storage arrays using Oracle ASM. For example,</span></p><p class="c0"><span class="c1">Oracle Database monitors the operating system to detect changes in the number of</span></p><p class="c0"><span class="c1">CPUs. If the CPU_COUNT initialization parameter is set to the default, then the</span></p><p class="c0"><span class="c1">database workload can dynamically take advantage of newly added processors.</span></p><p class="c0"><span class="c1">&#9632; Autotuning memory management</span></p><p class="c0"><span class="c1">Oracle Database uses a noncentralized policy to free and acquire memory in each</span></p><p class="c0"><span class="c1">subcomponent of the SGA and the PGA. Oracle Database autotunes memory by</span></p><p class="c0"><span class="c1">prompting the operating system to transfer granules of memory to components</span></p><p class="c0"><span class="c1">that require it. See &quot;Memory Management&quot; on page 18-15.</span></p><p class="c0"><span class="c1">&#9632; Automated distributions of data files, control files, and online redo log files</span></p><p class="c0"><span class="c1">Oracle ASM automates and simplifies the layout of data files, control files, and log</span></p><p class="c0"><span class="c1">files by automatically distributing them across all available disks. See Oracle</span></p><p class="c0"><span class="c1">Automatic Storage Management Administrator&#39;s Guide to learn more about Oracle</span></p><p class="c0"><span class="c1">ASM.</span></p><p class="c0"><span class="c1">Data Changes</span></p><p class="c0"><span class="c1">Planned data changes occur when there are changes to the logical structure or</span></p><p class="c0"><span class="c1">physical organization of Oracle Database objects. The primary objective of these</span></p><p class="c0"><span class="c1">changes is to improve performance or manageability. Examples include table</span></p><p class="c0"><span class="c1">redefinition, adding table partitions, and creating or rebuilding indexes.</span></p><p class="c0"><span class="c1">Oracle Database minimizes downtime for data changes through online reorganization</span></p><p class="c0"><span class="c1">and redefinition. This architecture enables you to perform the following tasks when</span></p><p class="c0"><span class="c1">the database is open:</span></p><p class="c0"><span class="c1">See Also: Oracle Database High Availability Overview to learn about</span></p><p class="c0"><span class="c1">features and solutions for planned downtimeOverview of Grid Computing</span></p><p class="c0"><span class="c1">17-12 Oracle Database Concepts</span></p><p class="c0"><span class="c1">&#9632; Perform online table redefinition, which enables you to make table structure</span></p><p class="c0"><span class="c1">modifications without significantly affecting the availability of the table</span></p><p class="c0"><span class="c1">&#9632; Create, analyze, and reorganize indexes (see Chapter 3, &quot;Indexes and</span></p><p class="c0"><span class="c1">Index-Organized Tables&quot;)</span></p><p class="c0"><span class="c1">&#9632; Move table partitions (see &quot;Overview of Partitions&quot; on page 4-1)</span></p><p class="c0"><span class="c1">Application Changes</span></p><p class="c0"><span class="c1">Planned application changes may include changes to data, schemas, and programs.</span></p><p class="c0"><span class="c1">The primary objective of these changes is to improve performance, manageability, and</span></p><p class="c0"><span class="c1">functionality. An example is an application upgrade.</span></p><p class="c0"><span class="c1">Oracle Database supports the following solutions for minimizing application</span></p><p class="c0"><span class="c1">downtime required to make changes to an application&#39;s database objects:</span></p><p class="c0"><span class="c1">&#9632; Rolling patch updates</span></p><p class="c0"><span class="c1">Oracle Database supports the application of patches to the nodes of an Oracle</span></p><p class="c0"><span class="c1">RAC system in a rolling fashion. See Oracle Database High Availability Best Practices.</span></p><p class="c0"><span class="c1">&#9632; Rolling release upgrades</span></p><p class="c0"><span class="c1">Oracle Database supports the installation of database software upgrades, and the</span></p><p class="c0"><span class="c1">application of patchsets, in a rolling fashion&mdash;with near zero database</span></p><p class="c0"><span class="c1">downtime&mdash;by using Data Guard SQL Apply and logical standby databases. See</span></p><p class="c0"><span class="c1">Oracle Database Upgrade Guide.</span></p><p class="c0"><span class="c1">&#9632; Edition-based redefinition</span></p><p class="c0"><span class="c1">Edition-based redefinition enables you to upgrade the database objects of an</span></p><p class="c0"><span class="c1">application while the application is in use, thus minimizing or eliminating down</span></p><p class="c0"><span class="c1">time. Oracle Database accomplishes this task by changing (redefining) database</span></p><p class="c0"><span class="c1">objects in a private environment known as an edition. See Oracle Database</span></p><p class="c0"><span class="c1">Advanced Application Developer&#39;s Guide.</span></p><p class="c0"><span class="c1">&#9632; DDL with the default WAIT option</span></p><p class="c0"><span class="c1">DDL commands require exclusive locks on internal structures (see &quot;DDL Locks&quot;</span></p><p class="c0"><span class="c1">on page 9-24). In previous releases, DDL commands would fail if they could not</span></p><p class="c0"><span class="c1">obtain the locks. DDL specified with the WAIT option resolves this issue. See Oracle</span></p><p class="c0"><span class="c1">Database High Availability Overview.</span></p><p class="c0"><span class="c1">&#9632; Creation of triggers in a disabled state</span></p><p class="c0"><span class="c1">You can create a trigger in the disabled state so that you can ensure that your code</span></p><p class="c0"><span class="c1">compiles successfully before you enable the trigger. See Oracle Database PL/SQL</span></p><p class="c0"><span class="c1">Language Reference.</span></p><p class="c0"><span class="c1">Overview of Grid Computing</span></p><p class="c0"><span class="c1">Grid computing is a computing architecture that effectively pools large numbers of</span></p><p class="c0"><span class="c1">servers and storage into a flexible, on-demand resource for all enterprise computing</span></p><p class="c0"><span class="c1">needs. A Database Server Grid is a collection of commodity servers connected</span></p><p class="c0"><span class="c1">together to run on one or more databases. A Database Storage Grid is a collection of</span></p><p class="c0"><span class="c1">low-cost modular storage arrays combined together and accessed by the computers in</span></p><p class="c0"><span class="c1">the Database Server Grid.</span></p><p class="c0"><span class="c1">See Also: Oracle Database Administrator&#39;s Guide to learn how to</span></p><p class="c0"><span class="c1">change data structures onlineOverview of Grid Computing</span></p><p class="c0"><span class="c1">Topics for Database Administrators and Developers 17-13</span></p><p class="c0"><span class="c1">With the Database Server and Storage Grid, you can build a pool of system resources.</span></p><p class="c0"><span class="c1">You can dynamically allocate and deallocate these resources based on business</span></p><p class="c0"><span class="c1">priorities.</span></p><p class="c0"><span class="c1">Figure 17&ndash;2 illustrates the Database Server Grid and Database Storage Grid in a Grid</span></p><p class="c0"><span class="c1">enterprise computing environment.</span></p><p class="c0"><span class="c1">Figure 17&ndash;2 Grid Computing Environment</span></p><p class="c0"><span class="c1">Database Server Grid</span></p><p class="c0"><span class="c1">Oracle Real Application Clusters (Oracle RAC) enables multiple instances that are</span></p><p class="c0"><span class="c1">linked by an interconnect to share access to an Oracle database. In an Oracle RAC</span></p><p class="c0"><span class="c1">environment, Oracle Database runs on two or more systems in a cluster while</span></p><p class="c0"><span class="c1">concurrently accessing a single shared database. Oracle RAC enables a Database</span></p><p class="c0"><span class="c1">Server Grid by providing a single database that spans multiple low-cost servers yet</span></p><p class="c0"><span class="c1">appears to the application as a single, unified database system.</span></p><p class="c0"><span class="c1">Oracle Clusterware is software that enables servers to operate together as if they are</span></p><p class="c0"><span class="c1">one server. Each server looks like any standalone server. However, each server has</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database High Availability Overview for an overview of Grid</span></p><p class="c0"><span class="c1">Computing</span></p><p class="c0"><span class="c1">&#9632; http://www.gridforum.org/ to learn about the standards</span></p><p class="c0"><span class="c1">organization Global Grid Forum (GGF)</span></p><p class="c0"><span class="c1">Database Server Grid</span></p><p class="c0"><span class="c1">Database Storage Grid</span></p><p class="c0"><span class="c1">Storage Switches</span></p><p class="c0"><span class="c1">Databases Databases Databases</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">Servers</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">Servers</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">Servers</span></p><p class="c0"><span class="c1">InterconnectOverview of Grid Computing</span></p><p class="c0"><span class="c1">17-14 Oracle Database Concepts</span></p><p class="c0"><span class="c1">additional processes that communicate with each other so that separate servers work</span></p><p class="c0"><span class="c1">together as if they were one server. Oracle Clusterware provides all of the features</span></p><p class="c0"><span class="c1">required to run the cluster, including node membership and messaging services.</span></p><p class="c0"><span class="c1">Scalability</span></p><p class="c0"><span class="c1">In a Database Server Grid, Oracle RAC enables you to add nodes to the cluster as the</span></p><p class="c0"><span class="c1">demand for capacity increases. The Cache Fusion technology implemented in Oracle</span></p><p class="c0"><span class="c1">RAC enables you to scale capacity without changing your applications. Thus, you can</span></p><p class="c0"><span class="c1">scale the system incrementally to save costs and eliminate the need to replace smaller</span></p><p class="c0"><span class="c1">single-node systems with larger ones.</span></p><p class="c0"><span class="c1">You can incrementally add nodes to a cluster instead of replacing existing systems</span></p><p class="c0"><span class="c1">with larger nodes. Grid Plug and Play simplifies addition and removal of nodes from a</span></p><p class="c0"><span class="c1">cluster, making it easier to deploy clusters in a dynamically provisioned environment.</span></p><p class="c0"><span class="c1">Grid Plug and Play also enables databases and services to be managed in a</span></p><p class="c0"><span class="c1">location-independent manner. SCAN enables clients to connect to the database service</span></p><p class="c0"><span class="c1">without regard for its location within the grid.</span></p><p class="c0"><span class="c1">Fault Tolerance</span></p><p class="c0"><span class="c1">Fault tolerance is the protection provided by a high availability architecture against</span></p><p class="c0"><span class="c1">the failure of a component in the architecture. A key advantage of the Oracle RAC</span></p><p class="c0"><span class="c1">architecture is the inherent fault tolerance provided by multiple nodes. Because the</span></p><p class="c0"><span class="c1">physical nodes run independently, the failure of one or more nodes does not affect</span></p><p class="c0"><span class="c1">other nodes in the cluster.</span></p><p class="c0"><span class="c1">Failover can happen to any node on the Grid. In the extreme case, an Oracle RAC</span></p><p class="c0"><span class="c1">system provides database service even when all but one node is down. This</span></p><p class="c0"><span class="c1">architecture allows a group of nodes to be transparently put online or taken offline, for</span></p><p class="c0"><span class="c1">maintenance, while the rest of the cluster continues to provide database service.</span></p><p class="c0"><span class="c1">Oracle RAC provides built-in integration with Oracle Clients and connection pools.</span></p><p class="c0"><span class="c1">With this capability, an application is immediately notified of any failure through the</span></p><p class="c0"><span class="c1">pool that terminates the connection. The application avoids waiting for a TCP timeout</span></p><p class="c0"><span class="c1">and can immediately take the appropriate recovery action. Oracle RAC integrates the</span></p><p class="c0"><span class="c1">listener with Oracle Clients and the connection pools to create optimal application</span></p><p class="c0"><span class="c1">throughput. Oracle RAC can balance cluster workload based on the load at the time of</span></p><p class="c0"><span class="c1">the transaction.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database 2 Day + Real Application Clusters Guide for an</span></p><p class="c0"><span class="c1">introduction to Oracle Clusterware and Oracle RAC</span></p><p class="c0"><span class="c1">&#9632; Oracle Real Application Clusters Administration and Deployment</span></p><p class="c0"><span class="c1">Guide to learn how to manage an Oracle RAC database</span></p><p class="c0"><span class="c1">&#9632; Oracle Clusterware Administration and Deployment Guide to learn</span></p><p class="c0"><span class="c1">how to administer and deploy Oracle Clusterware</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Real Application Clusters Administration and Deployment</span></p><p class="c0"><span class="c1">Guide to learn more about Cache Fusion</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Installation Guide to learn how to install Grid Plug</span></p><p class="c0"><span class="c1">and PlayOverview of Data Warehousing and Business Intelligence</span></p><p class="c0"><span class="c1">Topics for Database Administrators and Developers 17-15</span></p><p class="c0"><span class="c1">Services</span></p><p class="c0"><span class="c1">Oracle RAC supports services that can group database workloads and route work to</span></p><p class="c0"><span class="c1">the optimal instances assigned to offer the services. A service represents the workload</span></p><p class="c0"><span class="c1">of applications with common attributes, performance thresholds, and priorities.</span></p><p class="c0"><span class="c1">You define and apply business policies to these services to perform tasks such as to</span></p><p class="c0"><span class="c1">allocate nodes for times of peak processing or to automatically handle a server failure.</span></p><p class="c0"><span class="c1">Using services ensures the application of system resources where and when they are</span></p><p class="c0"><span class="c1">needed to achieve business goals.</span></p><p class="c0"><span class="c1">Services are integrated with the Database Resource Manager, which enables you to</span></p><p class="c0"><span class="c1">restrict the resources that are used by a service within an instance. In addition, Oracle</span></p><p class="c0"><span class="c1">Scheduler jobs can run using a service, as opposed to using a specific instance.</span></p><p class="c0"><span class="c1">Database Storage Grid</span></p><p class="c0"><span class="c1">A DBA or storage administrator can use the Oracle ASM interface to specify the disks</span></p><p class="c0"><span class="c1">within the Database Storage Grid that ASM should manage across all server and</span></p><p class="c0"><span class="c1">storage platforms. ASM partitions the disk space and evenly distributes the data</span></p><p class="c0"><span class="c1">across the disks provided to ASM. Additionally, ASM automatically redistributes data</span></p><p class="c0"><span class="c1">as disks from storage arrays are added or removed from the Database Storage Grid.</span></p><p class="c0"><span class="c1">Overview of Data Warehousing and Business Intelligence</span></p><p class="c0"><span class="c1">A data warehouse is a relational database designed for query and analysis rather than</span></p><p class="c0"><span class="c1">for transaction processing. For example, a data warehouse could track historical stock</span></p><p class="c0"><span class="c1">prices or income tax records. A warehouse usually contains data derived from</span></p><p class="c0"><span class="c1">historical transaction data, but it can include data from other sources.</span></p><p class="c0"><span class="c1">A data warehouse environment includes several tools in addition to a relational</span></p><p class="c0"><span class="c1">database. A typical environment includes an ETL solution, an OLAP engine, Oracle</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Database Resident Connection Pooling&quot; on page 16-14</span></p><p class="c0"><span class="c1">&#9632; Oracle Real Application Clusters Administration and Deployment</span></p><p class="c0"><span class="c1">Guide to learn more about automatic workload management</span></p><p class="c0"><span class="c1">&#9632; Oracle Database High Availability Best Practices for an overview of</span></p><p class="c0"><span class="c1">fault tolerance in Oracle RAC</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database 2 Day + Real Application Clusters Guide to learn</span></p><p class="c0"><span class="c1">about Oracle services</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn about the Database</span></p><p class="c0"><span class="c1">Resource Manager and Oracle Scheduler</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Oracle Automatic Storage Management (Oracle ASM)&quot; on</span></p><p class="c0"><span class="c1">page 11-3</span></p><p class="c0"><span class="c1">&#9632; Oracle Database High Availability Overview for an overview of the</span></p><p class="c0"><span class="c1">Database Storage Grid</span></p><p class="c0"><span class="c1">&#9632; Oracle Automatic Storage Management Administrator&#39;s Guide for</span></p><p class="c0"><span class="c1">more information about clustered Oracle ASMOverview of Data Warehousing and Business Intelligence</span></p><p class="c0"><span class="c1">17-16 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Warehouse Builder, client analysis tools, and other applications that gather data and</span></p><p class="c0"><span class="c1">deliver it to users.</span></p><p class="c0"><span class="c1">Data Warehousing and OLTP</span></p><p class="c0"><span class="c1">A common way of introducing data warehousing is to refer to the characteristics of a</span></p><p class="c0"><span class="c1">data warehouse as set forth by William Inmon1:</span></p><p class="c0"><span class="c1">&#9632; Subject-Oriented</span></p><p class="c0"><span class="c1">Data warehouses enable you to define a database by subject matter, such as sales.</span></p><p class="c0"><span class="c1">&#9632; Integrated</span></p><p class="c0"><span class="c1">Data warehouses must put data from disparate sources into a consistent format.</span></p><p class="c0"><span class="c1">They must resolve such problems as naming conflicts and inconsistencies among</span></p><p class="c0"><span class="c1">units of measure. When they achieve this goal, they are said to be integrated.</span></p><p class="c0"><span class="c1">&#9632; Nonvolatile</span></p><p class="c0"><span class="c1">The purpose of a warehouse is to enable you to analyze what has occurred. Thus,</span></p><p class="c0"><span class="c1">after data has entered into the warehouse, data should not change.</span></p><p class="c0"><span class="c1">&#9632; Time-Variant</span></p><p class="c0"><span class="c1">The focus of a data warehouse is on change over time.</span></p><p class="c0"><span class="c1">Data warehouses and OLTP database have different requirements. For example, to</span></p><p class="c0"><span class="c1">discover trends in business, data warehouses must maintain large amounts of data. In</span></p><p class="c0"><span class="c1">contrast, good performance requires historical data to be moved regularly from OLTP</span></p><p class="c0"><span class="c1">systems to an archive. Table 17&ndash;1 lists differences between data warehouses and OLTP.</span></p><p class="c0"><span class="c1">1 Building the Data Warehouse, John Wiley and Sons, 1996.</span></p><p class="c0"><span class="c1">Table 17&ndash;1 Data Warehouses and OLTP Systems</span></p><p class="c0"><span class="c1">Characteristics Data Warehouse OLTP</span></p><p class="c0"><span class="c1">Workload Designed to accommodate ad hoc</span></p><p class="c0"><span class="c1">queries. You may not know the</span></p><p class="c0"><span class="c1">workload of your data warehouse</span></p><p class="c0"><span class="c1">in advance, so it should be</span></p><p class="c0"><span class="c1">optimized to perform well for a</span></p><p class="c0"><span class="c1">wide variety of possible queries.</span></p><p class="c0"><span class="c1">Supports only predefined operations.</span></p><p class="c0"><span class="c1">Your applications might be</span></p><p class="c0"><span class="c1">specifically tuned or designed to</span></p><p class="c0"><span class="c1">support only these operations.</span></p><p class="c0"><span class="c1">Data</span></p><p class="c0"><span class="c1">modifications</span></p><p class="c0"><span class="c1">Updated on a regular basis by the</span></p><p class="c0"><span class="c1">ETL process using bulk data</span></p><p class="c0"><span class="c1">modification techniques. End users</span></p><p class="c0"><span class="c1">of a data warehouse do not directly</span></p><p class="c0"><span class="c1">update the database.</span></p><p class="c0"><span class="c1">Subject to individual DML</span></p><p class="c0"><span class="c1">statements routinely issued by end</span></p><p class="c0"><span class="c1">users. The OLTP database is always</span></p><p class="c0"><span class="c1">up to date and reflects the current</span></p><p class="c0"><span class="c1">state of each business transaction.</span></p><p class="c0"><span class="c1">Schema design Uses denormalized or partially</span></p><p class="c0"><span class="c1">denormalized schemas (such as a</span></p><p class="c0"><span class="c1">star schema) to optimize query</span></p><p class="c0"><span class="c1">performance.</span></p><p class="c0"><span class="c1">Uses fully normalized schemas to</span></p><p class="c0"><span class="c1">optimize DML performance and to</span></p><p class="c0"><span class="c1">guarantee data consistency.</span></p><p class="c0"><span class="c1">Typical</span></p><p class="c0"><span class="c1">operations</span></p><p class="c0"><span class="c1">A typical query scans thousands or</span></p><p class="c0"><span class="c1">millions of rows. For example, a</span></p><p class="c0"><span class="c1">user may request the total sales for</span></p><p class="c0"><span class="c1">all customers last month.</span></p><p class="c0"><span class="c1">A typical operation accesses only a</span></p><p class="c0"><span class="c1">handful of records. For example, a</span></p><p class="c0"><span class="c1">user may retrieve the current order</span></p><p class="c0"><span class="c1">for a single customer.</span></p><p class="c0"><span class="c1">Historical data Stores many months or years of</span></p><p class="c0"><span class="c1">data to support historical analysis.</span></p><p class="c0"><span class="c1">Stores data from only a few weeks or</span></p><p class="c0"><span class="c1">months. Historical data retained as</span></p><p class="c0"><span class="c1">needed to meet the requirements of</span></p><p class="c0"><span class="c1">the current transaction.Overview of Data Warehousing and Business Intelligence</span></p><p class="c0"><span class="c1">Topics for Database Administrators and Developers 17-17</span></p><p class="c0"><span class="c1">Data Warehouse Architecture</span></p><p class="c0"><span class="c1">Data warehouses and their architectures vary depending on the business</span></p><p class="c0"><span class="c1">requirements. This section describes common data warehouse architectures.</span></p><p class="c0"><span class="c1">Data Warehouse Architecture (Basic)</span></p><p class="c0"><span class="c1">Figure 17&ndash;3 shows a simple architecture for a data warehouse. End users directly</span></p><p class="c0"><span class="c1">access data that was transported from several source systems to the data warehouse.</span></p><p class="c0"><span class="c1">Figure 17&ndash;3 Architecture of a Data Warehouse</span></p><p class="c0"><span class="c1">Figure 17&ndash;3 shows both the metadata and raw data of a traditional OLTP system and</span></p><p class="c0"><span class="c1">summary data. A summary is an aggregate view that improves query performance by</span></p><p class="c0"><span class="c1">precalculating expensive joins and aggregation operations and storing the results in a</span></p><p class="c0"><span class="c1">table. For example, a summary table can contain the sums of sales by region and by</span></p><p class="c0"><span class="c1">product. Summaries are also called materialized views.</span></p><p class="c0"><span class="c1">Data Warehouse Architecture (with a Staging Area)</span></p><p class="c0"><span class="c1">In the architecture shown in Figure 17&ndash;3, operational data must be cleaned and</span></p><p class="c0"><span class="c1">processed before being put into the warehouse. Figure 17&ndash;4 shows a data warehouse</span></p><p class="c0"><span class="c1">with a staging area, which is a place where data is preprocessed before entering the</span></p><p class="c0"><span class="c1">warehouse. A staging area simplifies the tasks of building summaries and managing</span></p><p class="c0"><span class="c1">the warehouse.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Data Warehousing Guide for a more detailed</span></p><p class="c0"><span class="c1">description of a database warehouse</span></p><p class="c0"><span class="c1">&#9632; Oracle Database VLDB and Partitioning Guide for a more detailed</span></p><p class="c0"><span class="c1">description of an OLTP system</span></p><p class="c0"><span class="c1">See Also: Oracle Database Data Warehousing Guide to learn about</span></p><p class="c0"><span class="c1">basic materialized views</span></p><p class="c0"><span class="c1">Data Sources Warehouse</span></p><p class="c0"><span class="c1">Summary</span></p><p class="c0"><span class="c1">Data Raw Data</span></p><p class="c0"><span class="c1">Metadata</span></p><p class="c0"><span class="c1">Operational</span></p><p class="c0"><span class="c1">System</span></p><p class="c0"><span class="c1">Operational</span></p><p class="c0"><span class="c1">System</span></p><p class="c0"><span class="c1">Flat Files</span></p><p class="c0"><span class="c1">Users</span></p><p class="c0"><span class="c1">Analysis</span></p><p class="c0"><span class="c1">Reporting</span></p><p class="c0"><span class="c1">MiningOverview of Data Warehousing and Business Intelligence</span></p><p class="c0"><span class="c1">17-18 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Figure 17&ndash;4 Architecture of a Data Warehouse with a Staging Area</span></p><p class="c0"><span class="c1">Data Warehouse Architecture (with a Staging Area and Data Marts)</span></p><p class="c0"><span class="c1">You may want to customize your warehouse architecture for different groups within</span></p><p class="c0"><span class="c1">your organization. You can achieve this goal by transporting data in the warehouse to</span></p><p class="c0"><span class="c1">data marts, which are independent databases designed for a specific business or</span></p><p class="c0"><span class="c1">project. Typically, data marts include many summary tables.</span></p><p class="c0"><span class="c1">Figure 17&ndash;5 separates purchasing, sales, and inventory information into independent</span></p><p class="c0"><span class="c1">data marts. A financial analyst can query the data marts for historical information</span></p><p class="c0"><span class="c1">about purchases and sales.</span></p><p class="c0"><span class="c1">Figure 17&ndash;5 Architecture of a Data Warehouse with a Staging Area and Data Marts</span></p><p class="c0"><span class="c1">See Also: Oracle Database Data Warehousing Guide to learn about</span></p><p class="c0"><span class="c1">different transportation mechanisms</span></p><p class="c0"><span class="c1">Operational</span></p><p class="c0"><span class="c1">System</span></p><p class="c0"><span class="c1">Data</span></p><p class="c0"><span class="c1">Sources</span></p><p class="c0"><span class="c1">Staging</span></p><p class="c0"><span class="c1">Area Warehouse Users</span></p><p class="c0"><span class="c1">Operational</span></p><p class="c0"><span class="c1">System</span></p><p class="c0"><span class="c1">Flat Files</span></p><p class="c0"><span class="c1">Analysis</span></p><p class="c0"><span class="c1">Reporting</span></p><p class="c0"><span class="c1">Mining</span></p><p class="c0"><span class="c1">Summary</span></p><p class="c0"><span class="c1">Data Raw Data</span></p><p class="c0"><span class="c1">Metadata</span></p><p class="c0"><span class="c1">Operational</span></p><p class="c0"><span class="c1">System</span></p><p class="c0"><span class="c1">Data</span></p><p class="c0"><span class="c1">Sources</span></p><p class="c0"><span class="c1">Staging</span></p><p class="c0"><span class="c1">Area Warehouse</span></p><p class="c0"><span class="c1">Data</span></p><p class="c0"><span class="c1">Marts Users</span></p><p class="c0"><span class="c1">Operational</span></p><p class="c0"><span class="c1">System</span></p><p class="c0"><span class="c1">Flat Files</span></p><p class="c0"><span class="c1">Sales</span></p><p class="c0"><span class="c1">Purchasing</span></p><p class="c0"><span class="c1">Inventory</span></p><p class="c0"><span class="c1">Analysis</span></p><p class="c0"><span class="c1">Reporting</span></p><p class="c0"><span class="c1">Mining</span></p><p class="c0"><span class="c1">Summary</span></p><p class="c0"><span class="c1">Data Raw Data</span></p><p class="c0"><span class="c1">MetadataOverview of Data Warehousing and Business Intelligence</span></p><p class="c0"><span class="c1">Topics for Database Administrators and Developers 17-19</span></p><p class="c0"><span class="c1">Overview of Extraction, Transformation, and Loading (ETL)</span></p><p class="c0"><span class="c1">The process of extracting data from source systems and bringing it into the warehouse</span></p><p class="c0"><span class="c1">is commonly called ETL: extraction, transformation, and loading. ETL refers to a broad</span></p><p class="c0"><span class="c1">process rather than three well-defined steps.</span></p><p class="c0"><span class="c1">In a typical scenario, data from one or more operational systems is extracted and then</span></p><p class="c0"><span class="c1">physically transported to the target system or an intermediate system for processing.</span></p><p class="c0"><span class="c1">Depending on the method of transportation, some transformations can occur during</span></p><p class="c0"><span class="c1">this process. For example, a SQL statement that directly accesses a remote target</span></p><p class="c0"><span class="c1">through a gateway can concatenate two columns as part of the SELECT statement.</span></p><p class="c0"><span class="c1">Oracle Database is not itself an ETL tool. However, Oracle Database provides a rich set</span></p><p class="c0"><span class="c1">of capabilities usable by ETL tools such as Oracle Warehouse Builder and customized</span></p><p class="c0"><span class="c1">ETL solutions. ETL capabilities provided by Oracle Database include:</span></p><p class="c0"><span class="c1">&#9632; Transportable tablespaces</span></p><p class="c0"><span class="c1">You can transport tablespaces between different computer architectures and</span></p><p class="c0"><span class="c1">operating systems. Transportable tablespaces are the fastest way for moving large</span></p><p class="c0"><span class="c1">volumes of data between two Oracle databases. See Oracle Database Administrator&#39;s</span></p><p class="c0"><span class="c1">Guide to learn about transportable tablespaces.</span></p><p class="c0"><span class="c1">&#9632; Table functions</span></p><p class="c0"><span class="c1">A table function can produce a set of rows as output and can accept a set of rows</span></p><p class="c0"><span class="c1">as input. Table functions provide support for pipelined and parallel execution of</span></p><p class="c0"><span class="c1">transformations implemented in PL/SQL, C, or Java without requiring the use of</span></p><p class="c0"><span class="c1">intermediate staging tables. See Oracle Database Data Warehousing Guide to learn</span></p><p class="c0"><span class="c1">about table functions.</span></p><p class="c0"><span class="c1">&#9632; External tables</span></p><p class="c0"><span class="c1">External tables enable external data to be joined directly and in parallel without</span></p><p class="c0"><span class="c1">requiring it to be first loaded in the database (see &quot;External Tables&quot; on page 2-16).</span></p><p class="c0"><span class="c1">Thus, external tables enable the pipelining of the loading phase with the</span></p><p class="c0"><span class="c1">transformation phase.</span></p><p class="c0"><span class="c1">&#9632; Table compression</span></p><p class="c0"><span class="c1">To reduce disk use and memory use, you can store tables and partitioned tables in</span></p><p class="c0"><span class="c1">a compressed format (see &quot;Table Compression&quot; on page 2-19). The use of table</span></p><p class="c0"><span class="c1">compression often leads to a better scaleup for read-only operations and faster</span></p><p class="c0"><span class="c1">query execution.</span></p><p class="c0"><span class="c1">&#9632; Change Data Capture</span></p><p class="c0"><span class="c1">This feature efficiently identifies and captures data that has been added to,</span></p><p class="c0"><span class="c1">updated in, or removed from, relational tables and makes this change data</span></p><p class="c0"><span class="c1">available for use by applications or individuals.</span></p><p class="c0"><span class="c1">See Also: Oracle Database Data Warehousing Guide to learn about</span></p><p class="c0"><span class="c1">transformation mechanisms</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Data Warehousing Guide to learn about Change</span></p><p class="c0"><span class="c1">Data Capture</span></p><p class="c0"><span class="c1">&#9632; Oracle Warehouse Builder Data Modeling, ETL, and Data Quality</span></p><p class="c0"><span class="c1">Guide for an overview of ETLOverview of Data Warehousing and Business Intelligence</span></p><p class="c0"><span class="c1">17-20 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Business Intelligence</span></p><p class="c0"><span class="c1">Business intelligence is the analysis of an organization&#39;s information as an aid to</span></p><p class="c0"><span class="c1">making business decisions. Business intelligence and analytical applications are</span></p><p class="c0"><span class="c1">dominated by actions such as drilling up and down hierarchies and comparing</span></p><p class="c0"><span class="c1">aggregate values. Oracle Database provides several technologies to support business</span></p><p class="c0"><span class="c1">intelligence operations.</span></p><p class="c0"><span class="c1">Analytic SQL</span></p><p class="c0"><span class="c1">Oracle Database has introduced many SQL operations for performing analytic</span></p><p class="c0"><span class="c1">operations. These operations include ranking, moving averages, cumulative sums,</span></p><p class="c0"><span class="c1">ratio-to-reports, and period-over-period comparisons. For example, Oracle Database</span></p><p class="c0"><span class="c1">supports the following forms of analytic SQL:</span></p><p class="c0"><span class="c1">&#9632; SQL for aggregation</span></p><p class="c0"><span class="c1">Aggregate functions such as COUNT return a single result row based on groups of</span></p><p class="c0"><span class="c1">rows rather than on single rows. Aggregation is fundamental to data warehousing.</span></p><p class="c0"><span class="c1">To improve aggregation performance in a warehouse, the database provides</span></p><p class="c0"><span class="c1">extensions to the GROUP BY clause to make querying and reporting easier and</span></p><p class="c0"><span class="c1">faster. See Oracle Database Data Warehousing Guide to learn about aggregation.</span></p><p class="c0"><span class="c1">&#9632; SQL for analysis</span></p><p class="c0"><span class="c1">Analytic functions compute an aggregate value based on a group of rows. They</span></p><p class="c0"><span class="c1">differ from aggregate functions in that they return multiple rows for each group.</span></p><p class="c0"><span class="c1">Oracle has advanced SQL analytical processing capabilities using a family of</span></p><p class="c0"><span class="c1">analytic SQL functions. For example, these analytic functions enable you to</span></p><p class="c0"><span class="c1">calculate rankings and percentiles and moving windows. See Oracle Database Data</span></p><p class="c0"><span class="c1">Warehousing Guide to learn about SQL for analysis and reporting.</span></p><p class="c0"><span class="c1">&#9632; SQL for modeling</span></p><p class="c0"><span class="c1">With the MODEL clause, you can create a multidimensional array from query results</span></p><p class="c0"><span class="c1">and apply rules to this array to calculate new values. For example, you can</span></p><p class="c0"><span class="c1">partition data in a sales view by country and perform a model computation, as</span></p><p class="c0"><span class="c1">defined by multiple rules, on each country. One rule could calculate the sales of a</span></p><p class="c0"><span class="c1">product in 2011 as the sum of sales in 2009 and 2010. See Oracle Database Data</span></p><p class="c0"><span class="c1">Warehousing Guide to learn about SQL modeling.</span></p><p class="c0"><span class="c1">OLAP</span></p><p class="c0"><span class="c1">Oracle online analytical processing (OLAP) provides native multidimensional storage</span></p><p class="c0"><span class="c1">and rapid response times when analyzing data across multiple dimensions. OLAP</span></p><p class="c0"><span class="c1">enables analysts to quickly obtain answers to complex, iterative queries during</span></p><p class="c0"><span class="c1">interactive sessions.</span></p><p class="c0"><span class="c1">Oracle OLAP has the following primary characteristics:</span></p><p class="c0"><span class="c1">&#9632; Oracle OLAP is integrated in the database so that you can use standard SQL</span></p><p class="c0"><span class="c1">administrative, querying, and reporting tools.</span></p><p class="c0"><span class="c1">&#9632; The OLAP engine runs within the kernel of Oracle Database.</span></p><p class="c0"><span class="c1">&#9632; Dimensional objects are stored in Oracle Database in their native</span></p><p class="c0"><span class="c1">multidimensional format.</span></p><p class="c0"><span class="c1">See Also: Oracle Database SQL Language Reference to learn about SQL</span></p><p class="c0"><span class="c1">functionsOverview of Oracle Information Integration</span></p><p class="c0"><span class="c1">Topics for Database Administrators and Developers 17-21</span></p><p class="c0"><span class="c1">&#9632; Cubes and other dimensional objects are first class data objects represented in the</span></p><p class="c0"><span class="c1">Oracle data dictionary.</span></p><p class="c0"><span class="c1">&#9632; Data security is administered in the standard way, by granting and revoking</span></p><p class="c0"><span class="c1">privileges to Oracle Database users and roles.</span></p><p class="c0"><span class="c1">Oracle OLAP offers the power of simplicity: one database, standard administration</span></p><p class="c0"><span class="c1">and security, and standard interfaces and development tools.</span></p><p class="c0"><span class="c1">Data Mining</span></p><p class="c0"><span class="c1">Data mining involves automatically searching large stores of data for patterns and</span></p><p class="c0"><span class="c1">trends that go beyond simple analysis. Data mining uses sophisticated mathematical</span></p><p class="c0"><span class="c1">algorithms to segment data and evaluate the probability of future events. Typical</span></p><p class="c0"><span class="c1">applications of data mining include call centers, ATMs, E-business relational</span></p><p class="c0"><span class="c1">management (ERM), and business planning.</span></p><p class="c0"><span class="c1">With Oracle Data Mining, the data, data preparation, model building, and model</span></p><p class="c0"><span class="c1">scoring results all remain in the database. Oracle Data Mining supports a PL/SQL API,</span></p><p class="c0"><span class="c1">a Java API, SQL functions for model scoring, and a GUI called Oracle Data Miner.</span></p><p class="c0"><span class="c1">Thus, Oracle Database provides an infrastructure for application developers to</span></p><p class="c0"><span class="c1">integrate data mining seamlessly with database applications.</span></p><p class="c0"><span class="c1">Overview of Oracle Information Integration</span></p><p class="c0"><span class="c1">As an organization evolves, it becomes increasingly important for it to be able to share</span></p><p class="c0"><span class="c1">information among multiple databases and applications. The basic approaches to</span></p><p class="c0"><span class="c1">sharing information are as follows:</span></p><p class="c0"><span class="c1">&#9632; Consolidation</span></p><p class="c0"><span class="c1">You can consolidate the information into a single database, which eliminates the</span></p><p class="c0"><span class="c1">need for further integration. Oracle RAC, Grid computing, and Oracle VPD can</span></p><p class="c0"><span class="c1">enable you to consolidate information into a single database.</span></p><p class="c0"><span class="c1">&#9632; Federation</span></p><p class="c0"><span class="c1">You can leave information distributed, and provide tools to federate this</span></p><p class="c0"><span class="c1">information, making it appear to be in a single virtual database.</span></p><p class="c0"><span class="c1">&#9632; Sharing</span></p><p class="c0"><span class="c1">You can share information, which lets you maintain the information in multiple</span></p><p class="c0"><span class="c1">data stores and applications.</span></p><p class="c0"><span class="c1">This section focuses on Oracle solutions for federating and sharing information.</span></p><p class="c0"><span class="c1">Federated Access</span></p><p class="c0"><span class="c1">The foundation of federated access is a distributed environment, which is a network</span></p><p class="c0"><span class="c1">of disparate systems that seamlessly communicate with each other. Each system in the</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Overview of Dimensions&quot; on page 4-21</span></p><p class="c0"><span class="c1">&#9632; Oracle OLAP User&#39;s Guide for an overview of Oracle OLAP</span></p><p class="c0"><span class="c1">See Also: Oracle Data Mining Concepts</span></p><p class="c0"><span class="c1">See Also: Oracle Database 2 Day + Data Replication and Integration</span></p><p class="c0"><span class="c1">Guide for an introduction to data replication and integrationOverview of Oracle Information Integration</span></p><p class="c0"><span class="c1">17-22 Oracle Database Concepts</span></p><p class="c0"><span class="c1">environment is called a node. The system to which a user is directly connected is</span></p><p class="c0"><span class="c1">called the local system. Additional systems accessed by this user are remote systems.</span></p><p class="c0"><span class="c1">A distributed environment enables applications to access and exchange data from the</span></p><p class="c0"><span class="c1">local and remote systems. All the data can be simultaneously accessed and modified.</span></p><p class="c0"><span class="c1">Distributed SQL</span></p><p class="c0"><span class="c1">Distributed SQL synchronously accesses and updates data distributed among</span></p><p class="c0"><span class="c1">multiple databases. An Oracle distributed database system can be transparent to users,</span></p><p class="c0"><span class="c1">making it appear as a single Oracle database.</span></p><p class="c0"><span class="c1">Distributed SQL includes distributed queries and distributed transactions. The Oracle</span></p><p class="c0"><span class="c1">distributed database architecture provides query and transaction transparency. For</span></p><p class="c0"><span class="c1">example, standard DML statements work just as they do in a non-distributed database</span></p><p class="c0"><span class="c1">environment. Additionally, applications control transactions using the standard SQL</span></p><p class="c0"><span class="c1">statements COMMIT, SAVEPOINT, and ROLLBACK.</span></p><p class="c0"><span class="c1">Database Links</span></p><p class="c0"><span class="c1">A database link is a connection between two physical databases that enables a client</span></p><p class="c0"><span class="c1">to access them as one logical database. Oracle Database uses database links to enable</span></p><p class="c0"><span class="c1">users on one database to access objects in a remote database. A local user can access a</span></p><p class="c0"><span class="c1">link to a remote database without being a user on the remote database.</span></p><p class="c0"><span class="c1">Figure 17&ndash;6 shows an example of user hr accessing the employees table on the remote</span></p><p class="c0"><span class="c1">database with the global name hq.example.com. The employees synonym hides the</span></p><p class="c0"><span class="c1">identity and location of the remote schema object.</span></p><p class="c0"><span class="c1">Figure 17&ndash;6 Database Link</span></p><p class="c0"><span class="c1">Information Sharing</span></p><p class="c0"><span class="c1">At the heart of any integration is the sharing of data among applications in the</span></p><p class="c0"><span class="c1">enterprise. Oracle Streams is the asynchronous information sharing infrastructure in</span></p><p class="c0"><span class="c1">Oracle Database. This infrastructure enables the propagation and management of data,</span></p><p class="c0"><span class="c1">transactions, and events in a data stream either within a database, or from one</span></p><p class="c0"><span class="c1">database to another.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Overview of Distributed Transactions&quot; on page 10-12</span></p><p class="c0"><span class="c1">&#9632; Oracle Database 2 Day + Data Replication and Integration Guide to</span></p><p class="c0"><span class="c1">learn about distributed SQL</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide to learn how to manage</span></p><p class="c0"><span class="c1">distributed transactions</span></p><p class="c0"><span class="c1">See Also: Oracle Database Administrator&#39;s Guide to learn about</span></p><p class="c0"><span class="c1">database links</span></p><p class="c0"><span class="c1">Local</span></p><p class="c0"><span class="c1">database</span></p><p class="c0"><span class="c1">User HR</span></p><p class="c0"><span class="c1">Remote</span></p><p class="c0"><span class="c1">database</span></p><p class="c0"><span class="c1">SELECT *</span></p><p class="c0"><span class="c1">FROM employees</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">Link</span></p><p class="c0"><span class="c1">(unidirectional)</span></p><p class="c0"><span class="c1">EMPLOYEES table</span></p><p class="c0"><span class="c1">PUBLIC SYNONYM</span></p><p class="c0"><span class="c1">employees -&gt; employees@HQ.EXAMPLE.COMOverview of Oracle Information Integration</span></p><p class="c0"><span class="c1">Topics for Database Administrators and Developers 17-23</span></p><p class="c0"><span class="c1">Oracle Streams includes replication and messaging. Replication is the process of</span></p><p class="c0"><span class="c1">sharing database objects and data at multiple databases. Messaging is the sharing of</span></p><p class="c0"><span class="c1">information between applications and users.</span></p><p class="c0"><span class="c1">Oracle Streams Replication</span></p><p class="c0"><span class="c1">In Oracle Streams replication, a change to a database object at one database can be</span></p><p class="c0"><span class="c1">shared with other databases in the replication environment. For example, Oracle</span></p><p class="c0"><span class="c1">Streams propagates an update to an employees table to an identical employees table in</span></p><p class="c0"><span class="c1">a different database. In this way, the database objects and data are kept synchronized</span></p><p class="c0"><span class="c1">at all databases in the replication environment.</span></p><p class="c0"><span class="c1">Typical uses for Oracle Streams replication include:</span></p><p class="c0"><span class="c1">&#9632; Creating a reporting site to offload processing from a primary OLTP site.</span></p><p class="c0"><span class="c1">&#9632; Providing load balancing and improved scalability and availability for a call center</span></p><p class="c0"><span class="c1">or similar application.</span></p><p class="c0"><span class="c1">&#9632; Providing site autonomy between locations to satisfy certain common business</span></p><p class="c0"><span class="c1">requirements.</span></p><p class="c0"><span class="c1">&#9632; Transforming and consolidating data from multiple locations.</span></p><p class="c0"><span class="c1">&#9632; Replicating data between different platforms and Oracle Database releases, and</span></p><p class="c0"><span class="c1">across a wide area network (WAN).</span></p><p class="c0"><span class="c1">Oracle Streams Information Flow The architecture of Oracle Streams is very flexible.</span></p><p class="c0"><span class="c1">Figure 17&ndash;7 depicts the basic information flow in a replication environment.</span></p><p class="c0"><span class="c1">Figure 17&ndash;7 Oracle Streams Information Flow</span></p><p class="c0"><span class="c1">As shown in Figure 17&ndash;7, Oracle Streams contains the following basic elements:</span></p><p class="c0"><span class="c1">&#9632; Capture</span></p><p class="c0"><span class="c1">Oracle Streams can implicitly capture DML and DDL changes. Rules determine</span></p><p class="c0"><span class="c1">which changes are captured. Changes are formatted into logical change records</span></p><p class="c0"><span class="c1">(LCRs), which are messages with a specific format describing a database change.</span></p><p class="c0"><span class="c1">&#9632; Staging</span></p><p class="c0"><span class="c1">LCRs are placed in a staging area, which is a queue that stores and manages</span></p><p class="c0"><span class="c1">captured messages. Message staging provides a holding area with security, as well</span></p><p class="c0"><span class="c1">as auditing and tracking of message data. Propagations can send messages from</span></p><p class="c0"><span class="c1">one queue to another. The queues can reside in the same or different databases.</span></p><p class="c0"><span class="c1">&#9632; Consumption</span></p><p class="c0"><span class="c1">LCRs remain in a staging area until subscribers consume them implicitly or</span></p><p class="c0"><span class="c1">explicitly. An apply process implicitly applies changes encapsulated in LCRs.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Streams Concepts and Administration</span></p><p class="c0"><span class="c1">&#9632; Oracle Streams Replication Administrator&#39;s Guide</span></p><p class="c0"><span class="c1">Capture Staging ConsumptionOverview of Oracle Information Integration</span></p><p class="c0"><span class="c1">17-24 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Oracle Streams Replication Environments Oracle Streams enables you to configure many</span></p><p class="c0"><span class="c1">different types of custom replication environments. However, the following types of</span></p><p class="c0"><span class="c1">replication environments are the most common:</span></p><p class="c0"><span class="c1">&#9632; Two-Database</span></p><p class="c0"><span class="c1">Only two databases share the replicated database objects. The changes made to</span></p><p class="c0"><span class="c1">replicated database objects at one database are captured and sent directly to the</span></p><p class="c0"><span class="c1">other database, where they are applied.</span></p><p class="c0"><span class="c1">In a one-way replication environment, only one database allows changes to the</span></p><p class="c0"><span class="c1">replicated database objects, with the other database containing read-only replicas</span></p><p class="c0"><span class="c1">of these objects. In a bi-directional replication environment, both databases can</span></p><p class="c0"><span class="c1">allow changes to the replicated objects. In this case, both databases capture</span></p><p class="c0"><span class="c1">changes to these database objects and send the changes to the other database,</span></p><p class="c0"><span class="c1">where they are applied.</span></p><p class="c0"><span class="c1">&#9632; Hub-and-Spoke</span></p><p class="c0"><span class="c1">A central database, or hub, communicates with secondary databases, or spokes.</span></p><p class="c0"><span class="c1">The spokes do not communicate directly with each other. In a hub-and-spoke</span></p><p class="c0"><span class="c1">replication environment, the spokes might or might not allow changes to the</span></p><p class="c0"><span class="c1">replicated database objects.</span></p><p class="c0"><span class="c1">&#9632; N-Way</span></p><p class="c0"><span class="c1">Each database communicates directly with every other database in the</span></p><p class="c0"><span class="c1">environment. The changes made to replicated database objects at one database are</span></p><p class="c0"><span class="c1">captured and sent directly to each of the other databases in the environment,</span></p><p class="c0"><span class="c1">where they are applied.</span></p><p class="c0"><span class="c1">Oracle Streams Advanced Queuing (AQ)</span></p><p class="c0"><span class="c1">Oracle Streams Advanced Queuing (AQ) is a robust and feature-rich message queuing</span></p><p class="c0"><span class="c1">system integrated with Oracle Database. When an organization has different systems</span></p><p class="c0"><span class="c1">that must communicate with each other, a messaging environment can provide a</span></p><p class="c0"><span class="c1">standard, reliable way to transport critical information between these systems.</span></p><p class="c0"><span class="c1">A sample use case is a business that enters orders in an Oracle database at</span></p><p class="c0"><span class="c1">headquarters. When an order is entered, the business uses AQ to send the order ID</span></p><p class="c0"><span class="c1">and order date to a database in a warehouse. These messages alert employees at the</span></p><p class="c0"><span class="c1">warehouse about the orders so that they can fill and ship them.</span></p><p class="c0"><span class="c1">Message Queuing and Dequeuing Advanced Queuing stores user messages in abstract</span></p><p class="c0"><span class="c1">storage units called queues. Enqueuing is the process by which producers place</span></p><p class="c0"><span class="c1">messages into queues. Dequeuing is the process by which consumers retrieve</span></p><p class="c0"><span class="c1">messages from queues.</span></p><p class="c0"><span class="c1">Note: Oracle Streams is fully inter-operational with materialized</span></p><p class="c0"><span class="c1">views, which you can use to maintain updatable or read-only copies</span></p><p class="c0"><span class="c1">of data (see &quot;Overview of Materialized Views&quot; on page 4-16).</span></p><p class="c0"><span class="c1">See Also: Oracle Database 2 Day + Data Replication and Integration</span></p><p class="c0"><span class="c1">Guide to learn how to replicate data using Oracle Streams</span></p><p class="c0"><span class="c1">See Also: Oracle Database 2 Day + Data Replication and Integration</span></p><p class="c0"><span class="c1">Guide to learn more about common replication environmentsOverview of Oracle Information Integration</span></p><p class="c0"><span class="c1">Topics for Database Administrators and Developers 17-25</span></p><p class="c0"><span class="c1">Support for explicit dequeue allows developers to use Oracle Streams to reliably</span></p><p class="c0"><span class="c1">exchange messages. They can also notify applications of changes by leveraging the</span></p><p class="c0"><span class="c1">change capture and propagation features of Oracle Streams.</span></p><p class="c0"><span class="c1">Figure 17&ndash;8 shows a sample application that explicitly enqueues and dequeues</span></p><p class="c0"><span class="c1">messages through Advanced Queuing, enabling it to share information with partners</span></p><p class="c0"><span class="c1">using different messaging systems. After being enqueued, messages can be</span></p><p class="c0"><span class="c1">transformed and propagated before being dequeued to the partner&#39;s application.</span></p><p class="c0"><span class="c1">Figure 17&ndash;8 Oracle Streams Message Queuing</span></p><p class="c0"><span class="c1">Advanced Queuing Features Oracle Streams Advanced Queuing supports all the</span></p><p class="c0"><span class="c1">standard features of message queuing systems. These features include:</span></p><p class="c0"><span class="c1">&#9632; Asynchronous application integration</span></p><p class="c0"><span class="c1">Oracle Streams Advanced Queuing offers several ways to enqueue messages. A</span></p><p class="c0"><span class="c1">capture process or synchronous capture can capture the messages implicitly, or</span></p><p class="c0"><span class="c1">applications and users can capture messages explicitly.</span></p><p class="c0"><span class="c1">&#9632; Extensible integration architecture</span></p><p class="c0"><span class="c1">Many applications are integrated with a distributed hub and spoke model with</span></p><p class="c0"><span class="c1">Oracle Database as the hub. The distributed applications on an Oracle database</span></p><p class="c0"><span class="c1">communicate with queues in the same hub. Multiple applications share the same</span></p><p class="c0"><span class="c1">queue, eliminating the need to add queues to support additional applications.</span></p><p class="c0"><span class="c1">&#9632; Heterogeneous application integration</span></p><p class="c0"><span class="c1">Advanced Queuing provides applications with the full power of the Oracle type</span></p><p class="c0"><span class="c1">system. It includes support for scalar data types, Oracle Database object types with</span></p><p class="c0"><span class="c1">inheritance, XMLType with additional operators for XML data, and ANYDATA.</span></p><p class="c0"><span class="c1">&#9632; Legacy application integration</span></p><p class="c0"><span class="c1">The Oracle Messaging Gateway integrates Oracle Database applications with other</span></p><p class="c0"><span class="c1">message queuing systems, such as Websphere MQ and Tibco.</span></p><p class="c0"><span class="c1">&#9632; Standards-Based API support</span></p><p class="c0"><span class="c1">Oracle Streams Advanced Queuing supports industry-standard APIs: SQL, JMS,</span></p><p class="c0"><span class="c1">and SOAP. Changes made using SQL are captured automatically as messages.</span></p><p class="c0"><span class="c1">Oracle Streams Use Case</span></p><p class="c0"><span class="c1">For a sample use case, assume that a company uses Oracle Streams to maintain</span></p><p class="c0"><span class="c1">multiple copies of a corporate Web site. The business requirements include:</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database 2 Day + Data Replication and Integration Guide to</span></p><p class="c0"><span class="c1">learn how to send messages using Advanced Queuing</span></p><p class="c0"><span class="c1">&#9632; Oracle Streams Advanced Queuing User&#39;s Guide</span></p><p class="c0"><span class="c1">Application Application</span></p><p class="c0"><span class="c1">Dequeue</span></p><p class="c0"><span class="c1">Enqueue</span></p><p class="c0"><span class="c1">Dequeue</span></p><p class="c0"><span class="c1">Enqueue</span></p><p class="c0"><span class="c1">Oracle</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">Advanced</span></p><p class="c0"><span class="c1">queuesOverview of Oracle Information Integration</span></p><p class="c0"><span class="c1">17-26 Oracle Database Concepts</span></p><p class="c0"><span class="c1">&#9632; A reporting database must contain the most current data for analysts in a New</span></p><p class="c0"><span class="c1">York office to perform ad hoc querying.</span></p><p class="c0"><span class="c1">&#9632; Updatable materialized views must support the field sales staff.</span></p><p class="c0"><span class="c1">&#9632; Data must be shared with applications hosted on a Sybase database.</span></p><p class="c0"><span class="c1">Figure 17&ndash;9 illustrates this Streams configuration.</span></p><p class="c0"><span class="c1">Figure 17&ndash;9 Streams Configuration</span></p><p class="c0"><span class="c1">Oracle Streams is used to replicate data in an n-way configuration consisting of sites in</span></p><p class="c0"><span class="c1">New York, London, and Tokyo. At each site, Streams implicit capture collects any</span></p><p class="c0"><span class="c1">changes that occur for subscribed tables in each local region, and stages them locally in</span></p><p class="c0"><span class="c1">the queue. Changes captured in each region are then forwarded to each of the other</span></p><p class="c0"><span class="c1">region&#39;s databases. Changes made at each database can be reflected at every other</span></p><p class="c0"><span class="c1">database, providing complete data for the subscribed objects throughout the world.</span></p><p class="c0"><span class="c1">At each regional database, an Oracle Streams apply process applies the changes</span></p><p class="c0"><span class="c1">automatically. As changes are applied, Oracle Streams checks for and resolves any</span></p><p class="c0"><span class="c1">conflicts. Streams can also be used to exchange data for particular tables with</span></p><p class="c0"><span class="c1">non-Oracle databases. Using the Oracle Database Gateway for Sybase, a Streams apply</span></p><p class="c0"><span class="c1">process applies the changes to a Sybase database using the same mechanisms as it</span></p><p class="c0"><span class="c1">does for Oracle databases.</span></p><p class="c0"><span class="c1">The reporting database is hosted in New York. This database is a fully functional</span></p><p class="c0"><span class="c1">Oracle database that has a read-only copy of the relevant application tables. The</span></p><p class="c0"><span class="c1">reporting site is not configured to capture changes on these application tables. Oracle</span></p><p class="c0"><span class="c1">Streams imposes no restrictions on the configuration or use of this reporting database.</span></p><p class="c0"><span class="c1">The London site also serves as the master site for several updatable materialized view</span></p><p class="c0"><span class="c1">sites. Each salesperson receives an updatable copy of the required portion of data.</span></p><p class="c0"><span class="c1">These sites typically only connect once a day to upload their orders and download any</span></p><p class="c0"><span class="c1">changes made after their last refresh.</span></p><p class="c0"><span class="c1">See Also: Oracle Database 2 Day + Data Replication and Integration</span></p><p class="c0"><span class="c1">Guide for examples of configuring Oracle Streams</span></p><p class="c0"><span class="c1">Tokyo</span></p><p class="c0"><span class="c1">London</span></p><p class="c0"><span class="c1">NY</span></p><p class="c0"><span class="c1">Report</span></p><p class="c0"><span class="c1">Gateway</span></p><p class="c0"><span class="c1">Sybase</span></p><p class="c0"><span class="c1">Clients18</span></p><p class="c0"><span class="c1">Concepts for Database Administrators 18-1</span></p><p class="c0"><span class="c1">Concepts for Database Administrators 8 1</span></p><p class="c0"><span class="c1">This chapter contains the following sections:</span></p><p class="c0"><span class="c1">&#9632; Duties of Database Administrators</span></p><p class="c0"><span class="c1">&#9632; Tools for Database Administrators</span></p><p class="c0"><span class="c1">&#9632; Topics for Database Administrators</span></p><p class="c0"><span class="c1">Duties of Database Administrators</span></p><p class="c0"><span class="c1">The principal responsibility of a database administrator (DBA) is to make enterprise</span></p><p class="c0"><span class="c1">data available to its users. DBAs must work closely with the developers to ensure that</span></p><p class="c0"><span class="c1">their applications make efficient use of the database, and with system administrators</span></p><p class="c0"><span class="c1">to ensure that physical resources are adequate and used efficiently.</span></p><p class="c0"><span class="c1">Oracle DBAs are responsible for understanding the Oracle Database architecture and</span></p><p class="c0"><span class="c1">how the database works. DBAs can expect to perform the following tasks:</span></p><p class="c0"><span class="c1">&#9632; Installing, upgrading, and patching Oracle Database software</span></p><p class="c0"><span class="c1">&#9632; Designing databases, including identifying requirements, creating the logical</span></p><p class="c0"><span class="c1">design (conceptual model), and physical database design</span></p><p class="c0"><span class="c1">&#9632; Creating Oracle databases</span></p><p class="c0"><span class="c1">&#9632; Developing and testing a backup and recovery strategy, backing up Oracle</span></p><p class="c0"><span class="c1">databases regularly, and recovering them in case of failures</span></p><p class="c0"><span class="c1">&#9632; Configuring the network environment to enable clients to connect to databases</span></p><p class="c0"><span class="c1">&#9632; Starting up and shutting down the database</span></p><p class="c0"><span class="c1">&#9632; Managing storage for the database</span></p><p class="c0"><span class="c1">&#9632; Managing users and security</span></p><p class="c0"><span class="c1">&#9632; Managing database objects such as tables, indexes, and views</span></p><p class="c0"><span class="c1">&#9632; Monitoring and tuning database performance</span></p><p class="c0"><span class="c1">&#9632; Investigating, gathering diagnostic data for, and reporting to Oracle Support</span></p><p class="c0"><span class="c1">Services any critical database errors</span></p><p class="c0"><span class="c1">&#9632; Evaluating and testing new database features</span></p><p class="c0"><span class="c1">The preceding tasks, and many others, are described in Oracle Database 2 Day DBA and</span></p><p class="c0"><span class="c1">Oracle Database Administrator&#39;s Guide.</span></p><p class="c0"><span class="c1">The types of users and their roles and responsibilities depend on the database</span></p><p class="c0"><span class="c1">environment. A small database may have one DBA. A very large database may divideTools for Database Administrators</span></p><p class="c0"><span class="c1">18-2 Oracle Database Concepts</span></p><p class="c0"><span class="c1">the DBA duties among several specialists, for example, security officers, backup</span></p><p class="c0"><span class="c1">operators, and application administrators.</span></p><p class="c0"><span class="c1">Tools for Database Administrators</span></p><p class="c0"><span class="c1">Oracle provides several tools for use in administering a database. This section</span></p><p class="c0"><span class="c1">describes some commonly used tools:</span></p><p class="c0"><span class="c1">&#9632; Oracle Enterprise Manager</span></p><p class="c0"><span class="c1">&#9632; SQL*Plus</span></p><p class="c0"><span class="c1">&#9632; Tools for Database Installation and Configuration</span></p><p class="c0"><span class="c1">&#9632; Tools for Oracle Net Configuration and Administration</span></p><p class="c0"><span class="c1">&#9632; Tools for Data Movement and Analysis</span></p><p class="c0"><span class="c1">Oracle Enterprise Manager</span></p><p class="c0"><span class="c1">Oracle Enterprise Manager (Enterprise Manager) is a system management tool that</span></p><p class="c0"><span class="c1">provides centralized management of a database environment. Combining a graphical</span></p><p class="c0"><span class="c1">console, Oracle Management Servers, Oracle Intelligent Agents, common services, and</span></p><p class="c0"><span class="c1">administrative tools, Enterprise Manager provides a comprehensive systems</span></p><p class="c0"><span class="c1">management platform for Oracle products.</span></p><p class="c0"><span class="c1">The Web-based Enterprise Manager Database Control (Database Control) is the</span></p><p class="c0"><span class="c1">primary tool for managing an Oracle database. It is installed with Oracle Database.</span></p><p class="c0"><span class="c1">You can use Database Control to perform administrative tasks such as:</span></p><p class="c0"><span class="c1">&#9632; Diagnosing, modifying, and tuning the database</span></p><p class="c0"><span class="c1">&#9632; Grouping related targets together to facilitate administration tasks, sharing tasks</span></p><p class="c0"><span class="c1">with other administrators, and scheduling tasks at varying time intervals</span></p><p class="c0"><span class="c1">&#9632; Configuring and managing Oracle Net Services for an Oracle home (see</span></p><p class="c0"><span class="c1">&quot;Overview of Oracle Networking Architecture&quot; on page 16-5)</span></p><p class="c0"><span class="c1">&#9632; Launching integrated Oracle and third-party tools</span></p><p class="c0"><span class="c1">The following figure shows the Database Home page of Database Control. The</span></p><p class="c0"><span class="c1">subpage links across the top of the page enable you to access performance, availability,</span></p><p class="c0"><span class="c1">and other database administration pages. The subsections of the Database Home page</span></p><p class="c0"><span class="c1">provide information about the environment and status of the database.Tools for Database Administrators</span></p><p class="c0"><span class="c1">Concepts for Database Administrators 18-3</span></p><p class="c0"><span class="c1">The following figure shows the basic architecture of Enterprise Manager. The</span></p><p class="c0"><span class="c1">management repository is stored inside the database. Both the agent and the</span></p><p class="c0"><span class="c1">management service run on the database host. You can run the Database Control</span></p><p class="c0"><span class="c1">Console from any Web browser that can connect securely to the management service.</span></p><p class="c0"><span class="c1">See Also: Oracle Database 2 Day DBA to learn how to administer the</span></p><p class="c0"><span class="c1">database with Enterprise Manager</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">Management</span></p><p class="c0"><span class="c1">Repository</span></p><p class="c0"><span class="c1">Management</span></p><p class="c0"><span class="c1">Agent</span></p><p class="c0"><span class="c1">HTTP(S)</span></p><p class="c0"><span class="c1">HTTPS</span></p><p class="c0"><span class="c1">Thin</span></p><p class="c0"><span class="c1">JDBC</span></p><p class="c0"><span class="c1">Management Service</span></p><p class="c0"><span class="c1">(J2EE Web Application)</span></p><p class="c0"><span class="c1">Database Control</span></p><p class="c0"><span class="c1">Console</span></p><p class="c0"><span class="c1">Client ServerTools for Database Administrators</span></p><p class="c0"><span class="c1">18-4 Oracle Database Concepts</span></p><p class="c0"><span class="c1">SQL*Plus</span></p><p class="c0"><span class="c1">SQL*Plus is an interactive and batch query tool included in every Oracle Database</span></p><p class="c0"><span class="c1">installation. It has a command-line user interface that acts as the client when</span></p><p class="c0"><span class="c1">connecting to the database.</span></p><p class="c0"><span class="c1">SQL*Plus has its own commands and environment. It enables you to enter and execute</span></p><p class="c0"><span class="c1">SQL, PL/SQL, SQL*Plus and operating system commands to perform tasks such as:</span></p><p class="c0"><span class="c1">&#9632; Formatting, performing calculations on, storing, and printing from query results</span></p><p class="c0"><span class="c1">&#9632; Examining table and object definitions</span></p><p class="c0"><span class="c1">&#9632; Developing and running batch scripts</span></p><p class="c0"><span class="c1">&#9632; Administering a database</span></p><p class="c0"><span class="c1">You can use SQL*Plus to generate reports interactively, to generate reports as batch</span></p><p class="c0"><span class="c1">processes, and to output the results to text file, to screen, or to HTML file for browsing</span></p><p class="c0"><span class="c1">on the Internet. You can generate reports dynamically using the HTML output facility.</span></p><p class="c0"><span class="c1">Tools for Database Installation and Configuration</span></p><p class="c0"><span class="c1">Oracle provides several tools to simplify the task of installing and configuring Oracle</span></p><p class="c0"><span class="c1">Database software. The tools include:</span></p><p class="c0"><span class="c1">&#9632; Oracle Universal Installer (OUI)</span></p><p class="c0"><span class="c1">OUI is a GUI utility that enables you to view, install, and deinstall Oracle Database</span></p><p class="c0"><span class="c1">software. Online Help is available to guide you through the installation. See Oracle</span></p><p class="c0"><span class="c1">Database Installation Guide to learn how to install Oracle Database software.</span></p><p class="c0"><span class="c1">&#9632; Database Upgrade Assistant (DBUA)</span></p><p class="c0"><span class="c1">DBUA interactively guides you through a database upgrade and configures the</span></p><p class="c0"><span class="c1">database for the new release. DBUA automates the upgrade by performing all</span></p><p class="c0"><span class="c1">tasks normally performed manually. DBUA makes recommendations for</span></p><p class="c0"><span class="c1">configuration options such as tablespaces and the online redo log. See Oracle</span></p><p class="c0"><span class="c1">Database 2 Day DBA to learn how to upgrade a database with DBUA.</span></p><p class="c0"><span class="c1">&#9632; Database Configuration Assistant (DBCA)</span></p><p class="c0"><span class="c1">DBCA provides a graphical interface and guided workflow for creating and</span></p><p class="c0"><span class="c1">configuring a database. This tool enables you to create a database from</span></p><p class="c0"><span class="c1">Oracle-supplied templates or create your own database and templates. See Oracle</span></p><p class="c0"><span class="c1">Database Administrator&#39;s Guide to learn how to create a database with DBCA.</span></p><p class="c0"><span class="c1">Tools for Oracle Net Configuration and Administration</span></p><p class="c0"><span class="c1">Oracle Net Services provides enterprise wide connectivity solutions in distributed,</span></p><p class="c0"><span class="c1">heterogeneous computing environments. Oracle Net, a component of Oracle Net</span></p><p class="c0"><span class="c1">Services, enables a network session from a client application to an database. You can</span></p><p class="c0"><span class="c1">use the following tools to configure and administer Oracle Net Services:</span></p><p class="c0"><span class="c1">&#9632; Oracle Net Manager</span></p><p class="c0"><span class="c1">This tool enables you to configure Oracle Net Services for an Oracle home on a</span></p><p class="c0"><span class="c1">local client or server host. You can use Oracle Net Manager to configure naming,</span></p><p class="c0"><span class="c1">naming methods, profiles, and listeners. You can start Oracle Net Manager using</span></p><p class="c0"><span class="c1">the Oracle Enterprise Manager Console or as an independent application.</span></p><p class="c0"><span class="c1">See Also: Oracle Database 2 Day DBA and SQL*Plus User&#39;s Guide and</span></p><p class="c0"><span class="c1">Reference to learn more about SQL*PlusTools for Database Administrators</span></p><p class="c0"><span class="c1">Concepts for Database Administrators 18-5</span></p><p class="c0"><span class="c1">&#9632; Oracle Net Configuration Assistant</span></p><p class="c0"><span class="c1">This tools runs automatically during software installation. The Assistant enables</span></p><p class="c0"><span class="c1">you to configure basic network components during installation, including listener</span></p><p class="c0"><span class="c1">names and protocol addresses, naming methods, net service names in a</span></p><p class="c0"><span class="c1">tnsnames.ora file, and directory server usage.</span></p><p class="c0"><span class="c1">&#9632; Listener Control Utility</span></p><p class="c0"><span class="c1">The Listener Control utility enables you to configure listeners to receive client</span></p><p class="c0"><span class="c1">connections (see &quot;The Oracle Net Listener&quot; on page 16-6). You can access the utility</span></p><p class="c0"><span class="c1">through Enterprise Manager or as a standalone command-line application.</span></p><p class="c0"><span class="c1">&#9632; Oracle Connection Manager Control Utility</span></p><p class="c0"><span class="c1">This command-line utility enables you to administer an Oracle Connection</span></p><p class="c0"><span class="c1">Manager, which is a router through which a client connection request may be sent</span></p><p class="c0"><span class="c1">either to its next hop or directly to the database. You can use utility commands to</span></p><p class="c0"><span class="c1">perform basic management functions on one or more Oracle Connection</span></p><p class="c0"><span class="c1">Managers. Additionally, you can view and change parameter settings.</span></p><p class="c0"><span class="c1">Tools for Data Movement and Analysis</span></p><p class="c0"><span class="c1">Oracle Database includes several utilities to assist in database movement and analysis.</span></p><p class="c0"><span class="c1">For example, you can use database utilities to:</span></p><p class="c0"><span class="c1">&#9632; Load data into Oracle Database tables from operating system files, as explained in</span></p><p class="c0"><span class="c1">&quot;SQL*Loader&quot; on page 18-5</span></p><p class="c0"><span class="c1">&#9632; Move data and metadata from one database to another database, as explained in</span></p><p class="c0"><span class="c1">&quot;Oracle Data Pump Export and Import&quot; on page 18-7</span></p><p class="c0"><span class="c1">&#9632; Query redo log files through a SQL interface, as explained in &quot;Oracle LogMiner&quot;</span></p><p class="c0"><span class="c1">on page 18-8</span></p><p class="c0"><span class="c1">&#9632; Manage Oracle Database diagnostic data, as explained in &quot;ADR Command</span></p><p class="c0"><span class="c1">Interpreter (ADRCI)&quot; on page 18-8</span></p><p class="c0"><span class="c1">Other tasks include performing physical data structure integrity checks on an offline</span></p><p class="c0"><span class="c1">database or data file with DBVERIFY, or changing the database identifier (DBID) or</span></p><p class="c0"><span class="c1">database name for an operational database using the DBNEWID utility.</span></p><p class="c0"><span class="c1">SQL*Loader</span></p><p class="c0"><span class="c1">SQL*Loader loads data from external files, called data files, into database tables. It</span></p><p class="c0"><span class="c1">has a powerful data parsing engine that puts little limitation on the format of the data</span></p><p class="c0"><span class="c1">in the data file. You can use SQL*Loader to perform tasks such as:</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Overview of Oracle Networking Architecture&quot; on page 16-5</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Net Services Administrator&#39;s Guide and Oracle</span></p><p class="c0"><span class="c1">Database Net Services Reference to learn more about Oracle Net</span></p><p class="c0"><span class="c1">Services tools</span></p><p class="c0"><span class="c1">Note: Tools related to backup and recovery are covered in &quot;Backup</span></p><p class="c0"><span class="c1">and Recovery&quot; on page 18-9.</span></p><p class="c0"><span class="c1">See Also: Oracle Database Utilities to learn about DBVERIFY and</span></p><p class="c0"><span class="c1">DBNEWIDTools for Database Administrators</span></p><p class="c0"><span class="c1">18-6 Oracle Database Concepts</span></p><p class="c0"><span class="c1">&#9632; Loading data from multiple data files into multiple tables</span></p><p class="c0"><span class="c1">You store the data to be loaded in SQL*Loader data files. The SQL*Loader control</span></p><p class="c0"><span class="c1">file is a text file that contains DDL instructions that SQL*Loader uses to determine</span></p><p class="c0"><span class="c1">where to find the data, how to parse and interpret it, where to insert it, and more.</span></p><p class="c0"><span class="c1">&#9632; Control various aspects of the load operation</span></p><p class="c0"><span class="c1">For example, you can selectively load data, specify the data character set (see</span></p><p class="c0"><span class="c1">&quot;Character Sets&quot; on page 19-9), manipulate the data with SQL functions, generate</span></p><p class="c0"><span class="c1">unique sequential key values in specified columns, and so on. You can also</span></p><p class="c0"><span class="c1">generate sophisticated error reports.</span></p><p class="c0"><span class="c1">&#9632; Use either conventional or direct path loading</span></p><p class="c0"><span class="c1">A conventional path load executes SQL INSERT statements to populate tables. In</span></p><p class="c0"><span class="c1">contrast, a direct path load eliminates much of the database overhead by</span></p><p class="c0"><span class="c1">formatting data blocks and writing them directly to the database files. Direct</span></p><p class="c0"><span class="c1">writes operate on blocks above the high water mark and write directly to disk,</span></p><p class="c0"><span class="c1">bypassing the database buffer cache. Direct reads read directly from disk into the</span></p><p class="c0"><span class="c1">PGA, again bypassing the buffer cache.</span></p><p class="c0"><span class="c1">A typical SQL*Loader session takes as input a SQL*Loader control file and one or</span></p><p class="c0"><span class="c1">more data files. The output is an Oracle database, a log file, a bad file, and potentially,</span></p><p class="c0"><span class="c1">a discard file. Figure 18&ndash;1 illustrates the flow of a typical SQL*Loader session.</span></p><p class="c0"><span class="c1">Figure 18&ndash;1 SQL*Loader Session</span></p><p class="c0"><span class="c1">Note: The SQL*Loader data files and control file are unrelated to the</span></p><p class="c0"><span class="c1">Oracle Database data files and control file.</span></p><p class="c0"><span class="c1">See Also: Oracle Database 2 Day DBA and Oracle Database Utilities to</span></p><p class="c0"><span class="c1">learn about SQL*Loader</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">Indexes</span></p><p class="c0"><span class="c1">Loader</span></p><p class="c0"><span class="c1">Control</span></p><p class="c0"><span class="c1">File</span></p><p class="c0"><span class="c1">Bad</span></p><p class="c0"><span class="c1">Files</span></p><p class="c0"><span class="c1">Discard</span></p><p class="c0"><span class="c1">Files</span></p><p class="c0"><span class="c1">Input</span></p><p class="c0"><span class="c1">Data</span></p><p class="c0"><span class="c1">Files</span></p><p class="c0"><span class="c1">Table</span></p><p class="c0"><span class="c1">Table Tables</span></p><p class="c0"><span class="c1">Log</span></p><p class="c0"><span class="c1">File</span></p><p class="c0"><span class="c1">SQL*LoaderTools for Database Administrators</span></p><p class="c0"><span class="c1">Concepts for Database Administrators 18-7</span></p><p class="c0"><span class="c1">Oracle Data Pump Export and Import</span></p><p class="c0"><span class="c1">Oracle Data Pump enables high-speed movement of data and metadata from one</span></p><p class="c0"><span class="c1">database to another. This technology is the basis for the following Oracle Database</span></p><p class="c0"><span class="c1">data movement utilities:</span></p><p class="c0"><span class="c1">&#9632; Data Pump Export (Export)</span></p><p class="c0"><span class="c1">Export is a utility for unloading data and metadata into a set of operating system</span></p><p class="c0"><span class="c1">files called a dump file set. The dump file set is made up of one or more binary</span></p><p class="c0"><span class="c1">files that contain table data, database object metadata, and control information.</span></p><p class="c0"><span class="c1">&#9632; Data Pump Import (Import)</span></p><p class="c0"><span class="c1">Import is a utility for loading an export dump file set into a database. You can also</span></p><p class="c0"><span class="c1">use Import to load a destination database directly from a source database with no</span></p><p class="c0"><span class="c1">intervening files, which allows export and import operations to run concurrently,</span></p><p class="c0"><span class="c1">minimizing total elapsed time.</span></p><p class="c0"><span class="c1">Oracle Data Pump is made up of the following distinct parts:</span></p><p class="c0"><span class="c1">&#9632; The command-line clients expdp and impdp</span></p><p class="c0"><span class="c1">These client make calls to the DBMS_DATAPUMP package to perform Oracle Data</span></p><p class="c0"><span class="c1">Pump operations (see &quot;PL/SQL Packages&quot; on page 8-6).</span></p><p class="c0"><span class="c1">&#9632; The DBMS_DATAPUMP PL/SQL package, also known as the Data Pump API</span></p><p class="c0"><span class="c1">This API provides high-speed import and export functionality.</span></p><p class="c0"><span class="c1">&#9632; The DBMS_METADATA PL/SQL package, also known as the Metadata API</span></p><p class="c0"><span class="c1">This API, which stores object definitions in XML, is used by all processes that load</span></p><p class="c0"><span class="c1">and unload metadata.</span></p><p class="c0"><span class="c1">Figure 18&ndash;2 shows how Oracle Data Pump integrates with SQL*Loader and external</span></p><p class="c0"><span class="c1">tables. As shown, SQL*Loader is integrated with the External Table API and the Data</span></p><p class="c0"><span class="c1">Pump API to load data into external tables (see &quot;External Tables&quot; on page 2-16).</span></p><p class="c0"><span class="c1">Clients such as Database Control and transportable tablespaces can use the Oracle</span></p><p class="c0"><span class="c1">Data Pump infrastructure.Tools for Database Administrators</span></p><p class="c0"><span class="c1">18-8 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Figure 18&ndash;2 Oracle Data Pump Architecture</span></p><p class="c0"><span class="c1">Oracle LogMiner</span></p><p class="c0"><span class="c1">Oracle LogMiner enables you to query redo log files through a SQL interface.</span></p><p class="c0"><span class="c1">Potential uses for data contained in redo log files include:</span></p><p class="c0"><span class="c1">&#9632; Pinpointing when a logical corruption to a database, such as errors made at the</span></p><p class="c0"><span class="c1">application level, may have begun</span></p><p class="c0"><span class="c1">&#9632; Detecting user error</span></p><p class="c0"><span class="c1">&#9632; Determining what actions you would have to take to perform fine-grained</span></p><p class="c0"><span class="c1">recovery at the transaction level</span></p><p class="c0"><span class="c1">&#9632; Using trend analysis to determine which tables get the most updates and inserts</span></p><p class="c0"><span class="c1">&#9632; Analyzing system behavior and auditing database use through the LogMiner</span></p><p class="c0"><span class="c1">comprehensive relational interface to redo log files</span></p><p class="c0"><span class="c1">LogMiner is accessible through a command-line interface or through the Oracle</span></p><p class="c0"><span class="c1">LogMiner Viewer GUI, which is a part of Enterprise Manager.</span></p><p class="c0"><span class="c1">ADR Command Interpreter (ADRCI)</span></p><p class="c0"><span class="c1">ADRCI is a command-line utility that enables you to investigate problems, view</span></p><p class="c0"><span class="c1">health check reports, and package and upload first-failure diagnostic data to Oracle</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Utilities for an overview of Oracle Data Pump</span></p><p class="c0"><span class="c1">&#9632; Oracle Database PL/SQL Packages and Types Reference for a</span></p><p class="c0"><span class="c1">description of DBMS_DATAPUMP and DBMS_METADATA</span></p><p class="c0"><span class="c1">See Also: Oracle Database Utilities to learn more about LogMiner</span></p><p class="c0"><span class="c1">Other Clients</span></p><p class="c0"><span class="c1">Oracle Data</span></p><p class="c0"><span class="c1">Pump Export</span></p><p class="c0"><span class="c1">(expdp)</span></p><p class="c0"><span class="c1">Oracle Data</span></p><p class="c0"><span class="c1">Pump Import</span></p><p class="c0"><span class="c1">(impdb)</span></p><p class="c0"><span class="c1">Data Pump API (DBMS_DATAPUMP)</span></p><p class="c0"><span class="c1">SQL*Loader</span></p><p class="c0"><span class="c1">ORACLE_LOADER</span></p><p class="c0"><span class="c1">Access Driver</span></p><p class="c0"><span class="c1">External Table API</span></p><p class="c0"><span class="c1">Direct Path API Metadata API</span></p><p class="c0"><span class="c1">(DBMS_METADATA)</span></p><p class="c0"><span class="c1">ORACLE_DATAPUMP</span></p><p class="c0"><span class="c1">Access Driver</span></p><p class="c0"><span class="c1">Oracle Data PumpTopics for Database Administrators</span></p><p class="c0"><span class="c1">Concepts for Database Administrators 18-9</span></p><p class="c0"><span class="c1">Support. You can also use the utility to view the names of the trace files in the</span></p><p class="c0"><span class="c1">Automatic Diagnostic Repository (ADR) (ADR) and to view the alert log. ADRCI has</span></p><p class="c0"><span class="c1">a rich command set that you can use interactively or in scripts.</span></p><p class="c0"><span class="c1">Topics for Database Administrators</span></p><p class="c0"><span class="c1">Chapter 17 describes topics important for both developers and DBAs. This section</span></p><p class="c0"><span class="c1">covers topics that are most essential to DBAs and that have not been discussed</span></p><p class="c0"><span class="c1">elsewhere in the manual.</span></p><p class="c0"><span class="c1">This section contains the following topics:</span></p><p class="c0"><span class="c1">&#9632; Backup and Recovery</span></p><p class="c0"><span class="c1">&#9632; Memory Management</span></p><p class="c0"><span class="c1">&#9632; Resource Management and Task Scheduling</span></p><p class="c0"><span class="c1">&#9632; Performance Diagnostics and Tuning</span></p><p class="c0"><span class="c1">Backup and Recovery</span></p><p class="c0"><span class="c1">Backup and recovery is the set of concepts, procedures, and strategies involved in</span></p><p class="c0"><span class="c1">protecting the database against data loss caused by media failure or users errors. In</span></p><p class="c0"><span class="c1">general, the purpose of a backup and recovery strategy is to protect the database</span></p><p class="c0"><span class="c1">against data loss and reconstruct lost data.</span></p><p class="c0"><span class="c1">A backup is a copy of data. A backup can include crucial parts of the database such as</span></p><p class="c0"><span class="c1">data files, the server parameter file, and control file. A sample backup and recovery</span></p><p class="c0"><span class="c1">scenario is a failed disk drive that causes the loss of a data file. If a backup of the lost</span></p><p class="c0"><span class="c1">file exists, then you can restore and recover it. Media recovery refers to the operations</span></p><p class="c0"><span class="c1">involved in restoring data to its state before the loss occurred.</span></p><p class="c0"><span class="c1">Backup and Recovery Techniques</span></p><p class="c0"><span class="c1">You can use the following means to back up and recover an Oracle database:</span></p><p class="c0"><span class="c1">&#9632; Recovery Manager (RMAN)</span></p><p class="c0"><span class="c1">RMAN is an Oracle Database utility that integrates with an Oracle database to</span></p><p class="c0"><span class="c1">perform backup and recovery activities, including maintaining a repository of</span></p><p class="c0"><span class="c1">historical backup metadata in the control file of every database that it backs up.</span></p><p class="c0"><span class="c1">RMAN can also maintain a centralized backup repository called a recovery</span></p><p class="c0"><span class="c1">catalog in a different database. RMAN is an Oracle Database feature and does not</span></p><p class="c0"><span class="c1">require separate installation.</span></p><p class="c0"><span class="c1">RMAN is integrated with Oracle Secure Backup, which provides reliable,</span></p><p class="c0"><span class="c1">centralized tape backup management, protecting file system data and Oracle</span></p><p class="c0"><span class="c1">Database files. The Oracle Secure Backup SBT interface enables you to use RMAN</span></p><p class="c0"><span class="c1">to back up and restore database files to and from tape and internet-based Web</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Automatic Diagnostic Repository&quot; on page 13-18</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Utilities and Oracle Database Administrator&#39;s Guide</span></p><p class="c0"><span class="c1">for more information on ADR and ADRCI</span></p><p class="c0"><span class="c1">See Also: Oracle Database 2 Day DBA and Oracle Database Backup and</span></p><p class="c0"><span class="c1">Recovery User&#39;s Guide for backup and recovery concepts and tasksTopics for Database Administrators</span></p><p class="c0"><span class="c1">18-10 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Services such as Amazon S3. Oracle Secure Backup supports almost every tape</span></p><p class="c0"><span class="c1">drive and tape library in SAN and SCSI environments.</span></p><p class="c0"><span class="c1">RMAN and Oracle Secure Backup are accessible both from the command line and</span></p><p class="c0"><span class="c1">from Enterprise Manager.</span></p><p class="c0"><span class="c1">&#9632; User-Managed techniques</span></p><p class="c0"><span class="c1">As an alternative to RMAN, you can use operating system commands such as the</span></p><p class="c0"><span class="c1">Linux dd for backing up and restoring files and the SQL*Plus RECOVER command</span></p><p class="c0"><span class="c1">for media recovery. User-managed backup and recovery is fully supported by</span></p><p class="c0"><span class="c1">Oracle, although RMAN is recommended because it is integrated with Oracle</span></p><p class="c0"><span class="c1">Database and simplifies administration.</span></p><p class="c0"><span class="c1">Figure 18&ndash;3 shows basic RMAN architecture. The RMAN client, accessible through</span></p><p class="c0"><span class="c1">Enterprise Manager, uses server sessions on a target database to back up data to disk</span></p><p class="c0"><span class="c1">or tape. RMAN can update an external recovery catalog with backup metadata.</span></p><p class="c0"><span class="c1">Figure 18&ndash;3 RMAN Architecture</span></p><p class="c0"><span class="c1">Whichever backup and recovery technique you use, Oracle recommends that you</span></p><p class="c0"><span class="c1">configure a fast recovery area. This database-managed directory, file system, or Oracle</span></p><p class="c0"><span class="c1">ASM disk group centralizes backup and recovery files, including active control files,</span></p><p class="c0"><span class="c1">online and archived redo log files, and backups. Oracle Database recovery</span></p><p class="c0"><span class="c1">components interact with the fast recovery area to ensure database recoverability.</span></p><p class="c0"><span class="c1">Target</span></p><p class="c0"><span class="c1">Host</span></p><p class="c0"><span class="c1">Client Host</span></p><p class="c0"><span class="c1">Oracle</span></p><p class="c0"><span class="c1">ASM</span></p><p class="c0"><span class="c1">Tape</span></p><p class="c0"><span class="c1">Target</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">Server Process Server Process</span></p><p class="c0"><span class="c1">Recovery</span></p><p class="c0"><span class="c1">Catalog</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">Catalog</span></p><p class="c0"><span class="c1">Host</span></p><p class="c0"><span class="c1">RMAN Client</span></p><p class="c0"><span class="c1">Oracle Net</span></p><p class="c0"><span class="c1">Oracle NetTopics for Database Administrators</span></p><p class="c0"><span class="c1">Concepts for Database Administrators 18-11</span></p><p class="c0"><span class="c1">Database Backups</span></p><p class="c0"><span class="c1">Database backups can be either physical or logical. Physical backups, which are the</span></p><p class="c0"><span class="c1">primary concern in a backup and recovery strategy, are copies of physical database</span></p><p class="c0"><span class="c1">files. You can make physical backups with RMAN or operating system utilities.</span></p><p class="c0"><span class="c1">In contrast, logical backups contain logical data such as tables and stored procedures.</span></p><p class="c0"><span class="c1">You can extract logical data with an Oracle Database utility such as Data Pump Export</span></p><p class="c0"><span class="c1">and store it in a binary file. Logical backups can supplement physical backups.</span></p><p class="c0"><span class="c1">Physical backups have large granularity and limited transportability, but are very fast.</span></p><p class="c0"><span class="c1">Logical backups have fine granularity and complete transportability, but are slower</span></p><p class="c0"><span class="c1">than physical backups.</span></p><p class="c0"><span class="c1">Whole and Partial Database Backups A whole database backup is a backup of every data</span></p><p class="c0"><span class="c1">file in the database, plus the control file. Whole database backups are the most</span></p><p class="c0"><span class="c1">common type of backup.</span></p><p class="c0"><span class="c1">A partial database backup includes a subset of the database: individual tablespaces or</span></p><p class="c0"><span class="c1">data files. A tablespace backup is a backup of all the data files in a tablespace or in</span></p><p class="c0"><span class="c1">multiple tablespaces. Tablespace backups, whether consistent or inconsistent, are valid</span></p><p class="c0"><span class="c1">only if the database is operating in ARCHIVELOG mode because redo is required to make</span></p><p class="c0"><span class="c1">the restored tablespace consistent with the rest of the database.</span></p><p class="c0"><span class="c1">Consistent and Inconsistent Backups A whole database backup is either consistent or</span></p><p class="c0"><span class="c1">inconsistent. In a consistent backup, all read/write data files and control files have the</span></p><p class="c0"><span class="c1">same checkpoint SCN, guaranteeing that these files contain all changes up to this</span></p><p class="c0"><span class="c1">SCN. This type of backup does not require recovery after it is restored.</span></p><p class="c0"><span class="c1">A consistent backup of the database is only possible after a consistent shutdown (see</span></p><p class="c0"><span class="c1">&quot;Shutdown Modes&quot; on page 13-9) and is the only valid backup option for a database</span></p><p class="c0"><span class="c1">operating in NOARCHIVELOG mode. Other backup options require media recovery for</span></p><p class="c0"><span class="c1">consistency, which is not possible without applying archived redo log files.</span></p><p class="c0"><span class="c1">In an inconsistent backup, read/write data files and control files are not guaranteed</span></p><p class="c0"><span class="c1">to have the same checkpoint SCN, so changes can be missing. All online backups are</span></p><p class="c0"><span class="c1">necessarily inconsistent because data files can be modified while backups occur.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database 2 Day DBA to learn how to perform backup and</span></p><p class="c0"><span class="c1">recovery with Enterprise Manager</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Backup and Recovery User&#39;s Guide for an</span></p><p class="c0"><span class="c1">overview of backup and recovery solutions</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide for information about how</span></p><p class="c0"><span class="c1">to set up and administer the fast recovery area</span></p><p class="c0"><span class="c1">&#9632; Oracle Secure Backup Administrator&#39;s Guide for an overview of</span></p><p class="c0"><span class="c1">Oracle Secure Backup</span></p><p class="c0"><span class="c1">See Also: Oracle Database Backup and Recovery User&#39;s Guide to learn</span></p><p class="c0"><span class="c1">about physical and logical backups</span></p><p class="c0"><span class="c1">Note: If you restore a consistent whole database backup without</span></p><p class="c0"><span class="c1">applying redo, then you lose all transactions made after the backup.Topics for Database Administrators</span></p><p class="c0"><span class="c1">18-12 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Inconsistent backups offer superior availability because you do not have to shut down</span></p><p class="c0"><span class="c1">the database to make backups that fully protect the database. If the database runs in</span></p><p class="c0"><span class="c1">ARCHIVELOG mode, and if you back up the archived redo logs and data files, then</span></p><p class="c0"><span class="c1">inconsistent backups can be the foundation for a sound backup and recovery strategy.</span></p><p class="c0"><span class="c1">Backup Sets and Image Copies The RMAN BACKUP command generates either image</span></p><p class="c0"><span class="c1">copies or backup sets. An image copy is a bit-for-bit, on-disk duplicate of a data file,</span></p><p class="c0"><span class="c1">control file, or archived redo log file. You can create image copies of physical files with</span></p><p class="c0"><span class="c1">operating system utilities or RMAN and use either tool to restore them.</span></p><p class="c0"><span class="c1">RMAN can also create backups in a proprietary format called a backup set. A backup</span></p><p class="c0"><span class="c1">set contains the data from one or more data files, archived redo log files, or control files</span></p><p class="c0"><span class="c1">or server parameter file. The smallest unit of a backup set is a binary file called a</span></p><p class="c0"><span class="c1">backup piece. Backup sets are the only form in which RMAN can write backups to</span></p><p class="c0"><span class="c1">sequential devices such as tape drives.</span></p><p class="c0"><span class="c1">Backup sets enable tape devices to stream continuously. For example, RMAN can</span></p><p class="c0"><span class="c1">mingle blocks from slow, medium, and fast disks into one backup set so that the tape</span></p><p class="c0"><span class="c1">device has a constant input of blocks. Image copies are useful for disk because you can</span></p><p class="c0"><span class="c1">update them incrementally, and also recover them in place.</span></p><p class="c0"><span class="c1">Data Repair</span></p><p class="c0"><span class="c1">While several problems can halt the normal operation of a database or affect I/O</span></p><p class="c0"><span class="c1">operations, only the following typically require DBA intervention and data repair:</span></p><p class="c0"><span class="c1">&#9632; Media failures</span></p><p class="c0"><span class="c1">A media failure occurs when a problem external to the database prevents it from</span></p><p class="c0"><span class="c1">reading from or writing to a file. Typical media failures include physical failures,</span></p><p class="c0"><span class="c1">such as head crashes, and the overwriting, deletion, or corruption of a database</span></p><p class="c0"><span class="c1">file. Media failures are less common than user or application errors, but a sound</span></p><p class="c0"><span class="c1">recovery strategy must prepare for them.</span></p><p class="c0"><span class="c1">&#9632; User errors</span></p><p class="c0"><span class="c1">A user or application may make unwanted changes to your database, such as</span></p><p class="c0"><span class="c1">erroneous updates, deleting the contents of a table, or dropping database objects</span></p><p class="c0"><span class="c1">(see &quot;Human Errors&quot; on page 17-10). A good backup and recovery strategy enables</span></p><p class="c0"><span class="c1">you to return your database to the desired state, with the minimum possible</span></p><p class="c0"><span class="c1">impact upon database availability, and minimal DBA effort.</span></p><p class="c0"><span class="c1">Typically, you have multiple ways to solve the preceding problems. This section</span></p><p class="c0"><span class="c1">summarizes some of these solutions.</span></p><p class="c0"><span class="c1">See Also: Oracle Database Backup and Recovery User&#39;s Guide to learn</span></p><p class="c0"><span class="c1">more about inconsistent backups</span></p><p class="c0"><span class="c1">Note: Unlike operating system copies, RMAN validates the blocks</span></p><p class="c0"><span class="c1">in the file and records the image copy in the RMAN repository.</span></p><p class="c0"><span class="c1">See Also: Oracle Database Backup and Recovery User&#39;s Guide to learn</span></p><p class="c0"><span class="c1">more about backup sets and image copies</span></p><p class="c0"><span class="c1">See Also: Oracle Database 2 Day DBA and Oracle Database Backup and</span></p><p class="c0"><span class="c1">Recovery User&#39;s Guide for data repair conceptsTopics for Database Administrators</span></p><p class="c0"><span class="c1">Concepts for Database Administrators 18-13</span></p><p class="c0"><span class="c1">Data Recovery Advisor The Data Recovery Advisor tool automatically diagnoses</span></p><p class="c0"><span class="c1">persistent data failures, presents appropriate repair options, and executes repairs at the</span></p><p class="c0"><span class="c1">user&#39;s request. By providing a centralized tool for automated data repair, Data</span></p><p class="c0"><span class="c1">Recovery Advisor improves the manageability and reliability of an Oracle database</span></p><p class="c0"><span class="c1">and thus helps reduce recovery time.</span></p><p class="c0"><span class="c1">The database includes a framework called Health Monitor for running diagnostic</span></p><p class="c0"><span class="c1">checks. A checker is a diagnostic operation or procedure registered with Health</span></p><p class="c0"><span class="c1">Monitor to assess the health of the database or its components. The health assessment</span></p><p class="c0"><span class="c1">is known as a data integrity check and can be invoked reactively or proactively.</span></p><p class="c0"><span class="c1">A failure is a persistent data corruption detected by a data integrity check. Failures are</span></p><p class="c0"><span class="c1">normally detected reactively. A database operation involving corrupted data results in</span></p><p class="c0"><span class="c1">an error, which automatically invokes a data integrity check that searches the database</span></p><p class="c0"><span class="c1">for failures related to the error. If failures are diagnosed, then the database records</span></p><p class="c0"><span class="c1">them in the Automatic Diagnostic Repository (ADR).</span></p><p class="c0"><span class="c1">After failures have been detected by the database and stored in ADR, Data Recovery</span></p><p class="c0"><span class="c1">Advisor automatically determines the best repair options and their impact on the</span></p><p class="c0"><span class="c1">database. Typically, Data Recovery Advisor generates both manual and automated</span></p><p class="c0"><span class="c1">repair options for each failure or group of failures.</span></p><p class="c0"><span class="c1">Before presenting an automated repair option, Data Recovery Advisor validates it for</span></p><p class="c0"><span class="c1">the specific environment and for the availability of media components required to</span></p><p class="c0"><span class="c1">complete the proposed repair. If you choose an automatic repair, then Oracle Database</span></p><p class="c0"><span class="c1">executes it for you. The Data Recovery Advisor tool verifies the repair success and</span></p><p class="c0"><span class="c1">closes the appropriate failures.</span></p><p class="c0"><span class="c1">Oracle Flashback Technology Oracle Database provides a group of features known as</span></p><p class="c0"><span class="c1">Oracle Flashback Technology that support viewing past states of data, and winding</span></p><p class="c0"><span class="c1">data back and forth in time, without needing to restore backups. Depending on the</span></p><p class="c0"><span class="c1">database changes, flashback features can often reverse unwanted changes more</span></p><p class="c0"><span class="c1">quickly and with less impact on availability than media recovery.</span></p><p class="c0"><span class="c1">The following flashback features are most relevant for backup and recovery:</span></p><p class="c0"><span class="c1">&#9632; Flashback Database</span></p><p class="c0"><span class="c1">You can rewind an Oracle database to a previous time to correct problems caused</span></p><p class="c0"><span class="c1">by logical data corruptions or user errors. Flashback Database can also be used to</span></p><p class="c0"><span class="c1">complement Data Guard, Data Recovery Advisor, and for synchronizing clone</span></p><p class="c0"><span class="c1">databases. Flashback Database does not restore or perform media recovery on</span></p><p class="c0"><span class="c1">files, so you cannot use it to correct media failures such as disk crashes.</span></p><p class="c0"><span class="c1">&#9632; Flashback Table</span></p><p class="c0"><span class="c1">You can rewind tables to a specified point in time with a single SQL statement.</span></p><p class="c0"><span class="c1">You can restore table data along with associated indexes, triggers, and constraints,</span></p><p class="c0"><span class="c1">while the database is online, undoing changes to only the specified tables.</span></p><p class="c0"><span class="c1">Flashback Table does not address physical corruption such as bad disks or data</span></p><p class="c0"><span class="c1">segment and index inconsistencies.</span></p><p class="c0"><span class="c1">&#9632; Flashback Drop</span></p><p class="c0"><span class="c1">You can reverse the effects of a DROP TABLE operation. Flashback Drop is</span></p><p class="c0"><span class="c1">substantially faster than recovery mechanisms such as point-in-time recovery and</span></p><p class="c0"><span class="c1">does not lead to loss of recent transactions or downtime.</span></p><p class="c0"><span class="c1">See Also: Oracle Database 2 Day DBA and Oracle Database Backup and</span></p><p class="c0"><span class="c1">Recovery User&#39;s Guide to learn how to use Data Recovery AdvisorTopics for Database Administrators</span></p><p class="c0"><span class="c1">18-14 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Block Media Recovery A block corruption is a data block that is not in a recognized</span></p><p class="c0"><span class="c1">Oracle format, or whose contents are not internally consistent (see &quot;Data Corruption&quot;</span></p><p class="c0"><span class="c1">on page 17-9). Block media recovery is a technique for restoring and recovering</span></p><p class="c0"><span class="c1">corrupt data blocks while data files are online. If only a few blocks are corrupt, then</span></p><p class="c0"><span class="c1">block recovery may be preferable to data file recovery.</span></p><p class="c0"><span class="c1">Data File Recovery Data file recovery repairs a lost or damaged current data file or</span></p><p class="c0"><span class="c1">control file. It can also recover changes lost when a tablespace went offline without the</span></p><p class="c0"><span class="c1">OFFLINE NORMAL option.</span></p><p class="c0"><span class="c1">Media recovery is necessary if you restore a backup of a data file or control file or a</span></p><p class="c0"><span class="c1">data file is taken offline without the OFFLINE NORMAL option. The database cannot be</span></p><p class="c0"><span class="c1">opened if online data files needs media recovery, nor can a data file that needs media</span></p><p class="c0"><span class="c1">recovery be brought online until media recovery completes.</span></p><p class="c0"><span class="c1">To restore a physical backup of a data file or control file is to reconstruct it and make it</span></p><p class="c0"><span class="c1">available to Oracle Database. To recover a backup is to apply archived redo log files,</span></p><p class="c0"><span class="c1">thereby reconstructing lost changes. RMAN can also recover data files with</span></p><p class="c0"><span class="c1">incremental backups, which contain only blocks modified after a previous backup.</span></p><p class="c0"><span class="c1">Unlike instance recovery, which automatically applies changes to online files, media</span></p><p class="c0"><span class="c1">recovery must be invoked by a user and applies archived redo log files to restored</span></p><p class="c0"><span class="c1">backups. Data file media recovery can only operate on offline data files or data files in</span></p><p class="c0"><span class="c1">a database that is not opened by any instance.</span></p><p class="c0"><span class="c1">Data file media recovery differs depending on whether all changes are applied:</span></p><p class="c0"><span class="c1">&#9632; Complete recovery</span></p><p class="c0"><span class="c1">Complete recovery applies all redo changes contained in the archived and online</span></p><p class="c0"><span class="c1">logs to a backup. Typically, you perform complete media recovery after a media</span></p><p class="c0"><span class="c1">failure damages data files or the control file. You can perform complete recovery</span></p><p class="c0"><span class="c1">on a database, tablespace, or data file.</span></p><p class="c0"><span class="c1">&#9632; Incomplete recovery</span></p><p class="c0"><span class="c1">Incomplete recovery, also called database point-in-time recovery, results in a</span></p><p class="c0"><span class="c1">noncurrent version of the database. In this case, you do not apply all of the redo</span></p><p class="c0"><span class="c1">generated after the restored backup. Typically, you perform point-in-time database</span></p><p class="c0"><span class="c1">recovery to undo a user error when Flashback Database is not possible.</span></p><p class="c0"><span class="c1">To perform incomplete recovery, you must restore all data files from backups</span></p><p class="c0"><span class="c1">created before the time to which you want to recover and then open the database</span></p><p class="c0"><span class="c1">with the RESETLOGS option when recovery completes. Resetting the logs creates a</span></p><p class="c0"><span class="c1">new stream of log sequence numbers starting with log sequence 1.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database 2 Day DBA and Oracle Database Backup and</span></p><p class="c0"><span class="c1">Recovery User&#39;s Guide to learn more about flashback features</span></p><p class="c0"><span class="c1">&#9632; Oracle Database SQL Language Reference and Oracle Database</span></p><p class="c0"><span class="c1">Backup and Recovery Reference to learn about the FLASHBACK</span></p><p class="c0"><span class="c1">DATABASE statement</span></p><p class="c0"><span class="c1">See Also: Oracle Database Backup and Recovery User&#39;s Guide to learn</span></p><p class="c0"><span class="c1">how to perform block media recoveryTopics for Database Administrators</span></p><p class="c0"><span class="c1">Concepts for Database Administrators 18-15</span></p><p class="c0"><span class="c1">The tablespace point-in-time recovery (TSPITR) feature lets you recover one or</span></p><p class="c0"><span class="c1">more tablespaces to a point in time older than the rest of the database.</span></p><p class="c0"><span class="c1">Memory Management</span></p><p class="c0"><span class="c1">Memory management involves maintaining optimal sizes for the Oracle instance</span></p><p class="c0"><span class="c1">memory structures as demands on the database change. Initialization parameter</span></p><p class="c0"><span class="c1">settings determine how SGA and instance PGA memory is managed.</span></p><p class="c0"><span class="c1">Figure 18&ndash;4 shows a decision tree for memory management options. The following</span></p><p class="c0"><span class="c1">sections explain the options in detail.</span></p><p class="c0"><span class="c1">Figure 18&ndash;4 Memory Management Methods</span></p><p class="c0"><span class="c1">Automatic Memory Management</span></p><p class="c0"><span class="c1">In automatic memory management, Oracle Database manages the SGA and instance</span></p><p class="c0"><span class="c1">PGA memory completely automatically. This method is the simplest and is strongly</span></p><p class="c0"><span class="c1">recommended by Oracle.</span></p><p class="c0"><span class="c1">Note: If current data files are available, then Flashback Database is</span></p><p class="c0"><span class="c1">an alternative to DBPITR.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Overview of Instance Recovery&quot; on page 13-12</span></p><p class="c0"><span class="c1">&#9632; Oracle Database 2 Day DBA and Oracle Database Backup and Recovery</span></p><p class="c0"><span class="c1">User&#39;s Guide for media recovery concepts</span></p><p class="c0"><span class="c1">See Also: Chapter 14, &quot;Memory Architecture&quot; to learn more about</span></p><p class="c0"><span class="c1">the SGA and PGA</span></p><p class="c0"><span class="c1">Automatic Memory Management (SGA and PGA)</span></p><p class="c0"><span class="c1">Automatic Shared Memory</span></p><p class="c0"><span class="c1">Management (SGA)</span></p><p class="c0"><span class="c1">Manual Shared Memory</span></p><p class="c0"><span class="c1">Management (SGA)</span></p><p class="c0"><span class="c1">Automatic PGA Management</span></p><p class="c0"><span class="c1">Automatic PGA Management</span></p><p class="c0"><span class="c1">Manual PGA Management</span></p><p class="c0"><span class="c1">Manual PGA ManagementTopics for Database Administrators</span></p><p class="c0"><span class="c1">18-16 Oracle Database Concepts</span></p><p class="c0"><span class="c1">The only user-specified controls are the target memory size initialization parameter</span></p><p class="c0"><span class="c1">(MEMORY_TARGET) and optional maximum memory size initialization parameter</span></p><p class="c0"><span class="c1">(MEMORY_MAX_TARGET). Oracle Database tunes to the target memory size, redistributing</span></p><p class="c0"><span class="c1">memory as needed between the SGA and the instance PGA.</span></p><p class="c0"><span class="c1">Figure 18&ndash;5 shows a database that sometimes processes jobs submitted by online users</span></p><p class="c0"><span class="c1">and sometimes batch jobs. Using automatic memory management, the database</span></p><p class="c0"><span class="c1">automatically adjusts the size of the large pool and database buffer cache depending</span></p><p class="c0"><span class="c1">on which type of jobs are running.</span></p><p class="c0"><span class="c1">Figure 18&ndash;5 Automatic Memory Management</span></p><p class="c0"><span class="c1">If you create your database with DBCA and choose the basic installation option, then</span></p><p class="c0"><span class="c1">automatic memory management is enabled by default.</span></p><p class="c0"><span class="c1">Shared Memory Management of the SGA</span></p><p class="c0"><span class="c1">If automatic memory management is not enabled, then the system must use shared</span></p><p class="c0"><span class="c1">memory management of the SGA. Shared memory management is possible in either</span></p><p class="c0"><span class="c1">of the following forms:</span></p><p class="c0"><span class="c1">&#9632; Automatic shared memory management</span></p><p class="c0"><span class="c1">This mode enables you to exercise more direct control over the size of the SGA and</span></p><p class="c0"><span class="c1">is the default when automatic memory management is disabled. The database</span></p><p class="c0"><span class="c1">tunes the total SGA to the target size and dynamically tunes the sizes of SGA</span></p><p class="c0"><span class="c1">components. Oracle Database remembers the sizes of the automatically tuned</span></p><p class="c0"><span class="c1">components across instance shutdowns if you are using a server parameter file.</span></p><p class="c0"><span class="c1">&#9632; Manual shared memory management</span></p><p class="c0"><span class="c1">In this mode, you set the sizes of several individual SGA components and</span></p><p class="c0"><span class="c1">manually tune individual SGA components on an ongoing basis. You have</span></p><p class="c0"><span class="c1">complete control of individual SGA component sizes. The database defaults to this</span></p><p class="c0"><span class="c1">mode when both automatic memory management and automatic shared memory</span></p><p class="c0"><span class="c1">management are disabled.</span></p><p class="c0"><span class="c1">See Also: Oracle Database 2 Day DBA and Oracle Database</span></p><p class="c0"><span class="c1">Administrator&#39;s Guide to learn about automatic memory management</span></p><p class="c0"><span class="c1">Online Users Batch Jobs</span></p><p class="c0"><span class="c1">Streams Pool</span></p><p class="c0"><span class="c1">Java Pool</span></p><p class="c0"><span class="c1">Shared Pool</span></p><p class="c0"><span class="c1">Large Pool</span></p><p class="c0"><span class="c1">Buffer Cache</span></p><p class="c0"><span class="c1">Streams Pool</span></p><p class="c0"><span class="c1">Java Pool</span></p><p class="c0"><span class="c1">Shared Pool</span></p><p class="c0"><span class="c1">Large Pool</span></p><p class="c0"><span class="c1">Buffer CacheTopics for Database Administrators</span></p><p class="c0"><span class="c1">Concepts for Database Administrators 18-17</span></p><p class="c0"><span class="c1">Memory Management of the Instance PGA</span></p><p class="c0"><span class="c1">If automatic memory management is not enabled, then the following modes are</span></p><p class="c0"><span class="c1">possible for management of PGA memory:</span></p><p class="c0"><span class="c1">&#9632; Automatic PGA memory management</span></p><p class="c0"><span class="c1">When automatic memory management is disabled and PGA_AGGREGATE_TARGET is</span></p><p class="c0"><span class="c1">set to a nonzero value, the database uses automatic PGA memory management.</span></p><p class="c0"><span class="c1">In this mode, the PGA_AGGREGATE_TARGET specifies a target size for the instance</span></p><p class="c0"><span class="c1">PGA. The database then tunes the size of the instance PGA to this target and</span></p><p class="c0"><span class="c1">dynamically tunes the sizes of individual PGAs. If you do not explicitly set a</span></p><p class="c0"><span class="c1">target size, then the database automatically configures a reasonable default.</span></p><p class="c0"><span class="c1">&#9632; Manual PGA memory management</span></p><p class="c0"><span class="c1">When automatic memory management is disabled and PGA_AGGREGATE_TARGET is</span></p><p class="c0"><span class="c1">set to 0, the database defaults to manual PGA management. Previous releases of</span></p><p class="c0"><span class="c1">Oracle Database required the DBA to manually specify the maximum work area</span></p><p class="c0"><span class="c1">size for each type of SQL operator (such as a sort or hash join). This technique</span></p><p class="c0"><span class="c1">proved to be very difficult because the workload is always changing. Although</span></p><p class="c0"><span class="c1">Oracle Database supports the manual PGA memory management method, Oracle</span></p><p class="c0"><span class="c1">strongly recommends automatic memory management.</span></p><p class="c0"><span class="c1">Summary of Memory Management Methods</span></p><p class="c0"><span class="c1">Table 18&ndash;1 summarizes the various memory management methods. If you do not</span></p><p class="c0"><span class="c1">enable automatic memory management, then you must separately configure one</span></p><p class="c0"><span class="c1">memory management method for the SGA and one for the PGA.</span></p><p class="c0"><span class="c1">Note: When automatic memory management is disabled, the</span></p><p class="c0"><span class="c1">database may in some cases automatically adjust the relative sizes of</span></p><p class="c0"><span class="c1">the shared pool and buffer cache based on user workload.</span></p><p class="c0"><span class="c1">See Also: Oracle Database 2 Day DBA and Oracle Database</span></p><p class="c0"><span class="c1">Administrator&#39;s Guide to learn about shared memory management</span></p><p class="c0"><span class="c1">See Also: Oracle Database Performance Tuning Guide to learn about</span></p><p class="c0"><span class="c1">PGA memory management</span></p><p class="c0"><span class="c1">Note: When automatic memory management is not enabled, the</span></p><p class="c0"><span class="c1">default method for the instance PGA is automatic PGA memory</span></p><p class="c0"><span class="c1">management.Topics for Database Administrators</span></p><p class="c0"><span class="c1">18-18 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Resource Management and Task Scheduling</span></p><p class="c0"><span class="c1">In a database with many active users, resource management is an important part of</span></p><p class="c0"><span class="c1">database administration. Sessions that consume excessive resources can prevent other</span></p><p class="c0"><span class="c1">sessions from doing their work. A related problem is how to schedule tasks so that</span></p><p class="c0"><span class="c1">they run at the best time. Oracle Database provides tools to help solve these problems.</span></p><p class="c0"><span class="c1">Table 18&ndash;1 Memory Management Methods</span></p><p class="c0"><span class="c1">Instance SGA PGA Description Initialization Parameters</span></p><p class="c0"><span class="c1">Auto n/a n/a The database tunes the size of</span></p><p class="c0"><span class="c1">the instance based on a single</span></p><p class="c0"><span class="c1">instance target size.</span></p><p class="c0"><span class="c1">You set:</span></p><p class="c0"><span class="c1">&#9632; Total memory target size for the database</span></p><p class="c0"><span class="c1">instance (MEMORY_TARGET)</span></p><p class="c0"><span class="c1">&#9632; Optional maximum memory size for the</span></p><p class="c0"><span class="c1">database instance (MEMORY_MAX_TARGET)</span></p><p class="c0"><span class="c1">n/a Auto Auto The database automatically</span></p><p class="c0"><span class="c1">tunes the SGA based on an</span></p><p class="c0"><span class="c1">SGA target.</span></p><p class="c0"><span class="c1">The database automatically</span></p><p class="c0"><span class="c1">tunes the PGA based on a</span></p><p class="c0"><span class="c1">PGA target.</span></p><p class="c0"><span class="c1">You set:</span></p><p class="c0"><span class="c1">&#9632; SGA target size (SGA_TARGET)</span></p><p class="c0"><span class="c1">&#9632; Optional SGA maximum size</span></p><p class="c0"><span class="c1">(SGA_MAX_SIZE)</span></p><p class="c0"><span class="c1">&#9632; Instance PGA target size</span></p><p class="c0"><span class="c1">(PGA_AGGREGATE_TARGET)</span></p><p class="c0"><span class="c1">n/a Auto Manual The database automatically</span></p><p class="c0"><span class="c1">tunes the SGA based on an</span></p><p class="c0"><span class="c1">SGA target.</span></p><p class="c0"><span class="c1">You control the PGA</span></p><p class="c0"><span class="c1">manually, setting the</span></p><p class="c0"><span class="c1">maximum work area size for</span></p><p class="c0"><span class="c1">each type of SQL operator.</span></p><p class="c0"><span class="c1">You set:</span></p><p class="c0"><span class="c1">&#9632; SGA target size (SGA_TARGET)</span></p><p class="c0"><span class="c1">&#9632; Optional SGA maximum size</span></p><p class="c0"><span class="c1">(SGA_MAX_SIZE)</span></p><p class="c0"><span class="c1">&#9632; PGA work area parameters such as</span></p><p class="c0"><span class="c1">SORT_AREA_SIZE, HASH_AREA_SIZE, and</span></p><p class="c0"><span class="c1">BITMAP_MERGE_AREA_SIZE</span></p><p class="c0"><span class="c1">n/a Manual Auto You control the SGA</span></p><p class="c0"><span class="c1">manually by setting</span></p><p class="c0"><span class="c1">individual component sizes.</span></p><p class="c0"><span class="c1">The database automatically</span></p><p class="c0"><span class="c1">tunes the PGA based on a</span></p><p class="c0"><span class="c1">PGA target.</span></p><p class="c0"><span class="c1">You set:</span></p><p class="c0"><span class="c1">&#9632; Shared pool size (SHARED_POOL_SIZE)</span></p><p class="c0"><span class="c1">&#9632; Buffer cache size (DB_CACHE_SIZE)</span></p><p class="c0"><span class="c1">&#9632; Large pool size (LARGE_POOL_SIZE)</span></p><p class="c0"><span class="c1">&#9632; Java pool size (JAVA_POOL_SIZE)</span></p><p class="c0"><span class="c1">&#9632; Streams pool size (STREAMS_POOL_SIZE)</span></p><p class="c0"><span class="c1">&#9632; Instance PGA target size</span></p><p class="c0"><span class="c1">(PGA_AGGREGATE_TARGET)</span></p><p class="c0"><span class="c1">n/a Manual Manual You must manually configure</span></p><p class="c0"><span class="c1">SGA component sizes.</span></p><p class="c0"><span class="c1">You control the PGA</span></p><p class="c0"><span class="c1">manually, setting the</span></p><p class="c0"><span class="c1">maximum work area size for</span></p><p class="c0"><span class="c1">each type of SQL operator.</span></p><p class="c0"><span class="c1">You must manually configure SGA component</span></p><p class="c0"><span class="c1">sizes. You set:</span></p><p class="c0"><span class="c1">&#9632; Shared pool size (SHARED_POOL_SIZE)</span></p><p class="c0"><span class="c1">&#9632; Buffer cache size (DB_CACHE_SIZE)</span></p><p class="c0"><span class="c1">&#9632; Large pool size (LARGE_POOL_SIZE)</span></p><p class="c0"><span class="c1">&#9632; Java pool size (JAVA_POOL_SIZE)</span></p><p class="c0"><span class="c1">&#9632; Streams pool size (STREAMS_POOL_SIZE)</span></p><p class="c0"><span class="c1">&#9632; PGA work area parameters such as</span></p><p class="c0"><span class="c1">SORT_AREA_SIZE, HASH_AREA_SIZE, and</span></p><p class="c0"><span class="c1">BITMAP_MERGE_AREA_SIZE</span></p><p class="c0"><span class="c1">See Also: Oracle Database Administrator&#39;s Guide because automatic</span></p><p class="c0"><span class="c1">memory management is not available on all platformsTopics for Database Administrators</span></p><p class="c0"><span class="c1">Concepts for Database Administrators 18-19</span></p><p class="c0"><span class="c1">Database Resource Manager</span></p><p class="c0"><span class="c1">Oracle Database Resource Manager (the Resource Manager) is an infrastructure that</span></p><p class="c0"><span class="c1">provides granular control of database resources allocated to users, applications, and</span></p><p class="c0"><span class="c1">services. The Resource Manager solves many resource allocation problems that an</span></p><p class="c0"><span class="c1">operating system does not manage well, including:</span></p><p class="c0"><span class="c1">&#9632; Excessive overhead</span></p><p class="c0"><span class="c1">&#9632; Inefficient scheduling</span></p><p class="c0"><span class="c1">&#9632; Inappropriate allocation of resources</span></p><p class="c0"><span class="c1">&#9632; Inability to manage database-specific resources</span></p><p class="c0"><span class="c1">The Resource Manager helps overcome these problems by giving the database more</span></p><p class="c0"><span class="c1">control over allocation of hardware resources and enabling you to prioritize work</span></p><p class="c0"><span class="c1">within the database. You can classify sessions into groups based on session attributes,</span></p><p class="c0"><span class="c1">and then allocate resources to these groups to optimize hardware utilization.</span></p><p class="c0"><span class="c1">Resources are allocated to users according to a resource plan specified by the database</span></p><p class="c0"><span class="c1">administrator. The plan specifies how the resources are to be distributed among</span></p><p class="c0"><span class="c1">resource consumer groups, which are user sessions grouped by resource</span></p><p class="c0"><span class="c1">requirements. A resource plan directive associates a resource consumer group with a</span></p><p class="c0"><span class="c1">plan and specifies how resources are to be allocated to the group.</span></p><p class="c0"><span class="c1">Figure 18&ndash;6 shows a simple resource plan for an organization that runs OLTP</span></p><p class="c0"><span class="c1">applications and reporting applications simultaneously during the daytime. The</span></p><p class="c0"><span class="c1">currently active plan, DAYTIME, allocates CPU resources among three resource</span></p><p class="c0"><span class="c1">consumer groups. Specifically, OLTP is allotted 75% of the CPU time, REPORTS is allotted</span></p><p class="c0"><span class="c1">15%, and OTHER_GROUPS receives the remaining 10%.</span></p><p class="c0"><span class="c1">Figure 18&ndash;6 Simple Resource Plan</span></p><p class="c0"><span class="c1">Oracle Scheduler</span></p><p class="c0"><span class="c1">Oracle Scheduler (the Scheduler) enables database administrators and application</span></p><p class="c0"><span class="c1">developers to control when and where various tasks take place in the database</span></p><p class="c0"><span class="c1">environment. The Scheduler provides complex enterprise scheduling functionality,</span></p><p class="c0"><span class="c1">which you can use to:</span></p><p class="c0"><span class="c1">&#9632; Schedule job execution based on time or events</span></p><p class="c0"><span class="c1">&#9632; Schedule job processing in a way that models your business requirements</span></p><p class="c0"><span class="c1">See Also: Oracle Database Administrator&#39;s Guide for information</span></p><p class="c0"><span class="c1">about using the Resource Manager</span></p><p class="c0"><span class="c1">Directive 2</span></p><p class="c0"><span class="c1">15% of CPU</span></p><p class="c0"><span class="c1">Directive 3</span></p><p class="c0"><span class="c1">10% of CPU</span></p><p class="c0"><span class="c1">Directive 1</span></p><p class="c0"><span class="c1">75% of CPU</span></p><p class="c0"><span class="c1">Consumer Group</span></p><p class="c0"><span class="c1">&quot;REPORTING&quot;</span></p><p class="c0"><span class="c1">Consumer Group</span></p><p class="c0"><span class="c1">&quot;OTHER_GROUPS&quot;</span></p><p class="c0"><span class="c1">Consumer Group</span></p><p class="c0"><span class="c1">&quot;OLTP&quot;</span></p><p class="c0"><span class="c1">Resource Plan</span></p><p class="c0"><span class="c1">&quot;DAYTIME&quot;Topics for Database Administrators</span></p><p class="c0"><span class="c1">18-20 Oracle Database Concepts</span></p><p class="c0"><span class="c1">&#9632; Manage and monitor jobs</span></p><p class="c0"><span class="c1">&#9632; Execute and manage jobs in a clustered environment</span></p><p class="c0"><span class="c1">Program objects (programs) contain metadata about the command that the Scheduler</span></p><p class="c0"><span class="c1">will run, including default values for any arguments. Schedule objects (schedules)</span></p><p class="c0"><span class="c1">contain information about run date and time and recurrence patterns. Job objects</span></p><p class="c0"><span class="c1">(jobs) associate a program with a schedule. To define what is executed and when, you</span></p><p class="c0"><span class="c1">assign relationships among programs, schedules, and jobs.</span></p><p class="c0"><span class="c1">The Scheduler is implemented as a set of functions and procedures in the</span></p><p class="c0"><span class="c1">DBMS_SCHEDULER PL/SQL package. You create and manipulate Scheduler objects with</span></p><p class="c0"><span class="c1">this package or with Enterprise Manager. Because Scheduler objects are standard</span></p><p class="c0"><span class="c1">database objects, you can control access to them with system and object privileges.</span></p><p class="c0"><span class="c1">Figure 18&ndash;7 shows the basic architecture of the Scheduler. The job table is a container</span></p><p class="c0"><span class="c1">for all the jobs, with one table per database. The job coordinator background process</span></p><p class="c0"><span class="c1">is automatically started and stopped as needed. Job slaves are awakened by the</span></p><p class="c0"><span class="c1">coordinator when a job must be run (see &quot;Job Queue Processes (CJQ0 and Jnnn)&quot; on</span></p><p class="c0"><span class="c1">page 15-12). The slaves gather metadata from the job table and run the job.</span></p><p class="c0"><span class="c1">Figure 18&ndash;7 Scheduler Components</span></p><p class="c0"><span class="c1">Performance Diagnostics and Tuning</span></p><p class="c0"><span class="c1">As a DBA, you are responsible for the performance of your Oracle database. Typically,</span></p><p class="c0"><span class="c1">performance problems result from unacceptable response time, which is the time to</span></p><p class="c0"><span class="c1">complete a specified workload, or throughput, which is the amount of work that can</span></p><p class="c0"><span class="c1">be completed in a specified time. Common problems include:</span></p><p class="c0"><span class="c1">&#9632; CPU bottlenecks</span></p><p class="c0"><span class="c1">&#9632; Undersized memory structures</span></p><p class="c0"><span class="c1">&#9632; I/O capacity issues</span></p><p class="c0"><span class="c1">&#9632; Inefficient or high-load SQL statements</span></p><p class="c0"><span class="c1">&#9632; Unexpected performance regression after tuning SQL statements</span></p><p class="c0"><span class="c1">&#9632; Concurrency and contention issues</span></p><p class="c0"><span class="c1">See Also: Oracle Database Administrator&#39;s Guide to learn about the</span></p><p class="c0"><span class="c1">Scheduler</span></p><p class="c0"><span class="c1">Client</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">Job Table</span></p><p class="c0"><span class="c1">Job1</span></p><p class="c0"><span class="c1">Job2</span></p><p class="c0"><span class="c1">Job3</span></p><p class="c0"><span class="c1">Job4</span></p><p class="c0"><span class="c1">Job5</span></p><p class="c0"><span class="c1">Job6 JS JS JS</span></p><p class="c0"><span class="c1">Job Slaves</span></p><p class="c0"><span class="c1">Job CoordinatorTopics for Database Administrators</span></p><p class="c0"><span class="c1">Concepts for Database Administrators 18-21</span></p><p class="c0"><span class="c1">&#9632; Database configuration issues</span></p><p class="c0"><span class="c1">The general goal of tuning is usually to improve response time, increase throughput,</span></p><p class="c0"><span class="c1">or both. A specific and measurable goal might be &quot;Reduce the response time of the</span></p><p class="c0"><span class="c1">specified SELECT statement to under 5 seconds.&quot; Whether this goal is achievable</span></p><p class="c0"><span class="c1">depends on factors that may or may not be under the control of the DBA. In general,</span></p><p class="c0"><span class="c1">tuning is the effort to achieve specific, measurable, and achievable tuning goals by</span></p><p class="c0"><span class="c1">using database resources in the most efficient way possible.</span></p><p class="c0"><span class="c1">The Oracle performance method is based on identifying and eliminating bottlenecks</span></p><p class="c0"><span class="c1">in the database, and developing efficient SQL statements. Applying the Oracle</span></p><p class="c0"><span class="c1">performance method involves the following tasks:</span></p><p class="c0"><span class="c1">&#9632; Performing pre-tuning preparations</span></p><p class="c0"><span class="c1">&#9632; Tuning the database proactively on a regular basis</span></p><p class="c0"><span class="c1">&#9632; Tuning the database reactively when users report performance problems</span></p><p class="c0"><span class="c1">&#9632; Identifying, tuning, and optimizing high-load SQL statements</span></p><p class="c0"><span class="c1">This section describes essential aspects of Oracle Database performance tuning,</span></p><p class="c0"><span class="c1">including the use of advisors. Oracle Database advisors provide specific advice on</span></p><p class="c0"><span class="c1">how to address key database management challenges, covering a wide range of areas</span></p><p class="c0"><span class="c1">including space, performance, and undo management.</span></p><p class="c0"><span class="c1">Database Self-Monitoring</span></p><p class="c0"><span class="c1">Self-monitoring take place as the database performs its regular operation, ensuring</span></p><p class="c0"><span class="c1">that the database is aware of problems as they arise. Oracle Database can send a</span></p><p class="c0"><span class="c1">server-generated alert to notify you of an impending problem.</span></p><p class="c0"><span class="c1">Alerts are automatically generated when a problem occurs or when data does not</span></p><p class="c0"><span class="c1">match expected values for metrics such as physical reads per second or SQL response</span></p><p class="c0"><span class="c1">time. A metric is the rate of change in a cumulative statistic. Server-generated alerts</span></p><p class="c0"><span class="c1">can be based on user-specified threshold levels or because an event has occurred.</span></p><p class="c0"><span class="c1">Server-generated alerts not only identify the problem, but sometimes recommend how</span></p><p class="c0"><span class="c1">the reported problem can be resolved. An example is an alert that the fast recovery</span></p><p class="c0"><span class="c1">area is running out of space with the recommendation that obsolete backups should be</span></p><p class="c0"><span class="c1">deleted or additional disk space added.</span></p><p class="c0"><span class="c1">Automatic Workload Repository (AWR)</span></p><p class="c0"><span class="c1">Automatic Workload Repository (AWR) is a repository of historical performance data</span></p><p class="c0"><span class="c1">that includes cumulative statistics for the system, sessions, individual SQL statements,</span></p><p class="c0"><span class="c1">segments, and services. These statistics are the foundation of performance tuning. By</span></p><p class="c0"><span class="c1">automating the gathering of database statistics for problem detection and tuning, AWR</span></p><p class="c0"><span class="c1">serves as the foundation for database self-management.</span></p><p class="c0"><span class="c1">As shown in Figure 18&ndash;8, the database stores recent AWR statistics in the SGA. By</span></p><p class="c0"><span class="c1">default, the MMON process gathers statistics every hour and creates an AWR</span></p><p class="c0"><span class="c1">snapshot (see &quot;Manageability Monitor Processes (MMON and MMNL)&quot; on</span></p><p class="c0"><span class="c1">page 15-11). A snapshot is a set of performance statistics captured at a specific time.</span></p><p class="c0"><span class="c1">The database writes snapshots to the SYSAUX tablespace. AWR manages snapshot</span></p><p class="c0"><span class="c1">space, purging older snapshots according to a configurable snapshot retention policy.</span></p><p class="c0"><span class="c1">See Also: Oracle Database 2 Day + Performance Tuning Guide and</span></p><p class="c0"><span class="c1">Oracle Database Performance Tuning Guide provide to learn how to</span></p><p class="c0"><span class="c1">implement the Oracle performance method</span></p><p class="c0"><span class="c1">See Also: Oracle Database Administrator&#39;s GuideTopics for Database Administrators</span></p><p class="c0"><span class="c1">18-22 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Figure 18&ndash;8 Automatic Workload Repository (AWR)</span></p><p class="c0"><span class="c1">An AWR baseline is a collection of statistic rates usually taken over a period when the</span></p><p class="c0"><span class="c1">system is performing well at peak load. You can specify a pair or range of AWR</span></p><p class="c0"><span class="c1">snapshots as a baseline. By using an AWR report to compare statistics captured during</span></p><p class="c0"><span class="c1">a period of bad performance to a baseline, you can diagnose problems.</span></p><p class="c0"><span class="c1">An automated maintenance infrastructure known as AutoTask illustrates how Oracle</span></p><p class="c0"><span class="c1">Database uses AWR for self-management. By analyzing AWR data, AutoTask can</span></p><p class="c0"><span class="c1">determine the need for maintenance tasks and schedule them to run in Oracle</span></p><p class="c0"><span class="c1">Scheduler maintenance windows. Examples of tasks include gathering statistics for</span></p><p class="c0"><span class="c1">the optimizer and running the Automatic Segment Advisor.</span></p><p class="c0"><span class="c1">Automatic Database Diagnostic Monitor (ADDM)</span></p><p class="c0"><span class="c1">Automatic Database Diagnostic Monitor (ADDM) is a self-diagnostic advisor built</span></p><p class="c0"><span class="c1">into Oracle Database. Using statistics captured in AWR, ADDM automatically and</span></p><p class="c0"><span class="c1">proactively diagnoses database performance and determines how identified problems</span></p><p class="c0"><span class="c1">can be resolved. You can also run ADDM manually.</span></p><p class="c0"><span class="c1">ADDM takes a holistic approach to system performance, using time as a common</span></p><p class="c0"><span class="c1">currency between components. ADDM identifies areas of Oracle Database consuming</span></p><p class="c0"><span class="c1">the most time. For example, the database may be spending an excessive amount of</span></p><p class="c0"><span class="c1">time waiting for free database buffers. ADDM drills down to identify the root cause of</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;The SYSAUX Tablespace&quot; on page 12-32</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Performance Tuning Guide to learn about AWR</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Administrator&#39;s Guide and Oracle Database 2 Day</span></p><p class="c0"><span class="c1">DBA to learn how to manage automatic maintenance tasks</span></p><p class="c0"><span class="c1">Database Instance</span></p><p class="c0"><span class="c1">System Global Area (SGA)</span></p><p class="c0"><span class="c1">Statistics MMON</span></p><p class="c0"><span class="c1">SYSAUX Tablespace</span></p><p class="c0"><span class="c1">Automatic Workload</span></p><p class="c0"><span class="c1">Repository</span></p><p class="c0"><span class="c1">Snapshots</span></p><p class="c0"><span class="c1">Memory</span></p><p class="c0"><span class="c1">DiskTopics for Database Administrators</span></p><p class="c0"><span class="c1">Concepts for Database Administrators 18-23</span></p><p class="c0"><span class="c1">problems, rather than just the symptoms, and reports the effect of the problem on</span></p><p class="c0"><span class="c1">Oracle Database overall. Minimal overhead occurs during the diagnostic process.</span></p><p class="c0"><span class="c1">In many cases, ADDM recommends solutions and quantifies expected performance</span></p><p class="c0"><span class="c1">benefits. For example, ADDM may recommend changes to hardware, database</span></p><p class="c0"><span class="c1">configuration, database schema, or applications. If a recommendation is made, then</span></p><p class="c0"><span class="c1">ADDM reports the time benefit. The use of time as a measure enables comparisons of</span></p><p class="c0"><span class="c1">problems or recommendations.</span></p><p class="c0"><span class="c1">Besides reporting potential performance issues, ADDM documents areas of the</span></p><p class="c0"><span class="c1">database that are not problems. Subcomponents such as I/O and memory that are not</span></p><p class="c0"><span class="c1">significantly impacting database performance are pruned from the classification tree at</span></p><p class="c0"><span class="c1">an early stage. ADDM lists these subcomponents so that you can quickly see that there</span></p><p class="c0"><span class="c1">is little benefit to performing actions in those areas.</span></p><p class="c0"><span class="c1">Active Session History (ASH)</span></p><p class="c0"><span class="c1">Active Session History (ASH) samples active database sessions each second, writing</span></p><p class="c0"><span class="c1">the data to memory and persistent storage. ASH is an integral part of the database</span></p><p class="c0"><span class="c1">self-management framework and is useful for diagnosing performance problems.</span></p><p class="c0"><span class="c1">Unlike instance-level statistics gathered by AWR, ASH statistics are gathered at the</span></p><p class="c0"><span class="c1">session level. An active session is a session that is using CPU and is not waiting for an</span></p><p class="c0"><span class="c1">event in the idle wait class.</span></p><p class="c0"><span class="c1">You can use Enterprise Manager or SQL scripts to generate ASH reports that gather</span></p><p class="c0"><span class="c1">session statistics gathered over a specified duration. You can use ASH reports for:</span></p><p class="c0"><span class="c1">&#9632; Analysis of short-lived performance problems not identified by ADDM</span></p><p class="c0"><span class="c1">&#9632; Scoped or targeted performance analysis by various dimensions or their</span></p><p class="c0"><span class="c1">combinations, such as time, session, module, action, or SQL ID</span></p><p class="c0"><span class="c1">For example, a user notifies you that the database was slow between 10:00 p.m. and</span></p><p class="c0"><span class="c1">10:02 p.m. However, the 2-minute performance degradation represents a small portion</span></p><p class="c0"><span class="c1">of the AWR snapshot interval from 10:00 p.m. and 11:00 p.m. and does not appear in</span></p><p class="c0"><span class="c1">ADDM findings. ASH reports can help identify the source of the transient problem.</span></p><p class="c0"><span class="c1">Application and SQL Tuning</span></p><p class="c0"><span class="c1">Oracle Database completely automates the SQL tuning process. ADDM identifies SQL</span></p><p class="c0"><span class="c1">statements consuming unusually high system resources and therefore causing</span></p><p class="c0"><span class="c1">performance problems. In addition, AWR automatically captures the top SQL</span></p><p class="c0"><span class="c1">statements in terms of CPU and shared memory consumption. The identification of</span></p><p class="c0"><span class="c1">high-load SQL statements happens automatically and requires no intervention.</span></p><p class="c0"><span class="c1">SQL Tuning Advisor Automatic SQL tuning is exposed through SQL Tuning Advisor.</span></p><p class="c0"><span class="c1">SQL Tuning Advisor runs automatically during system maintenance windows as a</span></p><p class="c0"><span class="c1">maintenance task. During each automatic run, the advisor selects high-load SQL</span></p><p class="c0"><span class="c1">queries in the database and generates recommendations for tuning these queries.</span></p><p class="c0"><span class="c1">SQL Tuning Advisor recommendations fall into the following categories:</span></p><p class="c0"><span class="c1">&#9632; Statistics analysis</span></p><p class="c0"><span class="c1">&#9632; SQL profiling</span></p><p class="c0"><span class="c1">See Also: Oracle Database 2 Day + Performance Tuning Guide and</span></p><p class="c0"><span class="c1">Oracle Database Performance Tuning Guide</span></p><p class="c0"><span class="c1">See Also: Oracle Database 2 Day + Performance Tuning Guide and</span></p><p class="c0"><span class="c1">Oracle Database Performance Tuning GuideTopics for Database Administrators</span></p><p class="c0"><span class="c1">18-24 Oracle Database Concepts</span></p><p class="c0"><span class="c1">&#9632; Access path analysis</span></p><p class="c0"><span class="c1">&#9632; SQL structure analysis</span></p><p class="c0"><span class="c1">A SQL profile contains additional statistics specific to a SQL statement and enables</span></p><p class="c0"><span class="c1">the optimizer to generate a better execution plan. Essentially, a SQL profile is a</span></p><p class="c0"><span class="c1">method for analyzing a query. Both access path and SQL structure analysis are useful</span></p><p class="c0"><span class="c1">for tuning an application under development or a homegrown production application.</span></p><p class="c0"><span class="c1">A principal benefit of SQL Tuning Advisor is that solutions come from the optimizer</span></p><p class="c0"><span class="c1">rather than external tools (see &quot;Overview of the Optimizer&quot; on page 7-10). Thus, tuning</span></p><p class="c0"><span class="c1">is performed by the database component that is responsible for the execution plans</span></p><p class="c0"><span class="c1">and SQL performance. The tuning process can consider past execution statistics of a</span></p><p class="c0"><span class="c1">SQL statement and customizes the optimizer settings for this statement.</span></p><p class="c0"><span class="c1">SQL Access Advisor SQL Access Advisor offers advice on how to optimize data access</span></p><p class="c0"><span class="c1">paths. Specifically, it recommends how database performance can be improved</span></p><p class="c0"><span class="c1">through partitioning, materialized views, indexes, and materialized view logs.</span></p><p class="c0"><span class="c1">Schema objects such as partitions and indexes are essential for optimizing complex,</span></p><p class="c0"><span class="c1">data-intensive queries. However, creation and maintenance of these objects can be</span></p><p class="c0"><span class="c1">time-consuming, and space requirements can be significant. SQL Access Advisor helps</span></p><p class="c0"><span class="c1">meet performance goals by recommending data structures for a specified workload.</span></p><p class="c0"><span class="c1">The SQL Access Advisor can be run from Enterprise Manager using the SQL Access</span></p><p class="c0"><span class="c1">Advisor Wizard or by invoking the DBMS_ADVISOR package. The DBMS_ADVISOR package</span></p><p class="c0"><span class="c1">consists of a collection of analysis and advisory functions and procedures callable from</span></p><p class="c0"><span class="c1">any PL/SQL program.</span></p><p class="c0"><span class="c1">See Also: Oracle Database 2 Day + Performance Tuning Guide and</span></p><p class="c0"><span class="c1">Oracle Database Performance Tuning Guide</span></p><p class="c0"><span class="c1">See Also: Oracle Database 2 Day + Performance Tuning Guide and</span></p><p class="c0"><span class="c1">Oracle Database Performance Tuning Guide19</span></p><p class="c0"><span class="c1">Concepts for Database Developers 19-1</span></p><p class="c0"><span class="c1">Concepts for Database Developers 9 1</span></p><p class="c0"><span class="c1">The Oracle Database developer creates and maintains a database application. This</span></p><p class="c0"><span class="c1">section presents a brief overview of what a database developer does and the</span></p><p class="c0"><span class="c1">development tools available.</span></p><p class="c0"><span class="c1">This section contains the following topics:</span></p><p class="c0"><span class="c1">&#9632; Duties of Database Developers</span></p><p class="c0"><span class="c1">&#9632; Tools for Database Developers</span></p><p class="c0"><span class="c1">&#9632; Topics for Database Developers</span></p><p class="c0"><span class="c1">Duties of Database Developers</span></p><p class="c0"><span class="c1">An Oracle developer is responsible for creating or maintaining the database</span></p><p class="c0"><span class="c1">components of an application that uses the Oracle technology stack. Oracle developers</span></p><p class="c0"><span class="c1">either develop new applications or convert existing applications to run in an Oracle</span></p><p class="c0"><span class="c1">Database environment. For this reason, developers work closely with the database</span></p><p class="c0"><span class="c1">administrators, sharing knowledge and information.</span></p><p class="c0"><span class="c1">Oracle database developers can expect to be involved in the following tasks:</span></p><p class="c0"><span class="c1">&#9632; Implementing the data model required by the application</span></p><p class="c0"><span class="c1">&#9632; Creating schema objects and implementing rules for data integrity</span></p><p class="c0"><span class="c1">&#9632; Choosing a programming environment for a new development project</span></p><p class="c0"><span class="c1">&#9632; Writing server-side PL/SQL or Java subprograms and client-side procedural code</span></p><p class="c0"><span class="c1">that use SQL statements</span></p><p class="c0"><span class="c1">&#9632; Creating the application interface with the chosen development tool</span></p><p class="c0"><span class="c1">&#9632; Establishing a Globalization Support environment for developing globalized</span></p><p class="c0"><span class="c1">applications</span></p><p class="c0"><span class="c1">&#9632; Instantiating applications in different databases for development, testing,</span></p><p class="c0"><span class="c1">education, and deployment in a production environment</span></p><p class="c0"><span class="c1">The preceding tasks, and many others, are described in Oracle Database 2 Day</span></p><p class="c0"><span class="c1">Developer&#39;s Guide and Oracle Database Advanced Application Developer&#39;s Guide.</span></p><p class="c0"><span class="c1">Tools for Database Developers</span></p><p class="c0"><span class="c1">Oracle provides several tools for use in developing database applications. This section</span></p><p class="c0"><span class="c1">describes some commonly used development tools.</span></p><p class="c0"><span class="c1">See Also: &quot;Introduction to Server-Side Programming&quot; on page 8-1Tools for Database Developers</span></p><p class="c0"><span class="c1">19-2 Oracle Database Concepts</span></p><p class="c0"><span class="c1">SQL Developer</span></p><p class="c0"><span class="c1">SQL Developer is a graphical version of SQL*Plus, written in Java, that supports</span></p><p class="c0"><span class="c1">development in SQL and PL/SQL. You can connect to any Oracle database schema</span></p><p class="c0"><span class="c1">using standard database authentication. SQL Developer enables you to:</span></p><p class="c0"><span class="c1">&#9632; Browse, create, edit, and delete schema objects</span></p><p class="c0"><span class="c1">&#9632; Execute SQL statements</span></p><p class="c0"><span class="c1">&#9632; Edit and debug PL/SQL program units</span></p><p class="c0"><span class="c1">&#9632; Manipulate and export data</span></p><p class="c0"><span class="c1">&#9632; Create and display reports</span></p><p class="c0"><span class="c1">SQL Developer is available in the default Oracle Database installation and by free</span></p><p class="c0"><span class="c1">download.</span></p><p class="c0"><span class="c1">Oracle Application Express</span></p><p class="c0"><span class="c1">Oracle Application Express (APEX) is a Web application development tool for Oracle</span></p><p class="c0"><span class="c1">Database. The tool uses built-in features such as user interface themes, navigational</span></p><p class="c0"><span class="c1">controls, form handlers, and flexible reports to accelerate application development.</span></p><p class="c0"><span class="c1">Oracle Application Express installs with the database and consists of data in tables and</span></p><p class="c0"><span class="c1">PL/SQL code. When you run an application, your browser sends a URL request that is</span></p><p class="c0"><span class="c1">translated into an Oracle Application Express PL/SQL call. After the database</span></p><p class="c0"><span class="c1">processes the PL/SQL, the results are relayed back to the browser as HTML. This cycle</span></p><p class="c0"><span class="c1">happens each time you request or submit a page.</span></p><p class="c0"><span class="c1">You can use Oracle Application Express with the embedded PL/SQL gateway. The</span></p><p class="c0"><span class="c1">gateway runs in the XML DB HTTP server in the database and provides the necessary</span></p><p class="c0"><span class="c1">infrastructure to create dynamic applications. As shown in Figure 19&ndash;1, the embedded</span></p><p class="c0"><span class="c1">PL/SQL gateway simplifies the application architecture by eliminating the middle tier.</span></p><p class="c0"><span class="c1">Figure 19&ndash;1 Application Express with Embedded PL/SQL Gateway</span></p><p class="c0"><span class="c1">Oracle JDeveloper</span></p><p class="c0"><span class="c1">Oracle JDeveloper is an integrated development environment (IDE) for building</span></p><p class="c0"><span class="c1">service-oriented applications using the latest industry standards for Java, XML, Web</span></p><p class="c0"><span class="c1">services, and SQL. Oracle JDeveloper supports the complete software development life</span></p><p class="c0"><span class="c1">cycle, with integrated features for modeling, coding, debugging, testing, profiling,</span></p><p class="c0"><span class="c1">tuning, and deploying applications.</span></p><p class="c0"><span class="c1">See Also: Oracle Database 2 Day Developer&#39;s Guide and Oracle SQL</span></p><p class="c0"><span class="c1">Developer User&#39;s Guide to learn how to use SQL Developer</span></p><p class="c0"><span class="c1">See Also: Oracle Database 2 Day + Application Express Developer&#39;s</span></p><p class="c0"><span class="c1">Guide to learn how to use APEX</span></p><p class="c0"><span class="c1">Application</span></p><p class="c0"><span class="c1">Express</span></p><p class="c0"><span class="c1">Engine</span></p><p class="c0"><span class="c1">Oracle Database with</span></p><p class="c0"><span class="c1">Embedded PL/SQL Gateway</span></p><p class="c0"><span class="c1">Web</span></p><p class="c0"><span class="c1">BrowserTopics for Database Developers</span></p><p class="c0"><span class="c1">Concepts for Database Developers 19-3</span></p><p class="c0"><span class="c1">JDeveloper uses windows for various application development tools. For example,</span></p><p class="c0"><span class="c1">when creating a Java application, you can use tools such as the Java Visual Editor and</span></p><p class="c0"><span class="c1">Component Palette. In addition to these tools, JDeveloper provides a range of</span></p><p class="c0"><span class="c1">navigators to help you organize and view the contents of your projects.</span></p><p class="c0"><span class="c1">Oracle JPublisher</span></p><p class="c0"><span class="c1">Java Publisher (JPublisher) is a simple and convenient tool to create Java programs</span></p><p class="c0"><span class="c1">that access database tables. Java code stubs generated by JDeveloper present</span></p><p class="c0"><span class="c1">object-relational structures in the database as Java classes. These classes can represent</span></p><p class="c0"><span class="c1">the following user-defined database entities in a Java program:</span></p><p class="c0"><span class="c1">&#9632; SQL object types</span></p><p class="c0"><span class="c1">&#9632; Object reference types</span></p><p class="c0"><span class="c1">&#9632; SQL collection types</span></p><p class="c0"><span class="c1">&#9632; PL/SQL packages</span></p><p class="c0"><span class="c1">You can specify and customize the mapping of these entities to Java classes in a</span></p><p class="c0"><span class="c1">strongly typed paradigm, so that a specific Java type is associated with a specific</span></p><p class="c0"><span class="c1">user-defined SQL type. JPublisher can also generate classes for PL/SQL packages.</span></p><p class="c0"><span class="c1">These classes have wrapper methods to call the stored procedure in the package.</span></p><p class="c0"><span class="c1">Oracle Developer Tools for Visual Studio .NET</span></p><p class="c0"><span class="c1">Oracle Developer Tools for Visual Studio .NET is a set of application tools integrated</span></p><p class="c0"><span class="c1">with the Visual Studio .NET environment. These tools provide GUI access to Oracle</span></p><p class="c0"><span class="c1">functionality, enable the user to perform a wide range of application development</span></p><p class="c0"><span class="c1">tasks, and improve development productivity and ease of use.</span></p><p class="c0"><span class="c1">Oracle Developer Tools support the programming and implementation of .NET stored</span></p><p class="c0"><span class="c1">procedures using Visual Basic, C#, and other .NET languages. These procedures are</span></p><p class="c0"><span class="c1">written in a .NET language and contain SQL or PL/SQL statements.</span></p><p class="c0"><span class="c1">Topics for Database Developers</span></p><p class="c0"><span class="c1">Chapter 17 describes topics important for both developers and administrators. This</span></p><p class="c0"><span class="c1">section covers topics that are most essential to database developers and that have not</span></p><p class="c0"><span class="c1">been discussed elsewhere in the manual.</span></p><p class="c0"><span class="c1">This section contains the following topics:</span></p><p class="c0"><span class="c1">&#9632; Principles of Application Design and Tuning</span></p><p class="c0"><span class="c1">&#9632; Client-Side Database Programming</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database 2 Day + Java Developer&#39;s Guide to learn how to use</span></p><p class="c0"><span class="c1">JDeveloper</span></p><p class="c0"><span class="c1">&#9632; You can download JDeveloper from the following URL:</span></p><p class="c0"><span class="c1">http://www.oracle.com/technetwork/developer-tools/jdev/do</span></p><p class="c0"><span class="c1">wnloads/</span></p><p class="c0"><span class="c1">See Also: Oracle Database JPublisher User&#39;s Guide</span></p><p class="c0"><span class="c1">See Also: Oracle Database 2 Day + .NET Developer&#39;s Guide for Microsoft</span></p><p class="c0"><span class="c1">WindowsTopics for Database Developers</span></p><p class="c0"><span class="c1">19-4 Oracle Database Concepts</span></p><p class="c0"><span class="c1">&#9632; Globalization Support</span></p><p class="c0"><span class="c1">&#9632; Unstructured Data</span></p><p class="c0"><span class="c1">Principles of Application Design and Tuning</span></p><p class="c0"><span class="c1">Oracle developers must design, create, and tune database applications so that they</span></p><p class="c0"><span class="c1">achieve security and performance goals. The following principles of application design</span></p><p class="c0"><span class="c1">and tuning are useful guidelines:</span></p><p class="c0"><span class="c1">&#9632; Understand how Oracle Database works</span></p><p class="c0"><span class="c1">As a developer, you want to develop applications in the least amount of time</span></p><p class="c0"><span class="c1">against an Oracle database, which requires exploiting the database architecture</span></p><p class="c0"><span class="c1">and features. For example, not understanding Oracle Database concurrency</span></p><p class="c0"><span class="c1">controls and multiversioning read consistency may make an application corrupt</span></p><p class="c0"><span class="c1">the integrity of the data, run slowly, and decrease scalability (see &quot;Introduction to</span></p><p class="c0"><span class="c1">Data Concurrency and Consistency&quot; on page 9-1).</span></p><p class="c0"><span class="c1">&#9632; Use bind variables</span></p><p class="c0"><span class="c1">When a query uses bind variables, the database can compile it once and store the</span></p><p class="c0"><span class="c1">query plan in the shared pool. If the same statement is executed again, then the</span></p><p class="c0"><span class="c1">database can perform a soft parse and reuse the plan. In contrast, a hard parse</span></p><p class="c0"><span class="c1">takes longer and uses more resources (see &quot;SQL Parsing&quot; on page 7-16). Using bind</span></p><p class="c0"><span class="c1">variables to allow soft parsing is very efficient and is the way the database intends</span></p><p class="c0"><span class="c1">developers to work.</span></p><p class="c0"><span class="c1">&#9632; Implement integrity constraints in the server rather than in the client</span></p><p class="c0"><span class="c1">Using primary and foreign keys enables data to be reused in multiple applications.</span></p><p class="c0"><span class="c1">Coding the rules in a client means that other clients do not have access to these</span></p><p class="c0"><span class="c1">rules when running against the databases (see &quot;Advantages of Integrity</span></p><p class="c0"><span class="c1">Constraints&quot; on page 5-1).</span></p><p class="c0"><span class="c1">&#9632; Build a test environment with representative data and session activity</span></p><p class="c0"><span class="c1">A test environment that simulates your live production environment provides</span></p><p class="c0"><span class="c1">multiple benefits. For example, you can benchmark the application to ensure that</span></p><p class="c0"><span class="c1">it scales and performs well. Also, you can use a test environment to measure the</span></p><p class="c0"><span class="c1">performance impact of changes to the database, and ensure that upgrades and</span></p><p class="c0"><span class="c1">patches work correctly.</span></p><p class="c0"><span class="c1">&#9632; Design the data model with the goal of good performance</span></p><p class="c0"><span class="c1">Typically, attempts to use generic data models result in poor performance. A</span></p><p class="c0"><span class="c1">well-designed data model answer the most common queries as efficiently as</span></p><p class="c0"><span class="c1">possible. For example, the data model should use the type of indexes that provide</span></p><p class="c0"><span class="c1">the best performance. Tuning after deployment is undesirable because changes to</span></p><p class="c0"><span class="c1">logic and physical structures may be difficult or impossible.</span></p><p class="c0"><span class="c1">&#9632; Define clear performance goals and keep historical records of metrics</span></p><p class="c0"><span class="c1">An important facet of development is determining exactly how the application is</span></p><p class="c0"><span class="c1">expected to perform and scale. For example, you should use metrics that include</span></p><p class="c0"><span class="c1">expected user load, transactions per second, acceptable response times, and so on.</span></p><p class="c0"><span class="c1">Good practice dictates that you maintain historical records of performance metrics.</span></p><p class="c0"><span class="c1">In this way, you can monitor performance proactively and reactively (see</span></p><p class="c0"><span class="c1">&quot;Performance Diagnostics and Tuning&quot; on page 18-20).</span></p><p class="c0"><span class="c1">&#9632; Instrument the application codeTopics for Database Developers</span></p><p class="c0"><span class="c1">Concepts for Database Developers 19-5</span></p><p class="c0"><span class="c1">Good development practice involves adding debugging code to your application.</span></p><p class="c0"><span class="c1">The ability to generate trace files is useful for debugging and diagnosing</span></p><p class="c0"><span class="c1">performance problems.</span></p><p class="c0"><span class="c1">Client-Side Database Programming</span></p><p class="c0"><span class="c1">As explained in Chapter 8, &quot;Server-Side Programming: PL/SQL and Java&quot;, two basic</span></p><p class="c0"><span class="c1">techniques enable procedural database applications to use SQL: server-side</span></p><p class="c0"><span class="c1">programming with PL/SQL and Java, and client-side programming with precompilers</span></p><p class="c0"><span class="c1">and APIs. This section provides a brief overview of client-side database programming.</span></p><p class="c0"><span class="c1">Embedded SQL</span></p><p class="c0"><span class="c1">Historically, client/server programs have used embedded SQL to interact with the</span></p><p class="c0"><span class="c1">database. This section explains options for using embedded SQL.</span></p><p class="c0"><span class="c1">Oracle Precompilers Client/server programs are typically written using precompilers,</span></p><p class="c0"><span class="c1">which are programming tools that enable you to embed SQL statements in high-level</span></p><p class="c0"><span class="c1">programs. For example, the Oracle Pro*C/C++ precompiler enables you to embed SQL</span></p><p class="c0"><span class="c1">statements in a C or C++ source file. Oracle precompilers are also available for COBOL</span></p><p class="c0"><span class="c1">and FORTRAN.</span></p><p class="c0"><span class="c1">A precompiler provides several benefits, including the following:</span></p><p class="c0"><span class="c1">&#9632; Increases productivity because you typically write less code than equivalent OCI</span></p><p class="c0"><span class="c1">applications</span></p><p class="c0"><span class="c1">&#9632; Enables you to create highly customized applications</span></p><p class="c0"><span class="c1">&#9632; Allows close monitoring of resource use, SQL statement execution, and various</span></p><p class="c0"><span class="c1">run-time indicators</span></p><p class="c0"><span class="c1">&#9632; Saves time because the precompiler, not you, translates each embedded SQL</span></p><p class="c0"><span class="c1">statement into calls to the Oracle Database run-time library</span></p><p class="c0"><span class="c1">&#9632; Uses the Object Type Translator to map Oracle Database object types and</span></p><p class="c0"><span class="c1">collections into C data types to be used in the Pro*C/C++ application</span></p><p class="c0"><span class="c1">&#9632; Provides compile time type checking of object types and collections and automatic</span></p><p class="c0"><span class="c1">type conversion from database types to C data types</span></p><p class="c0"><span class="c1">The client application containing the SQL statements is the host program. This</span></p><p class="c0"><span class="c1">program is written in the host language. In the host program, you can mix complete</span></p><p class="c0"><span class="c1">SQL statements with complete C statements and use C variables or structures in SQL</span></p><p class="c0"><span class="c1">statements. When embedding SQL statements you must begin them with the</span></p><p class="c0"><span class="c1">keywords EXEC SQL and end them with a semicolon. Pro*C/C++ translates EXEC SQL</span></p><p class="c0"><span class="c1">statements into calls to the run-time library SQLLIB.</span></p><p class="c0"><span class="c1">Many embedded SQL statements differ from their interactive counterparts only</span></p><p class="c0"><span class="c1">through the addition of a new clause or the use of program variables. The following</span></p><p class="c0"><span class="c1">example compares interactive and embedded ROLLBACK statements:</span></p><p class="c0"><span class="c1">ROLLBACK; -- interactive</span></p><p class="c0"><span class="c1">EXEC SQL ROLLBACK; -- embedded</span></p><p class="c0"><span class="c1">See Also: Oracle Database 2 Day Developer&#39;s Guide for considerations</span></p><p class="c0"><span class="c1">when designing and deploying database applications</span></p><p class="c0"><span class="c1">See Also: Oracle Database Advanced Application Developer&#39;s Guide to</span></p><p class="c0"><span class="c1">learn how to choose a programming environmentTopics for Database Developers</span></p><p class="c0"><span class="c1">19-6 Oracle Database Concepts</span></p><p class="c0"><span class="c1">The statements have the same effect, but you would use the first in an interactive SQL</span></p><p class="c0"><span class="c1">environment (such as SQL Developer), and the second in a Pro*C/C++ program.</span></p><p class="c0"><span class="c1">A precompiler accepts the host program as input, translates the embedded SQL</span></p><p class="c0"><span class="c1">statements into standard database run-time library calls, and generates a source</span></p><p class="c0"><span class="c1">program that you can compile, link, and run in the usual way. Figure 19&ndash;2 illustrates</span></p><p class="c0"><span class="c1">typical steps of developing programs that use precompilers.</span></p><p class="c0"><span class="c1">Figure 19&ndash;2 Program Development with Precompilers</span></p><p class="c0"><span class="c1">SQLJ SQLJ is an ANSI SQL-1999 standard for embedding SQL statements in Java</span></p><p class="c0"><span class="c1">source code. SQLJ provides a simpler alternative to the Java Database Connectivity</span></p><p class="c0"><span class="c1">(JDBC) API for client-side SQL data access from Java.</span></p><p class="c0"><span class="c1">The SQLJ interface is the Java equivalent of the Pro* interfaces. You insert SQL</span></p><p class="c0"><span class="c1">statements in your Java source code. Afterward, you submit the Java source files to the</span></p><p class="c0"><span class="c1">SQLJ translator, which translates the embedded SQL to pure JDBC-based Java code.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Pro*C/C++ Programmer&#39;s Guide for a complete description of the</span></p><p class="c0"><span class="c1">Pro*C/C++ precompiler</span></p><p class="c0"><span class="c1">&#9632; Pro*FORTRAN Supplement to the Oracle Precompilers Guide</span></p><p class="c0"><span class="c1">See Also: &quot;SQLJ&quot; on page 8-16</span></p><p class="c0"><span class="c1">Editor</span></p><p class="c0"><span class="c1">Host</span></p><p class="c0"><span class="c1">Program</span></p><p class="c0"><span class="c1">Oracle</span></p><p class="c0"><span class="c1">Precompiler</span></p><p class="c0"><span class="c1">Compiler</span></p><p class="c0"><span class="c1">Object</span></p><p class="c0"><span class="c1">Program</span></p><p class="c0"><span class="c1">Executable</span></p><p class="c0"><span class="c1">Program</span></p><p class="c0"><span class="c1">Linker</span></p><p class="c0"><span class="c1">Source</span></p><p class="c0"><span class="c1">Program</span></p><p class="c0"><span class="c1">With embedded SQL</span></p><p class="c0"><span class="c1">statements</span></p><p class="c0"><span class="c1">With all SQL statements</span></p><p class="c0"><span class="c1">replaced by library calls</span></p><p class="c0"><span class="c1">Oracle</span></p><p class="c0"><span class="c1">Runtime</span></p><p class="c0"><span class="c1">Library</span></p><p class="c0"><span class="c1">(SQLLIB)</span></p><p class="c0"><span class="c1">To resolve callsTopics for Database Developers</span></p><p class="c0"><span class="c1">Concepts for Database Developers 19-7</span></p><p class="c0"><span class="c1">Client-Side APIs</span></p><p class="c0"><span class="c1">Most developers today use an API to embed SQL in their database applications. For</span></p><p class="c0"><span class="c1">example, two popular APIs for enabling programs to communicate with Oracle</span></p><p class="c0"><span class="c1">Database are Open Database Connectivity (ODBC) and JDBC. The Oracle Call</span></p><p class="c0"><span class="c1">Interface (OCI) and Oracle C++ Call Interface (OCCI) are two other common APIs for</span></p><p class="c0"><span class="c1">client-side programming.</span></p><p class="c0"><span class="c1">OCI and OCCI As an alternative to precompilers, Oracle provides the OCI and OCCI</span></p><p class="c0"><span class="c1">APIs. OCI lets you manipulate data and schemas in a database using a host</span></p><p class="c0"><span class="c1">programming language such as C. OCCI is an object-oriented interface suitable for use</span></p><p class="c0"><span class="c1">with C++. Both APIs enable developers to use native subprogram invocations to access</span></p><p class="c0"><span class="c1">Oracle Database and control SQL execution.</span></p><p class="c0"><span class="c1">In some cases, OCI provides better performance or more features than higher-level</span></p><p class="c0"><span class="c1">interfaces. OCI and OCCI provide many features, including the following:</span></p><p class="c0"><span class="c1">&#9632; Support for all SQL DDL, DML, query, and transaction control facilities available</span></p><p class="c0"><span class="c1">through Oracle Database</span></p><p class="c0"><span class="c1">&#9632; Instant client, a way to deploy applications when disk space is an issue</span></p><p class="c0"><span class="c1">&#9632; Thread management, connection pooling, globalization functions, and direct path</span></p><p class="c0"><span class="c1">loading of data from a C application</span></p><p class="c0"><span class="c1">OCI and OCCI provide a library of standard database access and retrieval functions in</span></p><p class="c0"><span class="c1">the form of a dynamic run-time library (OCILIB). This library can be linked in an</span></p><p class="c0"><span class="c1">application at run time. Thus, you can compile and link an OCI or OCCI program in</span></p><p class="c0"><span class="c1">the same way as a nondatabase application, avoiding a separate preprocessing or</span></p><p class="c0"><span class="c1">precompilation step. Figure 19&ndash;3 illustrates the development process.</span></p><p class="c0"><span class="c1">Figure 19&ndash;3 Development Process Using OCI or OCCI</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Call Interface Programmer&#39;s Guide</span></p><p class="c0"><span class="c1">&#9632; Oracle C++ Call Interface Programmer&#39;s Guide</span></p><p class="c0"><span class="c1">Host Language Compiler</span></p><p class="c0"><span class="c1">Source Files</span></p><p class="c0"><span class="c1">Host Linker</span></p><p class="c0"><span class="c1">Application</span></p><p class="c0"><span class="c1">Object Files OCI Library</span></p><p class="c0"><span class="c1">Object</span></p><p class="c0"><span class="c1">Server</span></p><p class="c0"><span class="c1">10101</span></p><p class="c0"><span class="c1">10101</span></p><p class="c0"><span class="c1">10101 10101Topics for Database Developers</span></p><p class="c0"><span class="c1">19-8 Oracle Database Concepts</span></p><p class="c0"><span class="c1">ODBC and JDBC ODBC is a standard API that enables applications to connect to a</span></p><p class="c0"><span class="c1">database and then prepare and run SQL statements. ODBC is independent of</span></p><p class="c0"><span class="c1">programming language, database, and operating system. The goal of ODBC is to</span></p><p class="c0"><span class="c1">enable any application to access data contained in any database.</span></p><p class="c0"><span class="c1">A database driver is software that sits between an application and the database. The</span></p><p class="c0"><span class="c1">driver translates the API calls made by the application into commands that the</span></p><p class="c0"><span class="c1">database can process. By using an ODBC driver, an application can access any data</span></p><p class="c0"><span class="c1">source, including data stored in spreadsheets. The ODBC driver performs all</span></p><p class="c0"><span class="c1">mappings between the ODBC standard and the database.</span></p><p class="c0"><span class="c1">The Oracle ODBC driver provided by Oracle enables ODBC-compliant applications to</span></p><p class="c0"><span class="c1">access Oracle Database. For example, an application written in Visual Basic can use</span></p><p class="c0"><span class="c1">ODBC to query and update tables in an Oracle database.</span></p><p class="c0"><span class="c1">JDBC is a low-level Java interface that enables Java applications to interact with Oracle</span></p><p class="c0"><span class="c1">database. Like ODBC, JDBC is a vendor-independent API. The JDBC standard is</span></p><p class="c0"><span class="c1">defined by Sun Microsystems and implemented through the java.sql interfaces.</span></p><p class="c0"><span class="c1">The JDBC standard enables individual providers to implement and extend the</span></p><p class="c0"><span class="c1">standard with their own JDBC drivers. Oracle provides the following JDBC drivers for</span></p><p class="c0"><span class="c1">client-side programming:</span></p><p class="c0"><span class="c1">&#9632; JDBC thin driver</span></p><p class="c0"><span class="c1">This pure Java driver resides on the client side without an Oracle client</span></p><p class="c0"><span class="c1">installation. It is platform-independent and usable with both applets and</span></p><p class="c0"><span class="c1">applications.</span></p><p class="c0"><span class="c1">&#9632; JDBC OCI driver</span></p><p class="c0"><span class="c1">This driver resides on the client-side with an Oracle client installation. It is usable</span></p><p class="c0"><span class="c1">only with applications. The JDBC OCI driver, which is written in both C and Java,</span></p><p class="c0"><span class="c1">converts JDBC calls to OCI calls.</span></p><p class="c0"><span class="c1">The following snippets are from a Java program that uses the JDBC OCI driver to</span></p><p class="c0"><span class="c1">create a Statement object and query the dual table:</span></p><p class="c0"><span class="c1">// Create a statement</span></p><p class="c0"><span class="c1">Statement stmt = conn.createStatement();</span></p><p class="c0"><span class="c1">// Query dual table</span></p><p class="c0"><span class="c1">ResultSet rset = stmt.executeQuery(&quot;SELECT &#39;Hello World&#39; FROM DUAL&quot;);</span></p><p class="c0"><span class="c1">Globalization Support</span></p><p class="c0"><span class="c1">Oracle Database globalization support enables you to store, process, and retrieve data</span></p><p class="c0"><span class="c1">in native languages. Thus, you can develop multilingual applications and software</span></p><p class="c0"><span class="c1">that can be accessed and run from anywhere in the world simultaneously.</span></p><p class="c0"><span class="c1">Developers who write globalized database application must do the following:</span></p><p class="c0"><span class="c1">&#9632; Understand the Oracle Database globalization support architecture, including the</span></p><p class="c0"><span class="c1">properties of the different character sets, territories, languages, and linguistic sort</span></p><p class="c0"><span class="c1">definitions</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Advanced Application Developer&#39;s Guide and</span></p><p class="c0"><span class="c1">Oracle Database 2 Day + Java Developer&#39;s Guide to learn more</span></p><p class="c0"><span class="c1">about JDBC</span></p><p class="c0"><span class="c1">&#9632; Oracle Database Gateway for ODBC User&#39;s GuideTopics for Database Developers</span></p><p class="c0"><span class="c1">Concepts for Database Developers 19-9</span></p><p class="c0"><span class="c1">&#9632; Understand the globalization functionality of their middle-tier programming</span></p><p class="c0"><span class="c1">environment, including how it can interact and synchronize with the locale model</span></p><p class="c0"><span class="c1">of the database</span></p><p class="c0"><span class="c1">&#9632; Design and write code capable of simultaneously supporting multiple clients</span></p><p class="c0"><span class="c1">running on different operating systems, with different character sets and locale</span></p><p class="c0"><span class="c1">requirements</span></p><p class="c0"><span class="c1">For example, an application may be required to render content of the user interface</span></p><p class="c0"><span class="c1">and process data in languages and locale preferences of native users. For example, the</span></p><p class="c0"><span class="c1">application must process multibyte Kanji data, display messages and dates in the</span></p><p class="c0"><span class="c1">proper regional format, and process 7-bit ASCII data without requiring users to</span></p><p class="c0"><span class="c1">change settings.</span></p><p class="c0"><span class="c1">Globalization Support Environment</span></p><p class="c0"><span class="c1">The globalization support environment includes the client application and the</span></p><p class="c0"><span class="c1">database. You can control language-dependent operations by setting parameters and</span></p><p class="c0"><span class="c1">environment variables on the client and server, which may exist in separate locations.</span></p><p class="c0"><span class="c1">Oracle Database provides globalization support for features such as:</span></p><p class="c0"><span class="c1">&#9632; Native languages and territories</span></p><p class="c0"><span class="c1">&#9632; Local formats for date, time, numbers, and currency</span></p><p class="c0"><span class="c1">&#9632; Calendar systems (Gregorian, Japanese, Imperial, Thai Buddha, and so on)</span></p><p class="c0"><span class="c1">&#9632; Multiple character sets, including Unicode</span></p><p class="c0"><span class="c1">&#9632; Character semantics</span></p><p class="c0"><span class="c1">Character Sets A key component of globalization support is a character set, which is an</span></p><p class="c0"><span class="c1">encoding scheme used to display characters on your computer screen. The following</span></p><p class="c0"><span class="c1">distinction is important in application development:</span></p><p class="c0"><span class="c1">&#9632; A database character set determines which languages can be represented in a</span></p><p class="c0"><span class="c1">database. The character set is specified at database creation.</span></p><p class="c0"><span class="c1">&#9632; A client character set is the character set for data entered or displayed by a client</span></p><p class="c0"><span class="c1">application. The character set for the client and database can be different.</span></p><p class="c0"><span class="c1">A group of characters (for example, alphabetic characters, ideographs, symbols,</span></p><p class="c0"><span class="c1">punctuation marks, and control characters) can be encoded as a character set. An</span></p><p class="c0"><span class="c1">encoded character set assigns a unique numeric code, called a code point or encoded</span></p><p class="c0"><span class="c1">See Also: Oracle Database Globalization Support Guide for more</span></p><p class="c0"><span class="c1">information about globalization</span></p><p class="c0"><span class="c1">Note: In previous releases, Oracle referred to globalization support</span></p><p class="c0"><span class="c1">capabilities as National Language Support (NLS) features. NLS is</span></p><p class="c0"><span class="c1">actually a subset of globalization support and provides the ability to</span></p><p class="c0"><span class="c1">choose a national language and store data in a specific character set.</span></p><p class="c0"><span class="c1">Note: After a database is created, changing its character set is</span></p><p class="c0"><span class="c1">usually very expensive in terms of time and resources. This operation</span></p><p class="c0"><span class="c1">may require converting all character data by exporting the whole</span></p><p class="c0"><span class="c1">database and importing it back.Topics for Database Developers</span></p><p class="c0"><span class="c1">19-10 Oracle Database Concepts</span></p><p class="c0"><span class="c1">value, to each character in the set. Code points are important in a global environment</span></p><p class="c0"><span class="c1">because of the potential need to convert data between different character sets.</span></p><p class="c0"><span class="c1">The computer industry uses many encoded character sets. These sets differ in the</span></p><p class="c0"><span class="c1">number of characters available, the characters available for use, code points assigned</span></p><p class="c0"><span class="c1">to each character, and so on. Oracle Database supports most national, international,</span></p><p class="c0"><span class="c1">and vendor-specific encoded character set standards.</span></p><p class="c0"><span class="c1">Oracle Database supports the following classes of encoded character sets:</span></p><p class="c0"><span class="c1">&#9632; Single-Byte character sets</span></p><p class="c0"><span class="c1">Each character occupies one byte. An example of a 7-bit character set is US7ASCII.</span></p><p class="c0"><span class="c1">An example of an 8-bit character set is WE8DEC.</span></p><p class="c0"><span class="c1">&#9632; Multibyte character sets</span></p><p class="c0"><span class="c1">Each character occupies multiple bytes. Multibyte sets are commonly used for</span></p><p class="c0"><span class="c1">Asian languages.</span></p><p class="c0"><span class="c1">&#9632; Unicode</span></p><p class="c0"><span class="c1">The universal encoded character set enables you to store information in any</span></p><p class="c0"><span class="c1">language by using a single character set. Unicode provides a unique code value for</span></p><p class="c0"><span class="c1">every character, regardless of the platform, program, or language.</span></p><p class="c0"><span class="c1">Locale-Specific Settings A locale is a linguistic and cultural environment in which a</span></p><p class="c0"><span class="c1">system or program is running. NLS parameters determine locale-specific behavior on</span></p><p class="c0"><span class="c1">both the client and database. A database session uses NLS settings when executing</span></p><p class="c0"><span class="c1">statements on behalf of a client. For example, the database makes the correct territory</span></p><p class="c0"><span class="c1">usage of the thousands separator for a client.</span></p><p class="c0"><span class="c1">Typically, the NLS_LANG environment variable on the client host specifies the locale for</span></p><p class="c0"><span class="c1">both the server session and client application. The process is as follows:</span></p><p class="c0"><span class="c1">1. When a client application starts, it initializes the client NLS environment from the</span></p><p class="c0"><span class="c1">environment settings.</span></p><p class="c0"><span class="c1">All NLS operations performed locally, such as displaying formatting in Oracle</span></p><p class="c0"><span class="c1">Developer applications, use these settings.</span></p><p class="c0"><span class="c1">2. The client communicates the information defined by NLS_LANG to the database</span></p><p class="c0"><span class="c1">when it connects.</span></p><p class="c0"><span class="c1">3. The database session initializes its NLS environment based on the settings</span></p><p class="c0"><span class="c1">communicated by the client.</span></p><p class="c0"><span class="c1">If the client did not specify settings, then the session uses the settings in the</span></p><p class="c0"><span class="c1">initialization parameter file. The database uses the initialization parameter settings</span></p><p class="c0"><span class="c1">only if the client did not specify any NLS settings. If the client specified some NLS</span></p><p class="c0"><span class="c1">settings, then the remaining NLS settings default.</span></p><p class="c0"><span class="c1">Each session started on behalf of a client application may run in the same or a different</span></p><p class="c0"><span class="c1">locale as other sessions. For example, one session may use the German locale while</span></p><p class="c0"><span class="c1">another uses the French locale. Also, each session may have the same or different</span></p><p class="c0"><span class="c1">language requirements specified.</span></p><p class="c0"><span class="c1">Table 19&ndash;1 shows two clients using different NLS_LANG settings. A user starts SQL*Plus</span></p><p class="c0"><span class="c1">on each host, logs on to the same database as hr, and runs the same query</span></p><p class="c0"><span class="c1">See Also: Oracle Database Globalization Support Guide to learn about</span></p><p class="c0"><span class="c1">character set migrationTopics for Database Developers</span></p><p class="c0"><span class="c1">Concepts for Database Developers 19-11</span></p><p class="c0"><span class="c1">simultaneously. The result for each session differs because of the locale-specific NLS</span></p><p class="c0"><span class="c1">setting for floating-point numbers.</span></p><p class="c0"><span class="c1">Oracle Globalization Development Kit</span></p><p class="c0"><span class="c1">The Oracle Globalization Development Kit (GDK) simplifies the development</span></p><p class="c0"><span class="c1">process and reduces the cost of developing Internet applications used to support a</span></p><p class="c0"><span class="c1">global environment. The GDK includes comprehensive programming APIs for both</span></p><p class="c0"><span class="c1">Java and PL/SQL, code samples, and documentation that address many of the design,</span></p><p class="c0"><span class="c1">development, and deployment issues encountered while creating global applications.</span></p><p class="c0"><span class="c1">The GDK mainly consists of two parts: GDK for Java and GDK for PL/SQL. GDK for</span></p><p class="c0"><span class="c1">Java provides globalization support to Java applications. GDK for PL/SQL provides</span></p><p class="c0"><span class="c1">globalization support to the PL/SQL programming environment. The features offered</span></p><p class="c0"><span class="c1">in the two parts are not identical.</span></p><p class="c0"><span class="c1">Unstructured Data</span></p><p class="c0"><span class="c1">The traditional relational model deals with simple structured data that fits into simple</span></p><p class="c0"><span class="c1">tables. Oracle Database also provides support for unstructured data, which cannot be</span></p><p class="c0"><span class="c1">decomposed into standard components. Unstructured data includes text, graphic</span></p><p class="c0"><span class="c1">images, video clips, and sound waveforms.</span></p><p class="c0"><span class="c1">Oracle Database includes data types to handle unstructured content. These data types</span></p><p class="c0"><span class="c1">appear as native types in the database and can be queried using SQL.</span></p><p class="c0"><span class="c1">Overview of XML in Oracle Database</span></p><p class="c0"><span class="c1">Oracle XML DB is a set of Oracle Database technologies related to high-performance</span></p><p class="c0"><span class="c1">XML storage and retrieval. XML DB provides native XML support by encompassing</span></p><p class="c0"><span class="c1">both SQL and XML data models in an interoperable manner.</span></p><p class="c0"><span class="c1">Oracle XML DB is suited for any Java or PL/SQL application where some or all of the</span></p><p class="c0"><span class="c1">data processed by the application is represented using XML. For example, the</span></p><p class="c0"><span class="c1">application may have large numbers of XML documents that must be ingested,</span></p><p class="c0"><span class="c1">generated, validated, and searched.</span></p><p class="c0"><span class="c1">Oracle XML DB provides many features, including the following:</span></p><p class="c0"><span class="c1">&#9632; The native XMLType data type, which can represent an XML document in the</span></p><p class="c0"><span class="c1">database so that it is accessible by SQL</span></p><p class="c0"><span class="c1">Table 19&ndash;1 Locale-Specific NLS Settings</span></p><p class="c0"><span class="c1">t Client Host 1 Client Host 2</span></p><p class="c0"><span class="c1">t0 $ export NLS_LANG=American_America.US7ASCII $ export NLS_LANG=German_Germany.US7ASCII</span></p><p class="c0"><span class="c1">t1 $ sqlplus /nolog</span></p><p class="c0"><span class="c1">SQL&gt; CONNECT hr@proddb</span></p><p class="c0"><span class="c1">Enter password: *******</span></p><p class="c0"><span class="c1">SQL&gt; SELECT 999/10 FROM DUAL;</span></p><p class="c0"><span class="c1">999/10</span></p><p class="c0"><span class="c1">----------</span></p><p class="c0"><span class="c1">99.9</span></p><p class="c0"><span class="c1">$ sqlplus /nolog</span></p><p class="c0"><span class="c1">SQL&gt; CONNECT hr@proddb</span></p><p class="c0"><span class="c1">Enter password: *******</span></p><p class="c0"><span class="c1">SQL&gt; SELECT 999/10 FROM DUAL;</span></p><p class="c0"><span class="c1">999/10</span></p><p class="c0"><span class="c1">----------</span></p><p class="c0"><span class="c1">99,9</span></p><p class="c0"><span class="c1">See Also: Oracle Database 2 Day + Java Developer&#39;s Guide and Oracle</span></p><p class="c0"><span class="c1">Database Globalization Support Guide to learn about NLS settings</span></p><p class="c0"><span class="c1">See Also: Oracle Database Globalization Support GuideTopics for Database Developers</span></p><p class="c0"><span class="c1">19-12 Oracle Database Concepts</span></p><p class="c0"><span class="c1">&#9632; Support for XML standards such as XML Schema, XPath, XQuery, XSLT, and DOM</span></p><p class="c0"><span class="c1">&#9632; XMLIndex, which supports all forms of XML data, from highly structured to</span></p><p class="c0"><span class="c1">completely unstructured</span></p><p class="c0"><span class="c1">Example 19&ndash;1 creates a table orders of type XMLType. The example also creates a SQL</span></p><p class="c0"><span class="c1">directory object, which is a logical name in the database for a physical directory on the</span></p><p class="c0"><span class="c1">host computer. This directory contains XML files. The example inserts XML content</span></p><p class="c0"><span class="c1">from the purchaseOrder.xml file into the orders table.</span></p><p class="c0"><span class="c1">Example 19&ndash;1 XMLType</span></p><p class="c0"><span class="c1">CREATE TABLE orders OF XMLType;</span></p><p class="c0"><span class="c1">CREATE DIRECTORY xmldir AS path_to_folder_containing_XML_file;</span></p><p class="c0"><span class="c1">INSERT INTO orders VALUES (XMLType(bfilename(&#39;XMLDIR&#39;, &#39;purchaseOrder.xml&#39;),</span></p><p class="c0"><span class="c1">nls_charset_id(&#39;AL32UTF8&#39;)));</span></p><p class="c0"><span class="c1">The Oracle XML developer&#39;s kits (XDK) contain the basic building blocks for reading,</span></p><p class="c0"><span class="c1">manipulating, transforming, and viewing XML documents, whether on a file system</span></p><p class="c0"><span class="c1">or in a database. APIs and tools are available for Java, C, and C++. The production</span></p><p class="c0"><span class="c1">Oracle XDKs are fully supported and come with a commercial redistribution license.</span></p><p class="c0"><span class="c1">Overview of LOBs</span></p><p class="c0"><span class="c1">The large object (LOB) data types enable you to store and manipulate large blocks of</span></p><p class="c0"><span class="c1">unstructured data in binary or character format. LOBs provide efficient, random,</span></p><p class="c0"><span class="c1">piece-wise access to the data.</span></p><p class="c0"><span class="c1">Internal LOBs An internal LOB stores data in the database itself rather than in external</span></p><p class="c0"><span class="c1">files. Internal LOBS include the following:</span></p><p class="c0"><span class="c1">&#9632; CLOB (character LOB), which stores large amounts of text, such as text or XML files,</span></p><p class="c0"><span class="c1">in the database character set</span></p><p class="c0"><span class="c1">&#9632; NCLOB (national character set LOB), which stores Unicode data</span></p><p class="c0"><span class="c1">&#9632; BLOB (binary LOB), which stores large amounts of binary information as a bit</span></p><p class="c0"><span class="c1">stream and is not subject to character set translation</span></p><p class="c0"><span class="c1">The database stores LOBs differently from other data types. Creating a LOB column</span></p><p class="c0"><span class="c1">implicitly creates a LOB segment and a LOB index (see &quot;User Segment Creation&quot; on</span></p><p class="c0"><span class="c1">page 12-21). The tablespace containing the LOB segment and LOB index, which are</span></p><p class="c0"><span class="c1">always stored together, may be different from the tablespace containing the table.</span></p><p class="c0"><span class="c1">The LOB segment stores data in pieces called chunks. A chunk is a logically</span></p><p class="c0"><span class="c1">contiguous set of data blocks and is the smallest unit of allocation for a LOB. A row in</span></p><p class="c0"><span class="c1">the table stores a pointer called a LOB locator, which points to the LOB index. When</span></p><p class="c0"><span class="c1">the table is queried, the database uses the LOB index to quickly locate the LOB chunks.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle XML DB Developer&#39;s Guide</span></p><p class="c0"><span class="c1">&#9632; Oracle XML Developer&#39;s Kit Programmer&#39;s Guide</span></p><p class="c0"><span class="c1">&#9632; Oracle Database XML Java API Reference</span></p><p class="c0"><span class="c1">Note: Sometimes the database can store small amounts of LOB data</span></p><p class="c0"><span class="c1">in the table itself rather than in a separate LOB segment.Topics for Database Developers</span></p><p class="c0"><span class="c1">Concepts for Database Developers 19-13</span></p><p class="c0"><span class="c1">The database manages read consistency for LOB segments differently from other data</span></p><p class="c0"><span class="c1">(see &quot;Read Consistency and Undo Segments&quot; on page 9-3). Instead of using undo data</span></p><p class="c0"><span class="c1">to record changes, the database stores the before images in the segment itself. When a</span></p><p class="c0"><span class="c1">transaction changes a LOB, the database allocates a new chunk and leaves the old data</span></p><p class="c0"><span class="c1">in place. If the transaction rolls back, then the database rolls back the changes to the</span></p><p class="c0"><span class="c1">index, which points to the old chunk.</span></p><p class="c0"><span class="c1">External LOBs A BFILE (binary file LOB) is an external LOB because the database stores</span></p><p class="c0"><span class="c1">a pointer to a file in the operating system. The external data is read-only.</span></p><p class="c0"><span class="c1">A BFILE uses a directory object to locate data. The amount of space consumed depends</span></p><p class="c0"><span class="c1">on the length of the directory object name and the length of the file name.</span></p><p class="c0"><span class="c1">A BFILE does not use the same read consistency mechanism as internal LOBS because</span></p><p class="c0"><span class="c1">the binary file is external to the database. If the data in the file changes, then repeated</span></p><p class="c0"><span class="c1">reads from the same binary file may produce different results.</span></p><p class="c0"><span class="c1">SecureFiles SecureFiles is a LOB data type specifically engineered to deliver high</span></p><p class="c0"><span class="c1">performance for file data comparable to that of traditional file systems, while retaining</span></p><p class="c0"><span class="c1">the advantages of Oracle Database. The SECUREFILE LOB parameter enables advanced</span></p><p class="c0"><span class="c1">features typically found in high-end file systems, such as deduplication, compression,</span></p><p class="c0"><span class="c1">encryption, and journaling.</span></p><p class="c0"><span class="c1">Overview of Oracle Text</span></p><p class="c0"><span class="c1">Oracle Text (Text) is a fast and accurate full-text retrieval technology integrated with</span></p><p class="c0"><span class="c1">Oracle Database. Oracle Text indexes any document or textual content stored in file</span></p><p class="c0"><span class="c1">systems, databases, or on the Web. These documents can be searched based on their</span></p><p class="c0"><span class="c1">textual content, metadata, or attributes.</span></p><p class="c0"><span class="c1">Oracle Text provides the following advantages:</span></p><p class="c0"><span class="c1">&#9632; Oracle Text allows text searches to be combined with regular database searches in</span></p><p class="c0"><span class="c1">a single SQL statement. The Text index is in the database, and Text queries are run</span></p><p class="c0"><span class="c1">in the Oracle Database process. The optimizer can choose the best execution plan</span></p><p class="c0"><span class="c1">for any query, giving the best performance for ad hoc queries involving Text and</span></p><p class="c0"><span class="c1">structured criteria.</span></p><p class="c0"><span class="c1">&#9632; You can use Oracle Text with XML data. In particular, you can combine XMLIndex</span></p><p class="c0"><span class="c1">with Oracle Text indexing, taking advantage of both XML and a full-text index.</span></p><p class="c0"><span class="c1">&#9632; The Oracle Text SQL API makes it simple and intuitive to create and maintain</span></p><p class="c0"><span class="c1">Oracle Text indexes and run searches.</span></p><p class="c0"><span class="c1">For a use case, suppose you must create a catalog index for an auction site that sells</span></p><p class="c0"><span class="c1">electronic equipment. New inventory is added every day. Item descriptions, bid dates,</span></p><p class="c0"><span class="c1">and prices must be stored together. The application requires good response time for</span></p><p class="c0"><span class="c1">mixed queries. First, you create and populate a catalog table. You then use Oracle Text</span></p><p class="c0"><span class="c1">to create a CTXCAT index that you can query with the CATSEARCH operator in a SELECT</span></p><p class="c0"><span class="c1">... WHERE CATSEARCH statement.</span></p><p class="c0"><span class="c1">Figure 19&ndash;4 illustrates the relation of the catalog table, its CTXCAT index, and the</span></p><p class="c0"><span class="c1">catalog application that uses the CATSEARCH operator to query the index.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; &quot;Oracle Data Types&quot; on page 2-9</span></p><p class="c0"><span class="c1">&#9632; Oracle Database SecureFiles and Large Objects Developer&#39;s Guide to</span></p><p class="c0"><span class="c1">learn more about LOB data typesTopics for Database Developers</span></p><p class="c0"><span class="c1">19-14 Oracle Database Concepts</span></p><p class="c0"><span class="c1">Figure 19&ndash;4 Catalog Query Application</span></p><p class="c0"><span class="c1">Overview of Oracle Multimedia</span></p><p class="c0"><span class="c1">Oracle Multimedia enables Oracle Database to store, manage, and retrieve images,</span></p><p class="c0"><span class="c1">medical images that follow the Digital Imaging and Communications in Medicine</span></p><p class="c0"><span class="c1">(DICOM) standard, audio, and video data in an integrated fashion with other</span></p><p class="c0"><span class="c1">enterprise information. Oracle Multimedia provides object types and methods for:</span></p><p class="c0"><span class="c1">&#9632; Extracting metadata and attributes from multimedia data</span></p><p class="c0"><span class="c1">&#9632; Embedding metadata created by applications into image and DICOM data</span></p><p class="c0"><span class="c1">&#9632; Obtaining and managing multimedia data from Oracle Database, Web servers, file</span></p><p class="c0"><span class="c1">systems, and other servers</span></p><p class="c0"><span class="c1">&#9632; Performing operations such as thumbnail generation on image and DICOM data</span></p><p class="c0"><span class="c1">&#9632; Making DICOM data anonymous</span></p><p class="c0"><span class="c1">&#9632; Checking DICOM data for conformity to user-defined validation rules</span></p><p class="c0"><span class="c1">Overview of Oracle Spatial</span></p><p class="c0"><span class="c1">Oracle Spatial (Spatial) provides a SQL schema and functions that facilitate the</span></p><p class="c0"><span class="c1">storage, retrieval, update, and query of collections of spatial features in an Oracle</span></p><p class="c0"><span class="c1">database. Oracle Spatial makes spatial data management easier to users of</span></p><p class="c0"><span class="c1">location-enabled applications and geographic information system (GIS) applications.</span></p><p class="c0"><span class="c1">An example of spatial data is a road map. The spatial data indicates the Earth location</span></p><p class="c0"><span class="c1">(such as longitude and latitude) of objects on the map. When the map is rendered, this</span></p><p class="c0"><span class="c1">spatial data is used to project the locations of the objects on a two-dimensional piece of</span></p><p class="c0"><span class="c1">paper. A GIS is often used to store, retrieve, and render this Earth-relative spatial data.</span></p><p class="c0"><span class="c1">When spatial data is stored in an Oracle database, the data can be easily manipulated,</span></p><p class="c0"><span class="c1">retrieved, and related to other data.</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Text Application Developer&#39;s Guide and Oracle Text Reference</span></p><p class="c0"><span class="c1">&#9632; Oracle XML DB Developer&#39;s Guide to learn how to perform full-text</span></p><p class="c0"><span class="c1">search over XML data</span></p><p class="c0"><span class="c1">See Also:</span></p><p class="c0"><span class="c1">&#9632; Oracle Multimedia User&#39;s Guide and Oracle Multimedia Reference</span></p><p class="c0"><span class="c1">&#9632; Oracle Multimedia DICOM Developer&#39;s Guide and Oracle Multimedia</span></p><p class="c0"><span class="c1">DICOM Java API Reference</span></p><p class="c0"><span class="c1">&#9632; Oracle Multimedia Java API Reference and Oracle Multimedia Servlets</span></p><p class="c0"><span class="c1">and JSP Java API Reference</span></p><p class="c0"><span class="c1">See Also: Oracle Spatial Developer&#39;s Guide</span></p><p class="c0"><span class="c1">Ctxcat</span></p><p class="c0"><span class="c1">Index</span></p><p class="c0"><span class="c1">Database</span></p><p class="c0"><span class="c1">SQL</span></p><p class="c0"><span class="c1">CATSEARCH</span></p><p class="c0"><span class="c1">Query</span></p><p class="c0"><span class="c1">Catalog</span></p><p class="c0"><span class="c1">Application</span></p><p class="c0"><span class="c1">Catalog TableGlossary-1</span></p><p class="c0"><span class="c1">Glossary</span></p><p class="c0"><span class="c1">access driver</span></p><p class="c0"><span class="c1">In the external table infrastructure, the API that interprets the external data for the</span></p><p class="c0"><span class="c1">database. The access driver runs inside the database, which uses the driver to read the</span></p><p class="c0"><span class="c1">data in the external table.</span></p><p class="c0"><span class="c1">access path</span></p><p class="c0"><span class="c1">The means by which data is retrieved from a database. For example, a query using an</span></p><p class="c0"><span class="c1">index and a query using a full table scan use different access paths.</span></p><p class="c0"><span class="c1">active transaction</span></p><p class="c0"><span class="c1">A transaction that has started but not yet committed or rolled back.</span></p><p class="c0"><span class="c1">ADDM</span></p><p class="c0"><span class="c1">Automatic Database Diagnostic Monitor. An Oracle Database infrastructure that</span></p><p class="c0"><span class="c1">enables a database to diagnose its own performance and determine how identified</span></p><p class="c0"><span class="c1">problems could be resolved.</span></p><p class="c0"><span class="c1">ADR</span></p><p class="c0"><span class="c1">Automatic Diagnostic Repository. A a file-based hierarchical data store for managing</span></p><p class="c0"><span class="c1">diagnostic information, including network tracing and logging.</span></p><p class="c0"><span class="c1">alert log</span></p><p class="c0"><span class="c1">A file that provides a chronological log of database messages and errors. The alert log</span></p><p class="c0"><span class="c1">is stored in the ADR.</span></p><p class="c0"><span class="c1">antijoin</span></p><p class="c0"><span class="c1">A join that returns rows from the left side of the predicate for which there are no</span></p><p class="c0"><span class="c1">corresponding rows on the right side of the predicate.</span></p><p class="c0"><span class="c1">application architecture</span></p><p class="c0"><span class="c1">The computing environment in which a database application connects to an Oracle</span></p><p class="c0"><span class="c1">database. The two most common database architectures are client/server and</span></p><p class="c0"><span class="c1">multitier.</span></p><p class="c0"><span class="c1">application domain index</span></p><p class="c0"><span class="c1">A customized index specific to an application.</span></p><p class="c0"><span class="c1">archived redo log file</span></p><p class="c0"><span class="c1">A member of the online redo log that has been archived by Oracle Database. The</span></p><p class="c0"><span class="c1">archived redo log files can be applied to a database backup in media recovery.ARCHIVELOG mode</span></p><p class="c0"><span class="c1">Glossary-2</span></p><p class="c0"><span class="c1">ARCHIVELOG mode</span></p><p class="c0"><span class="c1">A mode of the database that enables the archiving of the online redo log.</span></p><p class="c0"><span class="c1">ascending index</span></p><p class="c0"><span class="c1">An index in which data is stored in ascending order. By default, character data is</span></p><p class="c0"><span class="c1">ordered by the binary values contained in each byte of the value, numeric data from</span></p><p class="c0"><span class="c1">smallest to largest number, and date from earliest to latest value.</span></p><p class="c0"><span class="c1">Automatic Database Diagnostic Monitor (ADDM)</span></p><p class="c0"><span class="c1">See ADDM.</span></p><p class="c0"><span class="c1">Automatic Diagnostic Repository (ADR)</span></p><p class="c0"><span class="c1">See ADR.</span></p><p class="c0"><span class="c1">automatic undo management mode</span></p><p class="c0"><span class="c1">A mode of the database in which it automatically manages undo space in a dedicated</span></p><p class="c0"><span class="c1">undo tablespace.</span></p><p class="c0"><span class="c1">See also manual undo management mode.</span></p><p class="c0"><span class="c1">Automatic Workload Repository (AWR)</span></p><p class="c0"><span class="c1">See AWR.</span></p><p class="c0"><span class="c1">AWR</span></p><p class="c0"><span class="c1">Automatic Workload Repository (AWR). A built-in repository in every Oracle</span></p><p class="c0"><span class="c1">database. Oracle Database periodically makes a snapshot of its vital statistics and</span></p><p class="c0"><span class="c1">workload information and stores them in AWR.</span></p><p class="c0"><span class="c1">B-tree index</span></p><p class="c0"><span class="c1">An index organized like an upside-down tree. A B-tree index has two types of blocks:</span></p><p class="c0"><span class="c1">branch blocks for searching and leaf blocks that store values. The leaf blocks contain</span></p><p class="c0"><span class="c1">every indexed data value and a corresponding rowid used to locate the actual row. The</span></p><p class="c0"><span class="c1">&quot;B&quot; stands for &quot;balanced&quot; because all leaf blocks automatically stay at the same depth.</span></p><p class="c0"><span class="c1">background process</span></p><p class="c0"><span class="c1">A process that consolidates functions that would otherwise be handled by multiple</span></p><p class="c0"><span class="c1">Oracle programs running for each client process. The background processes</span></p><p class="c0"><span class="c1">asynchronously perform I/O and monitor other Oracle processes.</span></p><p class="c0"><span class="c1">See also instance; Oracle process.</span></p><p class="c0"><span class="c1">bind variable</span></p><p class="c0"><span class="c1">A placeholder in a SQL statement that must be replaced with a valid value or value</span></p><p class="c0"><span class="c1">address for the statement to execute successfully. By using bind variables, you can</span></p><p class="c0"><span class="c1">write a SQL statement that accepts inputs or parameters at run time. The following</span></p><p class="c0"><span class="c1">example shows a query that uses v_empid as a bind variable:</span></p><p class="c0"><span class="c1">SELECT * FROM employees WHERE employee_id = :v_empid;</span></p><p class="c0"><span class="c1">bitmap index</span></p><p class="c0"><span class="c1">A database index in which the database stores a bitmap for each index key instead of a</span></p><p class="c0"><span class="c1">list of rowids.</span></p><p class="c0"><span class="c1">bitmap join index</span></p><p class="c0"><span class="c1">A bitmap index for the join of two or more tables.checkpoint</span></p><p class="c0"><span class="c1">Glossary-3</span></p><p class="c0"><span class="c1">bitmap merge</span></p><p class="c0"><span class="c1">An operation that merges bitmaps retrieved from bitmap index scans. For example, if</span></p><p class="c0"><span class="c1">the gender and DOB columns have bitmap indexes, then the database may use a bitmap</span></p><p class="c0"><span class="c1">merge if the query predicate is WHERE gender=&#39;F&#39; AND DOB &gt; 1966.</span></p><p class="c0"><span class="c1">block corruption</span></p><p class="c0"><span class="c1">A data block that is not in a recognized Oracle format, or whose contents are not</span></p><p class="c0"><span class="c1">internally consistent.</span></p><p class="c0"><span class="c1">block header</span></p><p class="c0"><span class="c1">A part of a data block that includes information about the type of block, the address of</span></p><p class="c0"><span class="c1">the block, and sometimes transaction information.</span></p><p class="c0"><span class="c1">block overhead</span></p><p class="c0"><span class="c1">Space in a data block that stores metadata required for managing the block. The</span></p><p class="c0"><span class="c1">overhead includes the block header, table directory, and row directory.</span></p><p class="c0"><span class="c1">branch block</span></p><p class="c0"><span class="c1">In a B-tree index, a block that the database uses for searching. The leaf blocks store the</span></p><p class="c0"><span class="c1">index entries. The upper-level branch blocks of a B-tree index contain index data that</span></p><p class="c0"><span class="c1">points to lower-level index blocks.</span></p><p class="c0"><span class="c1">buffer</span></p><p class="c0"><span class="c1">A main memory address in the database buffer cache. A buffer caches currently and</span></p><p class="c0"><span class="c1">recently used data blocks read from disk. When a new block is needed, the database</span></p><p class="c0"><span class="c1">can replace an old data block with a new one.</span></p><p class="c0"><span class="c1">byte semantics</span></p><p class="c0"><span class="c1">Treatment of strings as a sequence of bytes. Offsets into strings and string lengths are</span></p><p class="c0"><span class="c1">expressed in bytes.</span></p><p class="c0"><span class="c1">cache recovery</span></p><p class="c0"><span class="c1">The phase of instance recovery where Oracle Database applies all committed and</span></p><p class="c0"><span class="c1">uncommitted changes in the online redo log files to the affected data blocks.</span></p><p class="c0"><span class="c1">cardinality</span></p><p class="c0"><span class="c1">The ratio of distinct values to the number of table rows. A column with only two</span></p><p class="c0"><span class="c1">distinct values in a million-row table would have low cardinality.</span></p><p class="c0"><span class="c1">character encoding</span></p><p class="c0"><span class="c1">A code that pairs each character from a given repertoire with a code unit to facilitate</span></p><p class="c0"><span class="c1">data storage.</span></p><p class="c0"><span class="c1">character semantics</span></p><p class="c0"><span class="c1">Treatment of strings as a sequence of characters. Offsets into strings and string lengths</span></p><p class="c0"><span class="c1">are expressed in characters (character codes).</span></p><p class="c0"><span class="c1">character set</span></p><p class="c0"><span class="c1">An encoding scheme used to display characters on your computer screen.</span></p><p class="c0"><span class="c1">checkpoint</span></p><p class="c0"><span class="c1">1. A data structure that marks the checkpoint position, which is the SCN in the redo</span></p><p class="c0"><span class="c1">thread where database instance recovery must begin. Checkpoints are recorded in theclient</span></p><p class="c0"><span class="c1">Glossary-4</span></p><p class="c0"><span class="c1">control file and each data file header, and are a crucial element of recovery.</span></p><p class="c0"><span class="c1">2. The writing of dirty data blocks in the database buffer cache to disk. The database</span></p><p class="c0"><span class="c1">writer (DBW) process writes blocks to disk to synchronize the buffer cache with the</span></p><p class="c0"><span class="c1">data files.</span></p><p class="c0"><span class="c1">client</span></p><p class="c0"><span class="c1">In client/server architecture, the front-end database application that interacts with a</span></p><p class="c0"><span class="c1">user. The client portion has no data access responsibilities.</span></p><p class="c0"><span class="c1">client process</span></p><p class="c0"><span class="c1">A process that executes the application or Oracle tool code. When users run client</span></p><p class="c0"><span class="c1">applications such as SQL*Plus, the operating system creates client processes to run the</span></p><p class="c0"><span class="c1">applications.</span></p><p class="c0"><span class="c1">See also Oracle process.</span></p><p class="c0"><span class="c1">client/server architecture</span></p><p class="c0"><span class="c1">Software architecture based on a separation of processing between two CPUs, one</span></p><p class="c0"><span class="c1">acting as the client in the transaction, requesting and receiving services, and the other</span></p><p class="c0"><span class="c1">as the server that provides services in a transaction.</span></p><p class="c0"><span class="c1">cluster file system</span></p><p class="c0"><span class="c1">A distributed file system that is a cluster of servers that collaborate to provide high</span></p><p class="c0"><span class="c1">performance service to their clients.</span></p><p class="c0"><span class="c1">cluster index</span></p><p class="c0"><span class="c1">A B-tree index on the cluster key.</span></p><p class="c0"><span class="c1">cluster key</span></p><p class="c0"><span class="c1">In a table cluster, the column or columns that the clustered tables have in common. For</span></p><p class="c0"><span class="c1">example, the employees and departments tables share the department_id column. You</span></p><p class="c0"><span class="c1">specify the cluster key when creating the table cluster and when creating every table</span></p><p class="c0"><span class="c1">added to the table cluster.</span></p><p class="c0"><span class="c1">column</span></p><p class="c0"><span class="c1">Vertical space in a table that represents a domain of data. A table definition includes a</span></p><p class="c0"><span class="c1">table name and set of columns. Each column has a name and data type.</span></p><p class="c0"><span class="c1">commit</span></p><p class="c0"><span class="c1">Action that ends a database transaction and makes permanent all changes performed</span></p><p class="c0"><span class="c1">in the transaction.</span></p><p class="c0"><span class="c1">composite index</span></p><p class="c0"><span class="c1">An index on multiple columns in a table.</span></p><p class="c0"><span class="c1">composite partitioning</span></p><p class="c0"><span class="c1">In partitioning strategy in which a table is partitioned by one data distribution method</span></p><p class="c0"><span class="c1">and then each partition is further divided into subpartitions using a second data</span></p><p class="c0"><span class="c1">distribution method.</span></p><p class="c0"><span class="c1">compression unit</span></p><p class="c0"><span class="c1">In Hybrid Columnar Compression, a logical construct that stores a set of rows. When</span></p><p class="c0"><span class="c1">you load data into a table, the database stores groups of rows in columnar format, withdatabase</span></p><p class="c0"><span class="c1">Glossary-5</span></p><p class="c0"><span class="c1">the values for each column stored and compressed together. After the database has</span></p><p class="c0"><span class="c1">compressed the column data for a set of rows, the database fits the data into the</span></p><p class="c0"><span class="c1">compression unit.</span></p><p class="c0"><span class="c1">concurrency</span></p><p class="c0"><span class="c1">Simultaneous access of the same data by many users. A multiuser database</span></p><p class="c0"><span class="c1">management system must provide adequate concurrency controls so that data cannot</span></p><p class="c0"><span class="c1">be updated or changed improperly, compromising data integrity.</span></p><p class="c0"><span class="c1">See also data consistency.</span></p><p class="c0"><span class="c1">condition</span></p><p class="c0"><span class="c1">The combination of one or more expressions and logical operators in a SQL statement</span></p><p class="c0"><span class="c1">that returns a value of TRUE, FALSE, or UNKNOWN. For example, the condition 1=1 always</span></p><p class="c0"><span class="c1">evaluates to TRUE.</span></p><p class="c0"><span class="c1">connection</span></p><p class="c0"><span class="c1">Communication pathway between a client process and an Oracle database instance.</span></p><p class="c0"><span class="c1">See also session.</span></p><p class="c0"><span class="c1">connection pooling</span></p><p class="c0"><span class="c1">A resource utilization and user scalability feature that maximizes the number of</span></p><p class="c0"><span class="c1">sessions over a limited number of protocol connections to a shared server.</span></p><p class="c0"><span class="c1">consistent backup</span></p><p class="c0"><span class="c1">A whole database backup that you can open with the RESETLOGS option without</span></p><p class="c0"><span class="c1">performing media recovery. In other words, the backup does not require the</span></p><p class="c0"><span class="c1">application of redo to be made consistent.</span></p><p class="c0"><span class="c1">See also inconsistent backup.</span></p><p class="c0"><span class="c1">context</span></p><p class="c0"><span class="c1">A set of application-defined attributes that validates and secures an application. The</span></p><p class="c0"><span class="c1">SQL statement CREATE CONTEXT creates namespaces for contexts.</span></p><p class="c0"><span class="c1">control file</span></p><p class="c0"><span class="c1">A binary file that records the physical structure of a database and contains the names</span></p><p class="c0"><span class="c1">and locations of redo log files, the time stamp of the database creation, the current log</span></p><p class="c0"><span class="c1">sequence number, checkpoint information, and so on.</span></p><p class="c0"><span class="c1">cube</span></p><p class="c0"><span class="c1">An organization of measures with identical dimensions and other shared</span></p><p class="c0"><span class="c1">characteristics. The edges of the cube contain the dimension members, whereas the</span></p><p class="c0"><span class="c1">body of the cube contains the data values.</span></p><p class="c0"><span class="c1">cursor</span></p><p class="c0"><span class="c1">A handle or name for a private SQL area in the PGA. Because cursors are closely</span></p><p class="c0"><span class="c1">associated with private SQL areas, the terms are sometimes used interchangeably.</span></p><p class="c0"><span class="c1">database</span></p><p class="c0"><span class="c1">Organized collection of data treated as a unit. The purpose of a database is to store and</span></p><p class="c0"><span class="c1">retrieve related information. Every Oracle database instance accesses only one</span></p><p class="c0"><span class="c1">database in its lifetime.database access control</span></p><p class="c0"><span class="c1">Glossary-6</span></p><p class="c0"><span class="c1">database access control</span></p><p class="c0"><span class="c1">The restriction of data access and database activities. For example, a database</span></p><p class="c0"><span class="c1">administrator can restrict users from querying specified tables or executing specified</span></p><p class="c0"><span class="c1">database commands.</span></p><p class="c0"><span class="c1">database application</span></p><p class="c0"><span class="c1">A software program that interacts with a database to access and manipulate data.</span></p><p class="c0"><span class="c1">database authentication</span></p><p class="c0"><span class="c1">The process by which a user presents credentials to the database, which verifies the</span></p><p class="c0"><span class="c1">credentials and allows access to the database.</span></p><p class="c0"><span class="c1">database buffer cache</span></p><p class="c0"><span class="c1">The portion of the system global area (SGA) that holds copies of data blocks. All</span></p><p class="c0"><span class="c1">client processes concurrently connected to the instance share access to the buffer</span></p><p class="c0"><span class="c1">cache.</span></p><p class="c0"><span class="c1">database instance</span></p><p class="c0"><span class="c1">The combination of the system global area (SGA) and background processes. An</span></p><p class="c0"><span class="c1">instance is associated with one and only one database. In an Oracle Real Application</span></p><p class="c0"><span class="c1">Clusters configuration, multiple instances access a single database simultaneously.</span></p><p class="c0"><span class="c1">database link</span></p><p class="c0"><span class="c1">In a schema object, a schema object in one database that enables users to access</span></p><p class="c0"><span class="c1">objects on a different database.</span></p><p class="c0"><span class="c1">database management system (DBMS)</span></p><p class="c0"><span class="c1">Software that controls the storage, organization, and retrieval of data.</span></p><p class="c0"><span class="c1">database object</span></p><p class="c0"><span class="c1">An object in the database that can be manipulated with SQL. Schema objects such as</span></p><p class="c0"><span class="c1">tables and indexes reside in schemas. Nonschema objects such as directories and roles</span></p><p class="c0"><span class="c1">do not reside in schemas.</span></p><p class="c0"><span class="c1">database security</span></p><p class="c0"><span class="c1">The aspect of database administration that involves user authentication, encryption,</span></p><p class="c0"><span class="c1">access control, and monitoring.</span></p><p class="c0"><span class="c1">database server</span></p><p class="c0"><span class="c1">A server that reliably manages a large amount of data in a multiuser environment so</span></p><p class="c0"><span class="c1">that users can concurrently access the same data. A database server also prevents</span></p><p class="c0"><span class="c1">unauthorized access and provides efficient solutions for failure recovery.</span></p><p class="c0"><span class="c1">database service</span></p><p class="c0"><span class="c1">A named representation of one or more database instances. The service name for an</span></p><p class="c0"><span class="c1">Oracle database is normally its global database name. Clients use the service name to</span></p><p class="c0"><span class="c1">connect to one or more database instances.</span></p><p class="c0"><span class="c1">database user</span></p><p class="c0"><span class="c1">An account through which you can log in to an Oracle database.</span></p><p class="c0"><span class="c1">database writer (DBW)</span></p><p class="c0"><span class="c1">A background process that writes buffers in the database buffer cache to data files.data segment</span></p><p class="c0"><span class="c1">Glossary-7</span></p><p class="c0"><span class="c1">data block</span></p><p class="c0"><span class="c1">Smallest logical unit of data storage in Oracle Database. Other names for data blocks</span></p><p class="c0"><span class="c1">include Oracle blocks or pages. One data block corresponds to a specific number of</span></p><p class="c0"><span class="c1">bytes of physical space on disk.</span></p><p class="c0"><span class="c1">See also extent; segment.</span></p><p class="c0"><span class="c1">data consistency</span></p><p class="c0"><span class="c1">A consistent view of the data by each user in a multiuser database.</span></p><p class="c0"><span class="c1">See also concurrency.</span></p><p class="c0"><span class="c1">data corruption</span></p><p class="c0"><span class="c1">An error that occurs when a hardware, software, or network component causes</span></p><p class="c0"><span class="c1">corrupt data to be read or written.</span></p><p class="c0"><span class="c1">data dictionary</span></p><p class="c0"><span class="c1">A read-only collection of database tables and views containing reference information</span></p><p class="c0"><span class="c1">about the database, its structures, and its users.</span></p><p class="c0"><span class="c1">data dictionary cache</span></p><p class="c0"><span class="c1">A memory area in the shared pool that holds data dictionary information. The data</span></p><p class="c0"><span class="c1">dictionary cache is also known as the row cache because it holds data as rows instead</span></p><p class="c0"><span class="c1">of buffers, which hold entire data blocks.</span></p><p class="c0"><span class="c1">data dictionary view</span></p><p class="c0"><span class="c1">A predefined view of tables or other views in the data dictionary. Data dictionary</span></p><p class="c0"><span class="c1">views begin with the prefix DBA_, ALL_, or USER_.</span></p><p class="c0"><span class="c1">data file</span></p><p class="c0"><span class="c1">A physical file on disk that was created by Oracle Database and contains the data for a</span></p><p class="c0"><span class="c1">database. The data files can be located either in an operating system file system or</span></p><p class="c0"><span class="c1">Oracle ASM disk group.</span></p><p class="c0"><span class="c1">data integrity</span></p><p class="c0"><span class="c1">Business rules that dictate the standards for acceptable data. These rules are applied to</span></p><p class="c0"><span class="c1">a database by using integrity constraints and triggers to prevent invalid data entry.</span></p><p class="c0"><span class="c1">data mining</span></p><p class="c0"><span class="c1">The automated search of large stores of data for patterns and trends that transcend</span></p><p class="c0"><span class="c1">simple analysis.</span></p><p class="c0"><span class="c1">Data Recovery Advisor</span></p><p class="c0"><span class="c1">An Oracle Database infrastructure that automatically diagnoses persistent data</span></p><p class="c0"><span class="c1">failures, presents repair options to the user, and executes repairs at the user&#39;s request.</span></p><p class="c0"><span class="c1">data segment</span></p><p class="c0"><span class="c1">The segment containing the data for a nonclustered table, table partition, or table</span></p><p class="c0"><span class="c1">cluster.</span></p><p class="c0"><span class="c1">See also extent.data type</span></p><p class="c0"><span class="c1">Glossary-8</span></p><p class="c0"><span class="c1">data type</span></p><p class="c0"><span class="c1">In SQL, a fixed set of properties associated with a column value or constant. Examples</span></p><p class="c0"><span class="c1">include VARCHAR2 and NUMBER. Oracle Database treats values of different data types</span></p><p class="c0"><span class="c1">differently.</span></p><p class="c0"><span class="c1">data warehouse</span></p><p class="c0"><span class="c1">A relational database designed for query and analysis rather than for OLTP.</span></p><p class="c0"><span class="c1">DDL</span></p><p class="c0"><span class="c1">Data definition language. Includes statements such as CREATE TABLE or ALTER INDEX</span></p><p class="c0"><span class="c1">that define or change a data structure.</span></p><p class="c0"><span class="c1">deadlock</span></p><p class="c0"><span class="c1">A situation in which two or more users are waiting for data locked by each other. Such</span></p><p class="c0"><span class="c1">deadlocks are rare in Oracle Database.</span></p><p class="c0"><span class="c1">dedicated server</span></p><p class="c0"><span class="c1">A database configuration in which a server process handles requests for a single client</span></p><p class="c0"><span class="c1">process.</span></p><p class="c0"><span class="c1">See also shared server.</span></p><p class="c0"><span class="c1">deferrable constraint</span></p><p class="c0"><span class="c1">A constraint that permits a SET CONSTRAINT statement to defer constraint checking</span></p><p class="c0"><span class="c1">until after the transaction is committed. A deferrable constraint enables you to disable</span></p><p class="c0"><span class="c1">the constraint temporarily while making changes that might violate the constraint.</span></p><p class="c0"><span class="c1">degree of parallelism</span></p><p class="c0"><span class="c1">The number of parallel execution servers associated with a single operation. Parallel</span></p><p class="c0"><span class="c1">execution is designed to effectively use multiple CPUs. Oracle Database parallel</span></p><p class="c0"><span class="c1">execution framework enables you to either explicitly choose a specific degree of</span></p><p class="c0"><span class="c1">parallelism or to rely on Oracle Database to automatically control it.</span></p><p class="c0"><span class="c1">dependent object</span></p><p class="c0"><span class="c1">In a schema object dependency, the object whose definition references another object.</span></p><p class="c0"><span class="c1">For example, if the definition of object A references object B, then A is a dependent</span></p><p class="c0"><span class="c1">object on B.</span></p><p class="c0"><span class="c1">descending index</span></p><p class="c0"><span class="c1">An index in which data is stored on a specified column or columns in descending</span></p><p class="c0"><span class="c1">order.</span></p><p class="c0"><span class="c1">dimension</span></p><p class="c0"><span class="c1">A structure that categorizes data to enable users to answer business questions.</span></p><p class="c0"><span class="c1">Commonly used dimensions are customers, products, and time.</span></p><p class="c0"><span class="c1">dimension table</span></p><p class="c0"><span class="c1">A relational table that stores all or part of the values for a dimension in a star or</span></p><p class="c0"><span class="c1">snowflake schema. Dimension tables typically contain columns for the dimension</span></p><p class="c0"><span class="c1">keys, levels, and attributes.equijoin</span></p><p class="c0"><span class="c1">Glossary-9</span></p><p class="c0"><span class="c1">direct-path INSERT</span></p><p class="c0"><span class="c1">An INSERT in which the database writes data directly to the data files, bypassing the</span></p><p class="c0"><span class="c1">database buffer cache. The database appends the inserted data to the existing data in</span></p><p class="c0"><span class="c1">the table.</span></p><p class="c0"><span class="c1">directory object</span></p><p class="c0"><span class="c1">A database object that specifies an alias for a directory on the server file system where</span></p><p class="c0"><span class="c1">external binary file LOBs (BFILEs) and external table data are located. All directory</span></p><p class="c0"><span class="c1">objects are created in a single namespace and are not owned by an individual schema.</span></p><p class="c0"><span class="c1">dirty read</span></p><p class="c0"><span class="c1">A transaction reads data that has been written by another transaction that has not been</span></p><p class="c0"><span class="c1">committed yet. Oracle Database never permits dirty reads.</span></p><p class="c0"><span class="c1">dispatcher</span></p><p class="c0"><span class="c1">See dispatcher process (Dnnn).</span></p><p class="c0"><span class="c1">dispatcher process (Dnnn)</span></p><p class="c0"><span class="c1">Optional background process present only when a shared server configuration is used.</span></p><p class="c0"><span class="c1">Each dispatcher process is responsible for routing requests from connected client</span></p><p class="c0"><span class="c1">processes to available shared server processes and returning the responses.</span></p><p class="c0"><span class="c1">distributed database</span></p><p class="c0"><span class="c1">A set of databases in a distributed system that can appear to applications as a single</span></p><p class="c0"><span class="c1">data source.</span></p><p class="c0"><span class="c1">distributed processing</span></p><p class="c0"><span class="c1">The operations that occurs when an application distributes its tasks among different</span></p><p class="c0"><span class="c1">computers in a network.</span></p><p class="c0"><span class="c1">distributed transaction</span></p><p class="c0"><span class="c1">A transaction that includes statements that, individually or as a group, update data on</span></p><p class="c0"><span class="c1">nodes of a distributed database. Oracle Database ensures the integrity of data in</span></p><p class="c0"><span class="c1">distributed transactions using the two-phase commit mechanism.</span></p><p class="c0"><span class="c1">DML</span></p><p class="c0"><span class="c1">Data manipulation language. Includes statements such as SELECT, INSERT, UPDATE, and</span></p><p class="c0"><span class="c1">DELETE.</span></p><p class="c0"><span class="c1">edition</span></p><p class="c0"><span class="c1">A private environment in which you can redefine database objects. Edition-based</span></p><p class="c0"><span class="c1">redefinition enables you to upgrade an application&#39;s database objects while the</span></p><p class="c0"><span class="c1">application is in use, thus minimizing or eliminating down time.</span></p><p class="c0"><span class="c1">encryption</span></p><p class="c0"><span class="c1">The process of transforming data into an unreadable format using a secret key and an</span></p><p class="c0"><span class="c1">encryption algorithm.</span></p><p class="c0"><span class="c1">equijoin</span></p><p class="c0"><span class="c1">A join with a join condition containing an equality operator.ETL</span></p><p class="c0"><span class="c1">Glossary-10</span></p><p class="c0"><span class="c1">ETL</span></p><p class="c0"><span class="c1">Extraction, transformation, and loading (ETL). The process of extracting data from</span></p><p class="c0"><span class="c1">source systems and bringing it into a data warehouse.</span></p><p class="c0"><span class="c1">execution plan</span></p><p class="c0"><span class="c1">The combination of steps used by the database to execute a SQL statement. Each step</span></p><p class="c0"><span class="c1">either retrieves rows of data physically from the database or prepares them for the</span></p><p class="c0"><span class="c1">user issuing the statement. You can override execution plans by using hints.</span></p><p class="c0"><span class="c1">expression</span></p><p class="c0"><span class="c1">A combination of one or more values, operators, and SQL functions that evaluates to a</span></p><p class="c0"><span class="c1">value. For example, the expression 2*2 evaluates to 4. In general, expressions assume</span></p><p class="c0"><span class="c1">the data type of their components.</span></p><p class="c0"><span class="c1">extent</span></p><p class="c0"><span class="c1">Multiple contiguous data blocks allocated for storing a specific type of information. A</span></p><p class="c0"><span class="c1">segment is made up of one or more extents.</span></p><p class="c0"><span class="c1">See also data block.</span></p><p class="c0"><span class="c1">external table</span></p><p class="c0"><span class="c1">A read-only table whose metadata is stored in the database but whose data in stored in</span></p><p class="c0"><span class="c1">files outside the database. The database uses the metadata describing external tables to</span></p><p class="c0"><span class="c1">expose their data as if they were relational tables.</span></p><p class="c0"><span class="c1">extraction, transformation, and loading (ETL)</span></p><p class="c0"><span class="c1">See ETL.</span></p><p class="c0"><span class="c1">fact</span></p><p class="c0"><span class="c1">Data that represents a business measure, such as sales or cost data.</span></p><p class="c0"><span class="c1">fact table</span></p><p class="c0"><span class="c1">A table in a star schema of a data warehouse that contains factual data. A fact table</span></p><p class="c0"><span class="c1">typically has two types of columns: those that contain facts and those that are foreign</span></p><p class="c0"><span class="c1">keys to dimension tables.</span></p><p class="c0"><span class="c1">fast full index scan</span></p><p class="c0"><span class="c1">A full index scan in which the database reads the index blocks in no particular order.</span></p><p class="c0"><span class="c1">The database accesses the data in the index itself, without accessing the table.</span></p><p class="c0"><span class="c1">fast recovery area</span></p><p class="c0"><span class="c1">An optional disk location that stores recovery-related files such as control file and</span></p><p class="c0"><span class="c1">online redo log copies, archived redo log files, flashback logs, and RMAN backups.</span></p><p class="c0"><span class="c1">field</span></p><p class="c0"><span class="c1">In a table, the intersection of a row and column.</span></p><p class="c0"><span class="c1">file system</span></p><p class="c0"><span class="c1">A data structure built inside a contiguous disk address space.hash collision</span></p><p class="c0"><span class="c1">Glossary-11</span></p><p class="c0"><span class="c1">foreign key</span></p><p class="c0"><span class="c1">An integrity constraint that requires each value in a column or set of columns to</span></p><p class="c0"><span class="c1">match a value in the unique or primary key for a related table. Integrity constraints for</span></p><p class="c0"><span class="c1">foreign keys define actions dictating database behavior if referenced data is altered.</span></p><p class="c0"><span class="c1">format model</span></p><p class="c0"><span class="c1">A character literal that describes the format of a datetime in a character string.</span></p><p class="c0"><span class="c1">full index scan</span></p><p class="c0"><span class="c1">A scan of an index in which the database reads the entire index in order.</span></p><p class="c0"><span class="c1">full table scan</span></p><p class="c0"><span class="c1">A scan of table data in which the database sequentially reads all rows from a table and</span></p><p class="c0"><span class="c1">filters out those that do not meet the selection criteria. All data blocks under the high</span></p><p class="c0"><span class="c1">water mark are scanned.</span></p><p class="c0"><span class="c1">function</span></p><p class="c0"><span class="c1">A schema object, similar to a PL/SQL procedure, that always returns a single value.</span></p><p class="c0"><span class="c1">function-based index</span></p><p class="c0"><span class="c1">An index that computes the value of a function or expression involving one or more</span></p><p class="c0"><span class="c1">columns and stores it in the index.</span></p><p class="c0"><span class="c1">granule</span></p><p class="c0"><span class="c1">The basic unit of work in parallelism. Oracle Database divides the operation executed</span></p><p class="c0"><span class="c1">in parallel (for example, a table scan, table update, or index creation) into granules.</span></p><p class="c0"><span class="c1">Parallel execution processes execute the operation one granule at a time.</span></p><p class="c0"><span class="c1">grid computing</span></p><p class="c0"><span class="c1">A computing architecture that coordinates large numbers of servers and storage to act</span></p><p class="c0"><span class="c1">as a single large computer.</span></p><p class="c0"><span class="c1">grid infrastructure</span></p><p class="c0"><span class="c1">The software that provides the infrastructure for an enterprise grid architecture. In a</span></p><p class="c0"><span class="c1">cluster, this software includes Oracle Clusterware and Oracle ASM. For a standalone</span></p><p class="c0"><span class="c1">server, this software includes Oracle Restart and Oracle ASM. Oracle Database 11g</span></p><p class="c0"><span class="c1">Release 2 (11.2) combines these infrastructure products into one software installation</span></p><p class="c0"><span class="c1">called the grid infrastructure home.</span></p><p class="c0"><span class="c1">hard parse</span></p><p class="c0"><span class="c1">The steps performed by the database to build a new executable version of application</span></p><p class="c0"><span class="c1">code. The database must perform a hard parse instead of a soft parse if the parsed</span></p><p class="c0"><span class="c1">representation of a submitted statement does not exist in the shared pool.</span></p><p class="c0"><span class="c1">hash cluster</span></p><p class="c0"><span class="c1">A type of table cluster that is similar to an indexed cluster, except the index key is</span></p><p class="c0"><span class="c1">replaced with a hash function. No separate cluster index exists. In a hash cluster, the</span></p><p class="c0"><span class="c1">data is the index.</span></p><p class="c0"><span class="c1">hash collision</span></p><p class="c0"><span class="c1">Hashing multiple input values to the same output value.hash function</span></p><p class="c0"><span class="c1">Glossary-12</span></p><p class="c0"><span class="c1">hash function</span></p><p class="c0"><span class="c1">A function that operates on an arbitrary-length input value and returns a fixed-length</span></p><p class="c0"><span class="c1">hash value.</span></p><p class="c0"><span class="c1">hash join</span></p><p class="c0"><span class="c1">A join in which the database uses the smaller of two tables or data sources to build a</span></p><p class="c0"><span class="c1">hash table in memory. The database scans the larger table, probing the hash table for</span></p><p class="c0"><span class="c1">the addresses of the matching rows in the smaller table.</span></p><p class="c0"><span class="c1">hash key value</span></p><p class="c0"><span class="c1">In a hash cluster, an actual or possible value inserted into the cluster key column. For</span></p><p class="c0"><span class="c1">example, if the cluster key is department_id, then hash key values could be 10, 20, 30,</span></p><p class="c0"><span class="c1">and so on.</span></p><p class="c0"><span class="c1">hash table</span></p><p class="c0"><span class="c1">An in-memory data structure that associates join keys with rows in a hash join. For</span></p><p class="c0"><span class="c1">example, in a join of the employees and departments tables, the join key might be the</span></p><p class="c0"><span class="c1">department ID. A hash function uses the join key to generate a hash value. This hash</span></p><p class="c0"><span class="c1">value is an index in an array, which is the hash table.</span></p><p class="c0"><span class="c1">hash value</span></p><p class="c0"><span class="c1">In a hash cluster, a unique numeric ID that identifies a bucket. Oracle Database uses a</span></p><p class="c0"><span class="c1">hash function that accepts an infinite number of hash key values as input and sorts</span></p><p class="c0"><span class="c1">them into a finite number of buckets. Each hash value maps to the database block</span></p><p class="c0"><span class="c1">address for the block that stores the rows corresponding to the hash key value</span></p><p class="c0"><span class="c1">(department 10, 20, 30, and so on).</span></p><p class="c0"><span class="c1">hashing</span></p><p class="c0"><span class="c1">A mathematical technique in which an infinite set of input values is mapped to a finite</span></p><p class="c0"><span class="c1">set of output values, called hash values. Hashing is useful for rapid lookups of data in</span></p><p class="c0"><span class="c1">a hash table.</span></p><p class="c0"><span class="c1">heap-organized table</span></p><p class="c0"><span class="c1">A table in which the data rows are stored in no particular order on disk. By default,</span></p><p class="c0"><span class="c1">CREATE TABLE creates a heap-organized table.</span></p><p class="c0"><span class="c1">hierarchical database</span></p><p class="c0"><span class="c1">A database that organizes data in a tree structure. Each parent record has one or more</span></p><p class="c0"><span class="c1">child records, similar to the structure of a file system.</span></p><p class="c0"><span class="c1">high water mark</span></p><p class="c0"><span class="c1">The boundary between used and unused space in a segment.</span></p><p class="c0"><span class="c1">hint</span></p><p class="c0"><span class="c1">An instruction passed to the optimizer through comments in a SQL statement. The</span></p><p class="c0"><span class="c1">optimizer uses hints to choose an execution plan for the statement.</span></p><p class="c0"><span class="c1">human error outage</span></p><p class="c0"><span class="c1">An outage that occurs when unintentional or malicious actions are committed that</span></p><p class="c0"><span class="c1">cause data in the database to become logically corrupt or unusable.index unique scan</span></p><p class="c0"><span class="c1">Glossary-13</span></p><p class="c0"><span class="c1">implicit query</span></p><p class="c0"><span class="c1">A component of a DML statement that retrieves data without a subquery. An UPDATE,</span></p><p class="c0"><span class="c1">DELETE, or MERGE statement that does not explicitly include a SELECT statement uses an</span></p><p class="c0"><span class="c1">implicit query to retrieve the rows to be modified.</span></p><p class="c0"><span class="c1">inconsistent backup</span></p><p class="c0"><span class="c1">A backup in which some files in the backup contain changes made after the</span></p><p class="c0"><span class="c1">checkpoint. Unlike a consistent backup, an inconsistent backup requires media</span></p><p class="c0"><span class="c1">recovery to be made consistent.</span></p><p class="c0"><span class="c1">index</span></p><p class="c0"><span class="c1">Optional schema object associated with a nonclustered table, table partition, or table</span></p><p class="c0"><span class="c1">cluster. In some cases indexes speed data access.</span></p><p class="c0"><span class="c1">index block</span></p><p class="c0"><span class="c1">A special type of data block that manages space differently from table blocks.</span></p><p class="c0"><span class="c1">index cluster</span></p><p class="c0"><span class="c1">An table cluster that uses an index to locate data. The cluster index is a B-tree index on</span></p><p class="c0"><span class="c1">the cluster key.</span></p><p class="c0"><span class="c1">index clustering factor</span></p><p class="c0"><span class="c1">A measure of the row order in relation to an indexed value such as last name. The</span></p><p class="c0"><span class="c1">more order that exists in row storage for this value, the lower the clustering factor.</span></p><p class="c0"><span class="c1">index-organized table</span></p><p class="c0"><span class="c1">A table whose storage organization is a variant of a primary B-tree index. Unlike a</span></p><p class="c0"><span class="c1">heap-organized table, data is stored in primary key order.</span></p><p class="c0"><span class="c1">index range scan</span></p><p class="c0"><span class="c1">An ordered scan of an index that has the following characteristics:</span></p><p class="c0"><span class="c1">&#9632; One or more leading columns of an index are specified in conditions. A condition</span></p><p class="c0"><span class="c1">specifies a combination of one or more expressions and logical (Boolean) operators</span></p><p class="c0"><span class="c1">and returns a value of TRUE, FALSE, or UNKNOWN.</span></p><p class="c0"><span class="c1">&#9632; 0, 1, or more values are possible for an index key.</span></p><p class="c0"><span class="c1">index scan</span></p><p class="c0"><span class="c1">The retrieval of a row by traversing an index, using the indexed column values</span></p><p class="c0"><span class="c1">specified by the statement.</span></p><p class="c0"><span class="c1">index segment</span></p><p class="c0"><span class="c1">A segment that stores data for a nonpartitioned index or index partition.</span></p><p class="c0"><span class="c1">index skip scan</span></p><p class="c0"><span class="c1">An index scan that uses logical subindexes of a composite index. The database &quot;skips&quot;</span></p><p class="c0"><span class="c1">through a single index as if it were searching separate indexes.</span></p><p class="c0"><span class="c1">index unique scan</span></p><p class="c0"><span class="c1">An index scan that must have either 0 or 1 rowid associated with an index key. The</span></p><p class="c0"><span class="c1">database performs a unique scan when a predicate references all of the columns in the</span></p><p class="c0"><span class="c1">key of a UNIQUE index using an equality operator.in-flight transaction</span></p><p class="c0"><span class="c1">Glossary-14</span></p><p class="c0"><span class="c1">in-flight transaction</span></p><p class="c0"><span class="c1">A transaction that is running when an outage breaks the connection between a client</span></p><p class="c0"><span class="c1">application and the database.</span></p><p class="c0"><span class="c1">information system</span></p><p class="c0"><span class="c1">A formal system for storing and processing information.</span></p><p class="c0"><span class="c1">initialization parameter</span></p><p class="c0"><span class="c1">A configuration parameter such as DB_NAME or SGA_TARGET that affects the operation of</span></p><p class="c0"><span class="c1">a database instance. Settings for initialization parameters are stored in a text-based</span></p><p class="c0"><span class="c1">initialization parameter file or binary server parameter file.</span></p><p class="c0"><span class="c1">initialization parameter file</span></p><p class="c0"><span class="c1">A text file that contains initialization parameter settings for a database instance.</span></p><p class="c0"><span class="c1">inner join</span></p><p class="c0"><span class="c1">A join of two or more tables that returns only those rows that satisfy the join condition.</span></p><p class="c0"><span class="c1">instance</span></p><p class="c0"><span class="c1">The combination of the system global area (SGA) and background processes. An</span></p><p class="c0"><span class="c1">instance is associated with one and only one database. In an Oracle Real Application</span></p><p class="c0"><span class="c1">Clusters configuration, multiple instances access a single database simultaneously.</span></p><p class="c0"><span class="c1">instance failure</span></p><p class="c0"><span class="c1">The termination of a database instance because of a hardware failure, Oracle internal</span></p><p class="c0"><span class="c1">error, or SHUTDOWN ABORT statement.</span></p><p class="c0"><span class="c1">instance recovery</span></p><p class="c0"><span class="c1">The automatic application of redo log records to uncommitted data blocks when an</span></p><p class="c0"><span class="c1">instance is restarted after a failure.</span></p><p class="c0"><span class="c1">integrity</span></p><p class="c0"><span class="c1">See data integrity.</span></p><p class="c0"><span class="c1">integrity constraint</span></p><p class="c0"><span class="c1">Declarative method of defining a rule for a column. The integrity constraints enforce</span></p><p class="c0"><span class="c1">business rules and prevent the entry of invalid information into tables.</span></p><p class="c0"><span class="c1">interested transaction list (ITL)</span></p><p class="c0"><span class="c1">Information in the block header of every segment that determines whether a</span></p><p class="c0"><span class="c1">transaction was uncommitted when the database began modifying the block. Entries</span></p><p class="c0"><span class="c1">in the ITL describe which transactions have rows locked and which rows in the block</span></p><p class="c0"><span class="c1">contain committed and uncommitted changes.</span></p><p class="c0"><span class="c1">invisible index</span></p><p class="c0"><span class="c1">An index that is maintained by DML operations, but is not used by default by the</span></p><p class="c0"><span class="c1">optimizer. Making an index invisible is an alternative to making it unusable or</span></p><p class="c0"><span class="c1">dropping it.</span></p><p class="c0"><span class="c1">join</span></p><p class="c0"><span class="c1">A statement that retrieves data from multiple tables specified in the FROM clause. Join</span></p><p class="c0"><span class="c1">types include inner joins, outer joins, and Cartesian joins.locally managed tablespace</span></p><p class="c0"><span class="c1">Glossary-15</span></p><p class="c0"><span class="c1">join condition</span></p><p class="c0"><span class="c1">A condition that compares two columns, each from a different table, in a join. The</span></p><p class="c0"><span class="c1">database combines pairs of rows, each containing one row from each table, for which</span></p><p class="c0"><span class="c1">the join condition evaluates to TRUE.</span></p><p class="c0"><span class="c1">key</span></p><p class="c0"><span class="c1">Column or set of columns included in the definition of certain types of integrity</span></p><p class="c0"><span class="c1">constraints.</span></p><p class="c0"><span class="c1">key compression</span></p><p class="c0"><span class="c1">The elimination of repeated occurrence of primary key column values in an</span></p><p class="c0"><span class="c1">index-organized table.</span></p><p class="c0"><span class="c1">key values</span></p><p class="c0"><span class="c1">Individual values in a key.</span></p><p class="c0"><span class="c1">large object (LOB)</span></p><p class="c0"><span class="c1">See LOB.</span></p><p class="c0"><span class="c1">large pool</span></p><p class="c0"><span class="c1">Optional area in the SGA that provides large memory allocations for backup and</span></p><p class="c0"><span class="c1">restore operations, I/O server processes, and session memory for the shared server</span></p><p class="c0"><span class="c1">and Oracle XA.</span></p><p class="c0"><span class="c1">latch</span></p><p class="c0"><span class="c1">A low-level serialization control mechanism used to protect shared data structures in</span></p><p class="c0"><span class="c1">the SGA from simultaneous access.</span></p><p class="c0"><span class="c1">leaf block</span></p><p class="c0"><span class="c1">In a B-tree index, a lower-level block that stores index entries. The upper-level branch</span></p><p class="c0"><span class="c1">blocks of a B-tree index contain index data that points to lower-level index blocks.</span></p><p class="c0"><span class="c1">library cache</span></p><p class="c0"><span class="c1">An area of memory in the shared pool. This cache includes the shared SQL areas,</span></p><p class="c0"><span class="c1">private SQL areas (in a shared server configuration), PL/SQL procedures and</span></p><p class="c0"><span class="c1">packages, and control structures such as locks and library cache handles.</span></p><p class="c0"><span class="c1">listener</span></p><p class="c0"><span class="c1">A process that listens for incoming client connection requests and manages network</span></p><p class="c0"><span class="c1">traffic to the database.</span></p><p class="c0"><span class="c1">literal</span></p><p class="c0"><span class="c1">A fixed data value.</span></p><p class="c0"><span class="c1">LOB</span></p><p class="c0"><span class="c1">Large object. An Oracle data type designed to hold large amounts of data.</span></p><p class="c0"><span class="c1">locally managed tablespace</span></p><p class="c0"><span class="c1">A tablespace that uses a bitmap stored in each data file to manage the extents. In</span></p><p class="c0"><span class="c1">contrast, a dictionary-managed tablespace uses the data dictionary to manage space.lock</span></p><p class="c0"><span class="c1">Glossary-16</span></p><p class="c0"><span class="c1">lock</span></p><p class="c0"><span class="c1">A database mechanism that prevents destructive interaction between transactions</span></p><p class="c0"><span class="c1">accessing a shared resource such as a table, row, or system object not visible to users.</span></p><p class="c0"><span class="c1">The main categories of locks are DML locks, DDL locks, and latches and internal locks.</span></p><p class="c0"><span class="c1">logical transaction ID</span></p><p class="c0"><span class="c1">A globally unique identifier that defines a transaction from the application</span></p><p class="c0"><span class="c1">perspective. The logical transaction ID is bound to the database transaction ID.</span></p><p class="c0"><span class="c1">logical volume</span></p><p class="c0"><span class="c1">A virtual disk partition.</span></p><p class="c0"><span class="c1">logical volume manager (LVM)</span></p><p class="c0"><span class="c1">A software package, available with most operating systems, that enables pieces of</span></p><p class="c0"><span class="c1">multiple physical disks to be combined into a single contiguous address space that</span></p><p class="c0"><span class="c1">appears as one disk to higher layers of software.</span></p><p class="c0"><span class="c1">log sequence number</span></p><p class="c0"><span class="c1">A number that uniquely identifies a set of redo records in a redo log file. When the</span></p><p class="c0"><span class="c1">database fills one online redo log file and switches to a different one, the database</span></p><p class="c0"><span class="c1">automatically assigns the new file a log sequence number.</span></p><p class="c0"><span class="c1">log switch</span></p><p class="c0"><span class="c1">The point at which the log writer (LGWR) stops writing to the active redo log file and</span></p><p class="c0"><span class="c1">switches to the next available redo log file. LGWR switches when either the active redo</span></p><p class="c0"><span class="c1">log file is filled with redo records or a switch is manually initiated.</span></p><p class="c0"><span class="c1">log writer (LGWR)</span></p><p class="c0"><span class="c1">The background process responsible for redo log buffer management&mdash;writing the</span></p><p class="c0"><span class="c1">redo log buffer to the online redo log. LGWR writes all redo entries that have been</span></p><p class="c0"><span class="c1">copied into the buffer since the last time it wrote.</span></p><p class="c0"><span class="c1">lookup table</span></p><p class="c0"><span class="c1">A table containing a code column and an associated value column. For example, a job</span></p><p class="c0"><span class="c1">code corresponds to a job name. In contrast to a master table in a pair of master-detail</span></p><p class="c0"><span class="c1">tables, a lookup table is not the means to obtain a detailed result set, such as a list of</span></p><p class="c0"><span class="c1">employees. Rather, a user queries a table such as employees for an employee list and</span></p><p class="c0"><span class="c1">then joins the result set to the lookup table.</span></p><p class="c0"><span class="c1">lost update</span></p><p class="c0"><span class="c1">A data integrity problem in which one writer of data overwrites the changes of a</span></p><p class="c0"><span class="c1">different writer modifying the same data.</span></p><p class="c0"><span class="c1">mantissa</span></p><p class="c0"><span class="c1">The part of a floating-point number that contains its significant digits.</span></p><p class="c0"><span class="c1">manual undo management mode</span></p><p class="c0"><span class="c1">A mode of the database in which undo blocks are stored in user-managed undo</span></p><p class="c0"><span class="c1">segments. In automatic undo management mode, undo blocks are stored in a</span></p><p class="c0"><span class="c1">system-managed, dedicated undo tablespaces.object type</span></p><p class="c0"><span class="c1">Glossary-17</span></p><p class="c0"><span class="c1">master-detail tables</span></p><p class="c0"><span class="c1">A detail table has a foreign key relationship with a master table. For example, the</span></p><p class="c0"><span class="c1">employees detail table has a foreign key to the departments master table. Unlike a</span></p><p class="c0"><span class="c1">lookup table, a master table is typically queried and then joined to the detail table. For</span></p><p class="c0"><span class="c1">example, a user may query a department in the departments table and then use this</span></p><p class="c0"><span class="c1">result to find the employees in this department.</span></p><p class="c0"><span class="c1">master site</span></p><p class="c0"><span class="c1">In a replication environment, a different database with which a materialized view</span></p><p class="c0"><span class="c1">shares data.</span></p><p class="c0"><span class="c1">master table</span></p><p class="c0"><span class="c1">The table associated with a materialized view at a master site.</span></p><p class="c0"><span class="c1">materialized view</span></p><p class="c0"><span class="c1">A schema object that stores the result of a query. Oracle materialized views can be</span></p><p class="c0"><span class="c1">read-only or updatable.</span></p><p class="c0"><span class="c1">See also view.</span></p><p class="c0"><span class="c1">media recovery</span></p><p class="c0"><span class="c1">The application of redo or incremental backups to a data block or backup data file.</span></p><p class="c0"><span class="c1">mounted database</span></p><p class="c0"><span class="c1">An instance that is started and has the database control file open.</span></p><p class="c0"><span class="c1">multitier architecture</span></p><p class="c0"><span class="c1">An architecture in which one or more application servers provide data for clients and</span></p><p class="c0"><span class="c1">serves as an interface between clients and database servers.</span></p><p class="c0"><span class="c1">network database</span></p><p class="c0"><span class="c1">A type of database, similar to a hierarchical database, in which records have a</span></p><p class="c0"><span class="c1">many-to-many rather than a one-to-many relationship.</span></p><p class="c0"><span class="c1">network encryption</span></p><p class="c0"><span class="c1">Encrypting data as it travels across the network between a client and server.</span></p><p class="c0"><span class="c1">null</span></p><p class="c0"><span class="c1">Absence of a value in a column of a row. Nulls indicate missing, unknown, or</span></p><p class="c0"><span class="c1">inapplicable data.</span></p><p class="c0"><span class="c1">object-relational database management system (ORDBMS)</span></p><p class="c0"><span class="c1">An RDBMS that implements object-oriented features such as user-defined types,</span></p><p class="c0"><span class="c1">inheritance, and polymorphism.</span></p><p class="c0"><span class="c1">object table</span></p><p class="c0"><span class="c1">An special kind of table in which each row represents an object.</span></p><p class="c0"><span class="c1">object type</span></p><p class="c0"><span class="c1">A schema object that abstracts a real-world entity such as a purchase order. Attributes</span></p><p class="c0"><span class="c1">model the structure of the entity, whereas methods implement operations an</span></p><p class="c0"><span class="c1">application can perform on the entity.OLAP</span></p><p class="c0"><span class="c1">Glossary-18</span></p><p class="c0"><span class="c1">OLAP</span></p><p class="c0"><span class="c1">Online Analytical Processing. OLAP is characterized by dynamic, dimensional</span></p><p class="c0"><span class="c1">analysis of historical data.</span></p><p class="c0"><span class="c1">OLTP</span></p><p class="c0"><span class="c1">Online Transaction Processing. OLTP systems are optimized for fast and reliable</span></p><p class="c0"><span class="c1">transaction handling. Compared to data warehouse systems, most OLTP interactions</span></p><p class="c0"><span class="c1">involve a relatively small number of rows, but a larger group of tables.</span></p><p class="c0"><span class="c1">online redo log</span></p><p class="c0"><span class="c1">The set of two or more online redo log files that record all changes made to Oracle</span></p><p class="c0"><span class="c1">Database data files and control file. When a change is made to the database, Oracle</span></p><p class="c0"><span class="c1">Database generates a redo record in the redo buffer. log writer (LGWR) writes the</span></p><p class="c0"><span class="c1">contents of the redo buffer to the online redo log.</span></p><p class="c0"><span class="c1">operator</span></p><p class="c0"><span class="c1">1. In memory management, operators control the flow of data. Examples include sort,</span></p><p class="c0"><span class="c1">hash join, and bitmap merge operators.</span></p><p class="c0"><span class="c1">2. In SQL, an operator manipulates data items called operands or arguments and</span></p><p class="c0"><span class="c1">returns a result. The SQL operators are represented by special characters or by</span></p><p class="c0"><span class="c1">keywords. For example, the multiplication operator is represented by an asterisk (*).</span></p><p class="c0"><span class="c1">optimizer</span></p><p class="c0"><span class="c1">Built-in database software that determines the most efficient way to execute a SQL</span></p><p class="c0"><span class="c1">statement by considering factors related to the objects referenced and the conditions</span></p><p class="c0"><span class="c1">specified in the statement.</span></p><p class="c0"><span class="c1">Oracle architecture</span></p><p class="c0"><span class="c1">Memory and process structures used by Oracle Database to manage a database.</span></p><p class="c0"><span class="c1">Oracle Automatic Storage Management (Oracle ASM)</span></p><p class="c0"><span class="c1">See Oracle ASM.</span></p></body></html>